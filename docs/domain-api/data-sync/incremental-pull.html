<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Incremental pull by last update time | ERP.net Developer Docs </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Incremental pull by last update time | ERP.net Developer Docs ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/ErpNetDocs/dev/blob/master/domain-api/data-sync/incremental-pull.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="incremental-pull-by-last-update-time">Incremental pull by last update time</h1>

<h2 id="overview">Overview</h2>
<p>Some integrations need to periodically pull only the entities that have changed since the last successful synchronization run (incremental sync).</p>
<p>Starting from v26.2, aggregate root entities expose a calculated attribute <code>AggregateLastUpdateTimeUtc</code>, which can be used to implement incremental pulls via Domain API.</p>
<p><code>AggregateLastUpdateTimeUtc</code> is a UTC timestamp.</p>
<h2 id="getting-started">Getting started</h2>
<h3 id="1-select-the-last-update-timestamp">1) Select the last update timestamp</h3>
<p>To retrieve the value, explicitly select <code>AggregateLastUpdateTimeUtc</code>:</p>
<pre><code class="lang-http">General_Products_Products?$top=10&amp;$select=Id,AggregateLastUpdateTimeUtc,PartNumber
</code></pre>
<h3 id="2-first-synchronization-run-full-initial-sync">2) First synchronization run (full initial sync)</h3>
<p>On the first run there is no watermark. If you want a complete local copy, the recommended approach is to do a full initial pull and only then start incremental pulls.</p>
<p>Recommended approach (full initial sync):</p>
<ol>
<li>Perform a full pull (no filter on <code>AggregateLastUpdateTimeUtc</code>).</li>
<li>Always use paging (<code>$top</code>) and follow <code>@odata.nextLink</code> until completion.</li>
<li>Process each item idempotently (upsert).</li>
<li>While processing all pages, track <code>maxSeenUtc</code> = the maximum <code>AggregateLastUpdateTimeUtc</code> value you have successfully processed.</li>
<li>Persist the watermark only after the whole initial run finishes successfully:
<ul>
<li><code>watermarkUtc = maxSeenUtc</code></li>
</ul>
</li>
</ol>
<p>This ensures that the first incremental run starts from a safe point in time.</p>
<p>Alternative (start “from now”, no history):</p>
<p>If you do not need historical data, you can initialize:</p>
<ul>
<li><code>watermarkUtc = nowUtc</code></li>
</ul>
<p>and start incremental pulls from <code>watermarkUtc - overlap</code>. This starts the sync from “current time”, but it does not load existing/older records.</p>
<h3 id="3-incremental-pulls-watermark--overlap">3) Incremental pulls (watermark + overlap)</h3>
<p>A robust incremental sync uses a small overlap window to avoid missing changes around the watermark boundary.</p>
<ul>
<li>Store <code>watermarkUtc</code> (the last successfully processed point in time).</li>
<li>Choose an overlap duration.</li>
<li>For the next run, request changes from <code>fromUtc = watermarkUtc - overlap</code>.</li>
</ul>
<blockquote>
<p>NOTE
Domain API incremental sync uses <code>$filter=... ge ...</code>, so using an overlap window and idempotent processing is required.
Recommended overlap:</p>
<ul>
<li>5 minutes (default)</li>
<li>30 minutes (heavy workloads / large transactions)</li>
<li>up to 1 hour (worst-case safety window)</li>
</ul>
</blockquote>
<blockquote>
<p>NOTE
For synchronization scenarios, use <code>$top=1000</code> and do not use a value greater than 1000.
If the payload per row is large (many selected fields and/or <code>$expand</code>), consider using a smaller <code>$top</code>.</p>
</blockquote>
<p>Example:</p>
<ul>
<li><code>watermarkUtc = 2023-06-09T10:00:00.000Z</code></li>
<li><code>overlap = 5 minutes</code></li>
<li><code>fromUtc = 2023-06-09T09:55:00.000Z</code></li>
</ul>
<pre><code class="lang-http">General_Products_Products?
  $top=1000&amp;
  $select=Id,AggregateLastUpdateTimeUtc,PartNumber&amp;
  $filter=AggregateLastUpdateTimeUtc ge 2023-06-09T09:55:00.000Z
</code></pre>
<p>Because the filter intentionally goes a bit back in time, the result may contain duplicates that you have already processed in previous runs (or earlier pages of the same run). Your sync logic must be idempotent (see “Handling duplicates” below).</p>
<h3 id="4-page-through-results-using-">4) Page through results using @odata.nextLink</h3>
<p>When <code>$top</code> is provided, Domain API returns <code>@odata.nextLink</code>.</p>
<p>Recommended client behavior:</p>
<ul>
<li>Treat <code>@odata.nextLink</code> as an opaque URL.</li>
<li>Keep requesting it until the server stops returning <code>@odata.nextLink</code>.</li>
</ul>
<p>This paging approach is required for large result sets.</p>
<p>For more details, see <a href="../querying-data/paging.html">Paging results ($top and @odata.nextLink)</a>.</p>
<h2 id="concepts">Concepts</h2>
<h3 id="aggregatelastupdatetimeutc">AggregateLastUpdateTimeUtc</h3>
<ul>
<li><code>AggregateLastUpdateTimeUtc</code> is available for entities that are <strong>aggregate roots</strong>.</li>
<li>The value is calculated from the Extensible Data Object (EDO) change tracking (i.e. it represents the aggregated “last update moment” for the whole aggregate).</li>
</ul>
<p>This makes it suitable for incremental pull scenarios where any change in the aggregate tree should be considered an update.</p>
<h3 id="using-overlap">Using overlap</h3>
<p>Overlap reduces the chance of missing changes around the watermark boundary (latency, clock skew, boundary equality, retries).</p>
<p>Typical approach:</p>
<ul>
<li>Query from <code>watermarkUtc - overlap</code> using <code>ge</code></li>
<li>Deduplicate and process idempotently</li>
<li>Advance watermark only after a successful full run</li>
</ul>
<h3 id="handling-duplicates-required">Handling duplicates (required)</h3>
<p>Duplicates are expected when using overlap. The sync code should be idempotent.</p>
<p>A practical approach is to store a per-entity checkpoint keyed by <code>Id</code>:</p>
<ul>
<li><code>lastAppliedUtcById[Id] = last processed AggregateLastUpdateTimeUtc for this entity</code></li>
</ul>
<p>Then, for every received item:</p>
<ul>
<li>If <code>item.AggregateLastUpdateTimeUtc &lt;= lastAppliedUtcById[item.Id]</code> → skip (duplicate/older)</li>
<li>Else → upsert + update the per-entity checkpoint</li>
</ul>
<p>Pseudocode:</p>
<pre><code class="lang-text">maxSeenUtc = watermarkUtc

for each page (following @odata.nextLink):
  for each item:
    lastApplied = lastAppliedUtcById[item.Id] (or null)

    if lastApplied != null and item.AggregateLastUpdateTimeUtc &lt;= lastApplied:
        continue

    upsert(item)
    lastAppliedUtcById[item.Id] = item.AggregateLastUpdateTimeUtc
    maxSeenUtc = max(maxSeenUtc, item.AggregateLastUpdateTimeUtc)

watermarkUtc = maxSeenUtc  // advance watermark only after successful commit of the whole run
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="i-dont-see-aggregatelastupdatetimeutc">I don’t see AggregateLastUpdateTimeUtc</h3>
<p>The attribute is available only for entities that are aggregate roots. If the entity set you are querying is not an aggregate root, the attribute will not be exposed. Also make sure that the AggregateLastUpdateTimeUtc is explicitly included in <code>$select</code> clause.</p>
<h3 id="my-incremental-sync-produces-duplicates">My incremental sync produces duplicates</h3>
<p>This is expected when using overlap (<code>fromUtc = watermarkUtc - overlap</code>). Ensure your sync logic is idempotent and deduplicates by (<code>Id</code>, <code>AggregateLastUpdateTimeUtc</code>) as described above.</p>
<h3 id="i-keep-reprocessing-the-same-rows-on-every-run">I keep reprocessing the same rows on every run</h3>
<p>Common causes:</p>
<ul>
<li>The overlap window is too large for the update rate of the dataset.</li>
<li>The sync advances the watermark incorrectly (e.g. persisting <code>watermarkUtc</code> before the whole run has completed successfully).</li>
<li>The watermark is not persisted, so every run starts from an old value.</li>
</ul>
<p>Recommended approach:</p>
<ul>
<li>Persist <code>watermarkUtc</code> only after a successful full run.</li>
<li>Consider reducing the overlap window if duplicates are too frequent.</li>
</ul>
<h3 id="i-suspect-that-some-updates-are-missing">I suspect that some updates are missing</h3>
<p>Common causes:</p>
<ul>
<li>Overlap is too small for your worst-case transaction duration / processing delays.</li>
<li>The sync persists <code>watermarkUtc</code> even when the run fails halfway.</li>
</ul>
<p>Recommended approach:</p>
<ul>
<li>Increase overlap (e.g. from 5 minutes to 30 minutes, or up to 1 hour for worst-case safety).</li>
<li>Persist the watermark only after successful commit of the whole run.</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/ErpNetDocs/dev/blob/master/domain-api/data-sync/incremental-pull.md/#L1" class="edit-link">Suggest improvement to this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
