{
  "README.html": {
    "href": "README.html",
    "title": "Welcome to the ERP.net Developer Documentation | ERP.net Developer Docs",
    "summary": "Welcome to the ERP.net Developer Documentation The documentation uses DocFX to build."
  },
  "domain-api/authentication.html": {
    "href": "domain-api/authentication.html",
    "title": "Authentication | ERP.net Developer Docs",
    "summary": "Authentication Authentication is needed when an application needs to know the identity of the current user. Typically these applications manage data on behalf of that user and need to make sure that this user can only access the data for which he is allowed. The most common example for that is (classic) web applications – but native and JS-based applications also have a need for authentication. ERP.net uses OpenID Connect authentication protocol which is an extension of OAuth2. API Access Applications have two fundamental ways with which they communicate with APIs – using the application identity, or delegating the user’s identity. Sometimes both methods need to be combined. OAuth2 is a protocol that allows applications to request access tokens from a security token service and use them to communicate with APIs. This delegation reduces complexity in both the client applications as well as the APIs since authentication and authorization can be centralized. Identity Server Each ERP.net instance has it's own authentication provider site which is usually located on https://{ERP-INSTANCE-ROOT-URL}/id. For example the identity server for demodb ERP instance is located at https://demodb.my.erp.net/id. ERP.net Identity Server is build ot top of IdentityServer4 which documentation can be used to understand better the authentication process. Terminology IdentityServer - IdentityServer is an OpenID Connect provider - it implements the OpenID Connect and OAuth 2.0 protocols. User - A user is a human that is using a registered client to access resources. Client - A client is a piece of software that requests tokens from IdentityServer - either for authenticating a user (requesting an identity token) or for accessing a resource (requesting an access token). A client must be first registered with IdentityServer before it can request tokens. In ERP.net registered clients are addressed as trusted applications. Resources - Resources are something you want to protect with IdentityServer - either identity data of your users, or APIs. In our case this is the Domain API. Identity Token - An identity token represents the outcome of an authentication process. It contains at a bare minimum an identifier for the user (called the sub aka subject claim) and information about how and when the user authenticated. It can contain additional identity data. Access Token - An access token allows access to an API resource. Clients request access tokens and forward them to the API. Access tokens contain information about the client and the user (if present). APIs use that information to authorize access to their data. Refresh Token - Since access tokens have finite lifetimes, refresh tokens allow requesting new access tokens without user interaction. In ERP.net Refresh tokens are supported only for interactive confidential applications that use the authorization code flow. Source: https://docs.identityserver.io/en/latest/intro/terminology.html Application Types ERP.net supports two client application types Interactive applications This type of applications are used by end users to access the ERP.net resources and database. This applications must use a web browser to show the ERP.net login screen to the end user. After successfull login the application can request identity_token or/and access_token. These applications must use the Authorization Code Flow Service applications These are machine to machine applications that do not require user login. They use the Client Credentials Flow Trusted Applications The registered clients in one ERP.net instance are called trusted applications. They are stored in the database and have all required properties that Identity Server needs in order to manage the client application authorization. For more information of trusted applications visit the Trusted Applications Topic For detailed instructions how to register trusted application visit this topic Internal and External Users Client Applications can use the Identity Server to authenticate two type of users: Internal Users These are the users that have access to the ERP.net instance database. Only internal users can obtain a valid access_token. External Users These are users that can be authenticated by Identity Server but can not obtain a valid access_token for Domain API or Table API. They are usually customers of the company-owner of the ERP.net instance. When an external user logs in, using the Identity Server login page, only an id_token is issued by the identity server. This id_token prooves that the user is properly authenticated. For example the users of a web store are external users. Endpoints ERP.net Discovery Endpoint The address of Identity Server as all ERP.net sites can be configured. To find out where any ERP.net site is located we must call the /sys/auto-discovery endpoint. For example https://demodb.my.erp.net/sys/auto-discovery The result of this request will be: { \"WebSites\": [ { \"Type\": \"ID\", \"Status\": \"Working\", \"Url\": \"https://demodb.my.erp.net/id\", \"AdditionalProperties\": null }, { \"Type\": \"DomainAPI\", \"Status\": \"Working\", \"Url\": \"https://demodb.my.erp.net/api\", \"AdditionalProperties\": { \"ODataServiceRoot\": \"https://demodb.my.erp.net/api/domain/odata/\" } } ] } The result contains all configured web sites for this ERP.net instance. By the result of this request you can understand where the Identity Server is located as well where the ODATA service root of the Domain API is located. The site types at the moment are: ID - Identity Server Site - the authorization provider for the ERP.net instance. DomainAPI - Domain API Site TableAPI - Table API Site Other site types that provide different functionalities. Identity Server Discovery Endpoint The discovery endpoint can be used to retrieve metadata about your IdentityServer - it returns information like the issuer name, key material, supported scopes etc. See the spec for more details. The discovery endpoint is available via /.well-known/openid-configuration relative to the base address, e.g.: https://demodb.my.erp.net/id/.well-known/openid-configuration Authorize Endpoint The authorize endpoint can be used to request tokens or authorization codes via the browser. This process typically involves authentication of the end-user and optionally consent. For full list of available parameters visit this link. For Authorization Code Flow the application first need to call the authorize endpoint. Exapmle GET https://demodb.my.erp.net/id/connect/authorize? client_id={my_client_id}& redirect_uri={https://myapp/callback}& response_type=code%20id_token& scope=openid%20profile%20offline_access& nonce=abc& state=xyz& After successfull login the browser will be redirected to the provided redirect_uri (https://myapp/callback in the example above) with the authorization code as url parameter. This autnorization code then must be used to request an access_token from the token endpoint. Token Endpoint The token endpoint can be used to programmatically request tokens. Full list of available parameters The most used scenarios are: Request access_token with authorization code POST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1& client_secret=secret& grant_type=authorization_code& code=hdh922& redirect_uri=https://myapp.com/callback The result of this request is a JSON containing access_token, id_token and refresh_token. The refresh_token can be used to obtain a new access_token (along with new refresh_token). Request access_token with client credentials. This is the case when a service application can use the Domain API without an interactive user. The trusted application must be configured with system/service user that will be used to create the ERP session. POST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1& client_secret=secret& grant_type=client_credentials Note It is possible a client application to act as interactive application and service application at the same time. That means the application can use two different access tokens to communicate with Domain API or only use the client_credentials token. In order to achieve this the application must append the -service suffix to the client_id parameter of the Identity Server token endpoint when the application uses the client_credentials grant_type to obtain an access_token. For example a web store site can use a system user to load the products and to relate the logged in external user to a customer entry in the database. For example if the client application is registered as trusted application with ApplicationUri='ClientApp' and SystemUserAllowed=true and ImpersonateLoginUrl,ImpersonateLogoutUrl not empty, access_token can be requested with athorization_code grant_type and client_credentials grant_type, but when the client_credentials grant_type is used the provided client_id must be 'ClientApp-service': POST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=ClientApp-service&client_secret=secret&grant_type=client_credentials Request access_token with refresh_token POST /connect/token CONTENT-TYPE application/x-www-form-urlencoded client_id=client1& client_secret=secret& grant_type=refresh_token& refresh_token=xxxxxxxxxxxxxxxxxxxxxxxx The result contains new access_token and new refresh_token. End Session Endpoint The end session endpoint can be used to trigger single sign-out (see spec). To use the end session endpoint a client application will redirect the user’s browser to the end session URL. All applications that the user has logged into via the browser during the user’s session can participate in the sign-out. Full list of available parameters Example GET /connect/endsession?id_token_hint=eyJhbGciOiJSUzI1NiIsImtpZCI6IjdlOGFkZmMzMjU1OTEyNzI0ZDY4NWZmYmIwOThjNDEyIiwidHlwIjoiSldUIn0.eyJuYmYiOjE0OTE3NjUzMjEsImV4cCI6MTQ5MTc2NTYyMSwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwIiwiYXVkIjoianNfb2lkYyIsIm5vbmNlIjoiYTQwNGFjN2NjYWEwNGFmNzkzNmJjYTkyNTJkYTRhODUiLCJpYXQiOjE0OTE3NjUzMjEsInNpZCI6IjI2YTYzNWVmOTQ2ZjRiZGU3ZWUzMzQ2ZjFmMWY1NTZjIiwic3ViIjoiODg0MjExMTMiLCJhdXRoX3RpbWUiOjE0OTE3NjUzMTksImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.STzOWoeVYMtZdRAeRT95cMYEmClixWkmGwVH2Yyiks9BETotbSZiSfgE5kRh72kghN78N3-RgCTUmM2edB3bZx4H5ut3wWsBnZtQ2JLfhTwJAjaLE9Ykt68ovNJySbm8hjZhHzPWKh55jzshivQvTX0GdtlbcDoEA1oNONxHkpDIcr3pRoGi6YveEAFsGOeSQwzT76aId-rAALhFPkyKnVc-uB8IHtGNSyRWLFhwVqAdS3fRNO7iIs5hYRxeFSU7a5ZuUqZ6RRi-bcDhI-djKO5uAwiyhfpbpYcaY_TxXWoCmq8N8uAw9zqFsQUwcXymfOAi2UF3eFZt02hBu-shKA&post_logout_redirect_uri=http%3A%2F%2Flocalhost%3A7017%2Findex.html"
  },
  "domain-api/common-tasks/change-language.html": {
    "href": "domain-api/common-tasks/change-language.html",
    "title": "Change the response language | ERP.net Developer Docs",
    "summary": "Change the response language Overview Thanks to the built-in multilanguage support you can save data in multiple languages. Then, when you retrieve them back via the Domain API, you get the data all at once as a complex type of multilanguage string- i.e. all translations you have defined. { \"en\": \"Apple\", \"de\": \"Apfel\" } Document printout However, sometimes there are cases where the data must be returned, visualized for a particular language. I.e. it's not appropriate to return all defined translations at once. An example of this is when you acquire a document printout. The result of this feature is a document, a file, rendered in a specific language. What if you want the printout to be displayed in a language other than the default? Note The default language in Domain API is English (en). If you want it to be generated in German, you must specify it explicitly. Supported ways to specify the response language Url parameter: culture=de Cookie, containing a key=value: .AspNetCore.Culture=de Accept-Language HTTP header: Accept-Language: de All you have to do is to specify the language in one of the ways listed above. Caution The methods mentioned above are applicable only when using OAuth for authorization. You can find additional information here. Warning If there's more than one way to change the language at the same time, prioritization takes place. The priority is the same as listed above: (1) url parameter, (2) cookie, (3) accept-language header. I.e. if you send a request, containing a url parameter culture=de and also specify an HTTP header Accept-Language: en, the chosen language will be German. Going back to the example of generating a document printout mentioned above, here's what a typical request looks like, POST /api/domain/odata/Crm_Invoicing_Invoices(51a63a99-c96d-4876-b205-fced610143ae)/GetPrintout HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json { \"fileFormat\": \"pdf\", \"printout\": { \"@odata.id\": \"General_Printouts(f5229037-b420-46a4-81a0-f11f7d112879)\" } } The result of the request will be the printout as base64 encoded pdf file in the default Domain API language. If you want to change the language, it's enough to simply specify it in one of the three ways above, POST /api/domain/odata/Crm_Invoicing_Invoices(51a63a99-c96d-4876-b205-fced610143ae)/GetPrintout HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json Accept-Language: de { \"fileFormat\": \"pdf\", \"printout\": { \"@odata.id\": \"General_Printouts(f5229037-b420-46a4-81a0-f11f7d112879)\" } } The only change is the additional request HTTP header Accept-Language: de. The result will be the same printout, but in German. Note Changing the language simply instructs ERP.net to \"choose\" it from what is saved in the multilanguage string attributes. If the \"chosen\" language isn't present in a multulanguage string attribute, it will be returned transliterated. All non-multilanguage strings will be returned as they are. Specify response language when using Basic Auth Unlike the recommended OAuth authorization method, changing the response language while using Basic Auth can only be accomplished by specifying the lang parameter in the request URL. E.g., POST /api/domain/odata/Crm_Invoicing_Invoices(51a63a99-c96d-4876-b205-fced610143ae)/GetPrintout?lang=bg HTTP/1.1 Host: demodb.my.erp.net Authorization: Basic xxxxx lang=bg - that's the addition, and as a result, the prinout will be returned, but in Bulgarian. Anyway, the use of Basic Auth is strongly discouraged and should be approached with special caution, only as a last resort. Here, you can find information on how to migrate your Basic Auth workflow to OAuth: Authentication in ERP.net Register trusted app Step-by-step / acquire an access token Other cases, where language change has an effect Error responses / messages For example, we'll update a customer, but in such a way that we get an error back. We'll trigger the R27159 validation business rule. PATCH /api/domain/odata/Crm_Customers(e99186bc-d3bc-4a93-b169-5baec1d45540) HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json { \"FromDate\": \"2022-01-01\", \"ThruDate\": \"2021-01-01\" } Accordingly, the result will be the following error: { \"error\": { \"message\": \"An error occurred while saving data to the database\\r\\n The validation R27159: FromDateLessThanThruDate failed for event Commit: \\r\\n\\r\\nCustomer's From Date 1/1/2022 12:00:00 AM should not be greater than customer's Thru Date 1/1/2021 12:00:00 AM. (Constraint R27159)\" } } If we change the language (this time as a url parameter), the request will look like this, PATCH /api/domain/odata/Crm_Customers(e99186bc-d3bc-4a93-b169-5baec1d45540)?culture=bg HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json { \"FromDate\": \"2022-01-01\", \"ThruDate\": \"2021-01-01\" } The difference is adding the culture=bg parameter to the url. We'll receive the same message, but translated into Bulgarian: { \"error\": { \"message\": \"Грешка при записване.\\r\\n Валидацията R27159: FromDateLessThanThruDate не е била успешна при събитие Commit: \\r\\n\\r\\nСтойността на полето 'От дата' 1.01.2022 г. 0:00:00 ч. не трябва да надвишава стойността на полето 'До дата' 1.01.2021 г. 0:00:00 ч. (Constraint R27159)\" } }"
  },
  "domain-api/common-tasks/context-parameters.html": {
    "href": "domain-api/common-tasks/context-parameters.html",
    "title": "Context parameters | ERP.net Developer Docs",
    "summary": "Context parameters In some cases the behaviour of the domain model depends on the provided context parameters. Such parameters are the current user, current language, current enterprise company, current enterprise company location and current role. For example some business rules require current enterprise company to determine the costing and pricing currency of a product. The current user is implicitly determined by the session - this is the logged in internal user. The language may be provided by one of the standard ways defined by ASP.NET Core - culture URL parameter, .AspNetCore.Culture cookie or Accept-Language HTTP header. Providing current enterprise company, enterprise company location and role for the API request. 1. URL Parameters CurrentEnterpriseCompanyId=GUID1&CurrentEnterpriseCompanyLocationId=GUID2&CurrentRoleId=GUID3 OR ErpContextParameters=GUID1,GUID2,GUID3 The ErpContextParameters URL parameter requires three guids - the first one is enterprise company Id, the second one is enterprise company location Id and the third one is the role Id. 2. HTTP header Prefer The Prefer HTTP Header can be used by a client to request particular server behaviors. In this case we can append multiple Prefer headers: Prefer: CurrentEnterpriseCompanyId=GUID1 Prefer: CurrentEnterpriseCompanyLocationId=GUID2 Prefer: CurrentRoleId=GUID3 OR Prefer: ErpContextParameters=GUID1,GUID2,GUID3 3. Cookie We can provide cookie with name ErpContextParameters and value 'GUID1,GUID2,GUID3' Validation If the provided value can't be parsed to a valid guid it is ignored. If the current user has no acces to the provided enterprise company by security reasons, the provided CurrentEnterpriseCompanyId is ignored. If the provided company location Id is not amongs the company locations of the current enterprise company the value is ignored. If the provided role Id is not accessible by the current user the value is ignored."
  },
  "domain-api/common-tasks/create-notification.html": {
    "href": "domain-api/common-tasks/create-notification.html",
    "title": "Create notification | ERP.net Developer Docs",
    "summary": "Create notification Overview As already known, notifications in ERP.net are an entity, part of the domain model. Communities.Notifications Entity. Roughly, each notification is a message intended for a specific user. Additionally, the notification MAY reference a data object- e.g. the notification subject. This is expressed through the following entity attributes: User DataObject ERP.net creates and manages various notifications according to certain business rules, triggered by specific events. E.g. when someone replies to your comment- you'll get a notification. This flow is managed by a specific business rule (R33428 SocialComment - Notify User Comment Replied) More information about all notification types (i.e. notification classes) and when they're created can be found in the separate topic Notifications. Create a notification programmatically It's possible to create a notification yourself via the Domain API. You simple need to: Specify the entity that will be the subject of the notification. Invoke its method CreateNotificaiton. Populate the required notification's attributes such as the target user, the notification class, the notification subject. POST /api/domain/odata/Crm_Customers(79f3f74e-098a-4d91-9714-c4f845c2dc62)/CreateNotification HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json { \"user\": { \"@odata.id\": \"Systems_Security_Users(9da64839-a8d0-491d-aebb-4d18fa42b014)\" }, \"notificationClass\": \"NT_SOC_NEW_POST\", \"subject\": \"Hello from Domain API!\" } That's it. A notification will be created. Addressed to the specified user; originating from the specified customer. CreateNotification() in detail CreateNotification is an API method, defined in the EntityObject type. This means that it can be invoked from any entity. It's available for every entity in our Domain Model documententation. Here's a link to the method, used in the example from above, https://docs.erp.net/model/entities/Crm.Customers.html#createnotification Additionally, once the notification is created (as persistent data, in the database), it will be wrapped in a real-time event, which will be sent to the target user (as a real-time event). In this way, you can not only create notifications programmatically, but also notify users in real time. More information about real-time events can be found in the separate topic in the documentation. Real-time events"
  },
  "domain-api/common-tasks/handling-renames.html": {
    "href": "domain-api/common-tasks/handling-renames.html",
    "title": "Handling entity type renames | ERP.net Developer Docs",
    "summary": "Handling entity type renames Sometimes, entity types in ERP.net are renamed. In one version, they are called X, and in the next version, they are called Y. Of course, we avoid doing this as much as we can. But sometimes it is unavoidable and has to be done. For example, we have renamed \"General.DocumentPrintImages\" (\"General_DocumentPrintImages\" in the API) to \"Systems.Internal.DocumentPrintImages\". This, naturally, is a problem for applications, which access these entities through the API. To alleviate the problem, we have taken numerous measures: 1. Error message containing the new name When you access an entity, which has been renamed, ERP.net Domain API returns an informative error message, which contains the new name of the entity type For example: The provided entity set name 'General_DocumentPrintImages' is no more supported. The new name of this entity is 'Systems_Internal_DocumentPrintImages'. List of all entity renames can be found at https://testdb.my.erp.net/api/domain/odata/GetRenamedEntityTypes. You have to change your application to use the new name. 2. Support both old and new versions If you want your app to support both the old and the new version of ERP.net Domain API, you can check the version with the following function: /GetVersion The function returns a JSON object with \"version\" property. Example: https://testdb.my.erp.net/api/domain/odata/GetVersion Example response: { \"@odata.context\": \"https://testdb.my.erp.net/api/domain/odata/$metadata#Erp.OpenObject\", \"version\": \"24.1.5.41\" } 3. Automate entity type renames If you want to implement some form of automation for these pesky renames, we support end-point, which returns all renames, along with some related data: /GetRenamedEntityTypes The function returns a JSON array with entity type rename containig OldName, NewName and Version (the version when the new name replaces the old name). Example: https://testdb.my.erp.net/api/domain/odata/GetRenamedEntityTypes Example response: \"@odata.context\": \"https://testdb.my.erp.net/api/domain/odata/$metadata#Collection(Erp.OpenObject)\", \"value\": [ { \"OldName\": \"Systems_Core_DataEntryDefaultValues\", \"NewName\": \"Systems_Internal_DataEntryDefaultValues\", \"Version\": \"24.1.5.35\" }, { \"OldName\": \"Systems_Core_ExtensibleDataObjects\", \"NewName\": \"Systems_Internal_ExtensibleDataObjects\", \"Version\": \"24.1.5.35\" }, ... Finding the Actual Entity Type Name You can use the result of this function to determine the actual entity type name. Here is an example of how this can be achieved: // The variable $renames contains the array of all entity type renames returned by the ~/GetRenamedEntityTypes function. // The variable $entitySet is the provided entity set name, which may have been renamed. // The $renames collection may contain entries where an entity type name has been renamed multiple times. // To find the valid name, we need to iterate through all renames and update the $entitySet accordingly. foreach (var rename in $renames) { if (rename.OldName == $entitySet) { $entitySet = rename.NewName; } } // After the loop, $entitySet will contain the actual entity type name. 4. List of renames To view the list of renamed entity types, go to the following address: Renamed entity types"
  },
  "domain-api/common-tasks/index.html": {
    "href": "domain-api/common-tasks/index.html",
    "title": "Common tasks | ERP.net Developer Docs",
    "summary": "Common tasks This section includes examples of common tasks performed with the Domain API. Change the response language Context parameters Create notification Handling entity type renames Master/Detail Attributes Register Trusted Application Retrieve Products Working with documents CONTAINS Using contains filter function for string attribute: General_Contacts_Parties?$top=5&$filter=contains(PartyCode,'30') Try it Yourself Using contains filter function for multi-language attribute: General_Contacts_Parties?$top=5&$filter=contains(PartyName,'Ivan') Try it Yourself IN OPERATOR Not every attribute in ERP.net supports in filter operator. Generally all navigation properties support in, some enum attributes and occasionaly some other attributes. This information you can find in the Domain Model Reference. Using in for Id attribute: General_Products_Products?$top=10&$filter=Id in (edf2bd2a-7e4d-e111-a06c-00155d00050a, cf728601-1fd5-4853-ab23-01deeee7d038) Try it Yourself Using in for Document State attribute: Crm_Sales_SalesOrders?$top=10&$filter=State in ('FirmPlanned', 'Released')&$select=State Try it Yourself Using in for DocumentType navigation property: Crm_Sales_SalesOrders?$top=10&$select=DocumentType&$filter=DocumentType in ('General_DocumentTypes(de4913f3-962a-4289-a0f3-01bc2c1da21d)', 'General_DocumentTypes(a8b99412-3348-4c12-abdf-1a6a15ab5449)') Try it Yourself Passing inherited entity uri-s (Document.ToParty is of type General_Contacts_Party. The types General_Contacts_Company and General_Contacts_Person are inherited by General_Contacts_Party): Crm_Sales_SalesOrders?$top=10&$filter=ToParty in ('General_Contacts_Persons(2e97f255-f410-4925-8c51-211c8eaa18b8)', 'General_Contacts_Companies(bc60d0bc-2804-4e3c-b355-04184aef5505)') Note: if you pass uri-s to General_Contacts_Party entity the query can be optimized and will be faster than specifying inherited entity uri-s. Try it Yourself CAST The following uri returns the parent document of a specified sales order cast as Crm_Presales_Offer. Note: The type must be specified with the namespace which for all entities is Erp. Crm_Sales_SalesOrders(11217345-3659-43be-a85d-005eaaa3aaac)/Parent/Erp.Crm_Presales_Offer SELECT DEFAULT By default only system attributes are present in the JSON result. The Id attribute, custom properties and calculated attributes are not present. Use the keyword default in $select clause to include all default attributes. To include custom properties and calculated attributes they must be specified explicitly in $select clause. General_Products_Products?$top=1&$select=default,CalculatedAttribute_name NESTED EXPAND Crm_Sales_SalesOrders(59098bcf-f331-478f-91c2-f5520590f534)?$expand=Lines($expand=Product($select=Codes,Name,PartNumber;$expand=Codes($select=Code))) EXPAND $ref - returns the items as links Crm_Sales_SalesOrders(59098bcf-f331-478f-91c2-f5520590f534)?&$expand=Lines/$ref FILTER BY DATE Crm_Sales_SalesOrders?$top=2&$filter=DocumentDate eq 2012-01-01T00:00:00Z FILTER BY Custom Property General_Products_Products?$top=10&$select=CustomProperty_color&$filter=CustomProperty_color eq 'blue' FILTER BY Quantity and Amount Crm_Sales_SalesOrderLines?$top=10&$filter=QuantityValue ge 3 and QuantityValue le 5 and LineAmountValue ge 15.45&$select=Quantity Request COUNT applying filter Crm_Invoicing_Invoices/$count?$filter=DocumentDate eq 2020-03-23T00:00:00Z This request returns the number of invoices for the specified date. See http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361043 Crm_Sales_SalesOrderLines/$count?$filter=SalesOrder/Void eq false and SalesOrder/State ge 'Released' and Product eq 'General_Products_Products(35d5bcb9-0881-4bc8-bfe4-84fb874d4626)' This request returns the number of released sales order lines for a given product. Using $top, $skip and $count Crm_Sales_SalesOrderLines?$filter=SalesOrder/Void eq false and SalesOrder/State ge 'Released'&$top=10&$skip=120&$count=true The $count=true query option specifies that the total number of rows for the specified filter will be included in the result along with the data. UPDATE PRODUCT PATCH ~/General_Products_Products(59098bcf-f331-478f-91c2-f5520590f534) { \"@odata.type\": \"#Erp.General_Products_Product\", \"ABCClass\": \"A\", \"StandardLotSizeBase\": { \"Value\": 3.45, \"Unit\": \"бр\" }, \"MeasurementUnit@odata.bind\": \"https://mycompany.com/api/domain/odata/General_MeasurementUnits(5c5e77ce-60bb-4338-abd0-3a2acb27ff93)\" } FILTER BY DOCUMENT STATE Crm_Sales_SalesOrders?$top=1&$filter=State ge Erp.General_DocumentState'Released' FILTER BY MULTIPLE DOCUMENT TYPES Crm_Sales_SalesOrders?$top=2&$filter=DocumentType eq 'General_DocumentTypes(f8a93d3a-8cf3-4a09-9d45-667d664cb98d)' and DocumentType eq 'General_DocumentTypes(f8a93d3a-8cf3-4a09-9d45-667d664cb98e)' and DocumentType eq 'General_DocumentTypes(f8a93d3a-8cf3-4a09-9d45-667d664cb98f)' FILTER BY MasterDocument with Sales Order URI Crm_Sales_SalesOrders?$top=2&$filter=MasterDocument eq 'Crm_Sales_SalesOrders(70ef9b04-d843-df11-a1e1-0018f3790817)' CHANGE DOCUMENT STATE POST ~/Crm_Sales_SalesOrders(59098bcf-f331-478f-91c2-f5520590f534)/ChangeState { \"newState\" : \"FirmPlanned\", \"userStatus\": {\"@odata.id\": \"General_DocumentTypeUserStatuses(1ee1249e-4ef5-46b4-8409-26b2130d09c7)\"} } MAKE DOCUMENT VOID POST ~/Crm_Sales_SalesOrders(11217345-3659-43be-a85d-005eaaa3aaac)/MakeVoid { \"reason\" : \"test api method\", \"voidType\": \"VoidDocument\" }"
  },
  "domain-api/common-tasks/master-detail-attributes.html": {
    "href": "domain-api/common-tasks/master-detail-attributes.html",
    "title": "Master/Detail Attributes | ERP.net Developer Docs",
    "summary": "Master/Detail Attributes Description There are many entity types in ERP.net which are in master/detail relationship. For example, the Sales Orders entity type is master to the Sales Order Lines entity type. Following the relationship between their respective entity types, some attributes (or references) might be in master/detail relationship. For example, the SalesOrder.Store and SalesOrderLine.LineStore are in master/detail relationship. For in-depth information about master/detail attribute relationship, refer to the technical documentation. Very simplified version of the story from dev perspective: The detail attribute is the important one. It is considered by the business logic. The master attribute is used mainly for at-a-glance user information. The master attribute contains value only when the value (of the detail attribute) for all lines is the same. Otherwise, it is NULL. The detail attribute generally should be a required (not-NULL) attribute. However, there are exceptions, so check the model docs to be sure. Best practices When creating data Set the value of the detail attribute for each line, according to your business requirements. For the master attribute: If ALL detail lines have the same value for the detail attribute, set that value. Otherwise (if there are different values) - set NULL. When consuming data Use the detail attribute value to properly implement your business logic. If you are referring to the value of the master attribute, be sure to properly handle the possible NULL values. Examples All lines have the same value In this example, the master attribute has a value, because it is the same for all lines. Entity Attribute Value Sales Order 00596 Store Main Sales Order 00596 - Line 01 Line Store Main Sales Order 00596 - Line 02 Line Store Main Sales Order 00596 - Line 03 Line Store Main Different values on the lines In this example, the master attribute is NULL, because there are lines with different values. Entity Attribute Value Sales Order 00597 Store NULL Sales Order 00597 - Line 01 Line Store Main Sales Order 00597 - Line 02 Line Store Remote 01 Sales Order 00597 - Line 03 Line Store Main"
  },
  "domain-api/common-tasks/register-trusted-app.html": {
    "href": "domain-api/common-tasks/register-trusted-app.html",
    "title": "Register Trusted Application | ERP.net Developer Docs",
    "summary": "Register Trusted Application In this topic, you register an app in an ERP instance so the ERP.net identity server can provide authentication and authorization services for your application and its users. Each application that uses ERP.net APIs needs to be registered. Whether it's a client application like a web or mobile app, or it's a web API that backs a client app, registering it establishes a trust relationship between your application and the ERP instance. Note In future versions of ERP.net platform this way to register a trusted application will no longer be available, because of the sec scope (Only identity server itself will be granted with the sec scope) The ERP.net instance will provide a browser accessible endpoint where the application will provide its client_id, client_secret_hash, scopes and other required parameters to register the application. This endpoint will redirect the user to the login screen and if the user is a database administrator he or she will be able to approve the application registration. Register an application Registering your application establishes a trust relationship between your app and the ERP.net database instance. That means that your database trusts the application. We'll show how to register an application manually, using the Domain API Query Tool. Follow these steps to create the app registration: Sign in to your ERP instance and open the Domain API Query Tool. Every ERP.net database has it's own query tool on the Domain API site. The Domain Api site is usually hosted on address https://{COMPANY}.my.erp.net/api and the query tool is on https://{COMPANY}.my.erp.net/api/domain/query In this example we'll use the DEMODB ERP.net instance query tool: https://demodb.my.erp.net/api/domain/query ⚠️ You need to be a database administrator in order to be able to register a new trusted application. If the application is confidential, we need to prepare an application secret. Use this endpoint to get the application secret hash (Replace mysecret with your secret): https://demodb.my.erp.net/sys/tools/sha256?secret=mysecret In the query tool we'll create a new record for System.Security.TrustedApplications entity. Register interactive confidential application Query: Systems_Security_TrustedApplications Type: POST Body: { \"ApplicationUri\": \"MYDEMOCLIENT\", \"Name\": \"MY DEMO CLIENT\", \"ClientType\": \"Confidential\", \"ApplicationSecretHash\": \"T/AGymuI51LwjLeIFxRQXOs9IHnupDKs/ajhWODR2C4=\", \"ImpersonateAsCommunityUserAllowed\": true, \"ImpersonateAsInternalUserAllowed\": true, \"ImpersonateLoginUrl\": \"http://localhost:5080/myapp/signin-oidc\", \"ImpersonateLogoutUrl\": \"http://localhost:5080/myapp/\", \"SystemUserAllowed\": false } ApplicationUri is the unique name that identifies the application. This is the client_id in the OAuth terminology. Name is the display name of the application. ClientType - Confidential or Public. ApplicationSecretHash a hash of the application secret - previously created using https://demodb.my.erp.net/sys/tools/sha256?secret=mysecret tool. ImpersonateAsCommunityUserAllowed must be true if your application will work with community users. Community users are users that do not have access to system resources. They are usually customers of the company that owns the ERP.net database instance. ImpersonateAsInternalUserAllowed must be true if internal users will use the application. ImpersonateLoginUrl is a comma separated list of allowed URLs that are used from the application to receive the authorization code. When the user loads the application in the browser, if sign in is required, the browser is redirected to ERP.net Identity Server login page. After successful login the browser is redirected to the provided return_url that must be one of the URLs specified in ImpersonateLoginUrl providing the authorization_code through code url parameter. This code is used by the application to request an access_code that is used to gain access to ERP.net server resources. ImpersonateLogoutUrl is a comma separated list of allowed URLs that are used after the user is logged out from the identity server and \"Return to app\" button is clicked. SystemUserAllowed specifies if the application can act as a service application that is impersonated as specific user. Register interactive public application Query: Systems_Security_TrustedApplications Type: POST Body: { \"ApplicationUri\": \"MYDEMOCLIENT\", \"Name\": \"MY DEMO CLIENT\", \"ClientType\": \"Public\", \"ImpersonateAsCommunityUserAllowed\": true, \"ImpersonateAsInternalUserAllowed\": true, \"ImpersonateLoginUrl\": \"http://localhost:5080/myapp/signin-oidc\", \"ImpersonateLogoutUrl\": \"http://localhost:5080/myapp/\", \"SystemUserAllowed\": false } Register service application Query: Systems_Security_TrustedApplications Type: POST Body: { \"ApplicationUri\": \"MYSERVICEDEMOCLIENT\", \"Name\": \"Service Demo Client\", \"ApplicationSecretHash\": \"T/AGymuI51LwjLeIFxRQXOs9IHnupDKs/ajhWODR2C4=\", \"ClientType\": \"Confidential\", \"SystemUserAllowed\": true, \"SystemUser\": { \"@odata.id\": \"Systems_Security_Users(cc314327-3d04-477f-ac53-cde19d8350e9)\" } } SystemUser is the user for the service application."
  },
  "domain-api/common-tasks/retrieve-products.html": {
    "href": "domain-api/common-tasks/retrieve-products.html",
    "title": "Retrieve Products | ERP.net Developer Docs",
    "summary": "Retrieve Products The following query: Retrieves 10 products, without any order Filters by: Active = true Selects the following attributes: Id - the unique Id of the product. Part Number - the product code. Name - the multi-language product name. ProductGroup - reference to the Product Group containing the product. StandardPricePerLot - Amount object, containing the standard price. Description - textual description of the product. This description is clear text and does not support any formatting. There is also Description_Html attribute, which can be used to contain description with HTML formatting. MeasurementUnit - reference to measurement units. This is the default sales measurement unit of the product. https://demodb.my.erp.net/api/domain/odata/General_Products_Products?$top=10&$filter=Active%20eq%20true&$select=CatalogDescriptionHtml,Description,Id,MeasurementUnit,Name,PartNumber,ProductGroup,StandardPricePerLot You can edit the query in the Query Builder: https://demodb.my.erp.net/api/domain/querybuilder#General_Products_Products?$top=10&$filter=Active%20eq%20true&$select=CatalogDescriptionHtml,Description,Id,MeasurementUnit,Name,PartNumber,ProductGroup,StandardPricePerLot"
  },
  "domain-api/common-tasks/working-with-documents.html": {
    "href": "domain-api/common-tasks/working-with-documents.html",
    "title": "Working with documents | ERP.net Developer Docs",
    "summary": "Working with documents See Documents on technical documentation. Retrieving and updating documents is the same as any other entity in the domain. However there are some specific rules that apply only to documents. For example documents on state Released or above can not be modified directly. They must be modified with adjustment documents. Another important attribute of the documents that can not be modified with simple PATCH request is State. The examples below show some tasks related to documents. Create document Document can be created only by specifying the required properties. Other properties will be filled by it's constant default value or it's LateDefault expression. If Front-End model is used in API Transaction dependent property values are recalculated upon property change. For example in SalesOrderLine line.ProductDescription is set to line.Product.Name when line.Product changes. In the example bellow a new SalesOrder is created with one SalesOrderLine. Note that measurement units and currencies are specified before passing Quantity or Amount values. This is required because the quantity or amount contains the code of the measurement unit or currency. POST ~/Crm_Sales_SalesOrders { \"DocumentType\": { \"@odata.id\": \"General_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)\" }, \"EnterpriseCompany\": { \"@odata.id\": \"General_EnterpriseCompanies(b0e80577-fbbe-4c9b-811e-20b6c6dd465f)\" }, \"Customer\": { \"@odata.id\": \"Crm_Customers(15f2640f-f374-4017-ae2d-d2a41535f054)\" }, \"DocumentCurrency\": { \"@odata.id\": \"General_Currencies(3187833a-d3c1-4804-bfc0-e17e6aee3069)\" }, \"Lines\": [ { \"Product\": { \"@odata.id\": \"General_Products_Products(81d38b50-fd06-e611-8292-b31071e2ee7f)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 1, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 20, \"Currency\": \"BGN\" } } ] } Change document state HTTP C# POST ~/Crm_Sales_SalesOrders(59098bcf-f331-478f-91c2-f5520590f534)/ChangeState { \"newState\" : \"FirmPlanned\", \"userStatus\": {\"@odata.id\": \"General_DocumentTypeUserStatuses(1ee1249e-4ef5-46b4-8409-26b2130d09c7)\"} } Make document void HTTP C# POST ~/Crm_Sales_SalesOrders(11217345-3659-43be-a85d-005eaaa3aaac)/MakeVoid { \"reason\" : \"test api method\", \"voidType\": \"VoidDocument\" } Recalculate document This method is used to recalculate some document details such as Document Amounts (like VAT), Bonus Programs etc. It make sense only in the context of Front-End transaction because the recalculated changes remain only in memory. They must be commited to the database with a separate call to EndTransaction{commit=true}. HTTP C# POST ~/Crm_Sales_SalesOrders(11217345-3659-43be-a85d-005eaaa3aaac)/Recalculate Create adjustment documents Released documents can be modified only with adjustment documents. The API provides a convenient method to create adjustment documents: CreateAdjustmentDocuments. The method requires TransactionId in the request header. The method creates adjustment documents for modified released documents. The adjustment documents are created in separate transaction and their state is changed to 'Adjustment'. The method does not commit or rollback the current front-end transaction. HTTP C# // Begin a front-end transaction POST ~/BeginTransaction { \"model\": \"frontend\" } // The returned transaction id must be set in the request header for each subsequent query. The header name is TransactionId. // Update some sales order lines. PATCH ~/Crm_Sales_SalesOrderLines(34217345-3659-43be-a85d-005eaaa3aaac) TransactionId: xxxx { \"Quantity\": {\"Value\": 5.0, \"Unit\": \"PCE\"} } // Update another line. PATCH ~/Crm_Sales_SalesOrderLines(65217345-3659-43be-a85d-005eaaa3aaac) TransactionId: xxxx { \"Quantity\": {\"Value\": 15.0, \"Unit\": \"PCE\"} } // Call CreateAdjustmentDocuments to create the adjustment documents and apply the changes to the original document. // Adjustment documents will be created for all modified released documents in the current transaction. POST ~/CreateAdjustmentDocuments TransactionId: xxxx // End the transaction without committing because updating released document directly is not allowed. POST ~/EndTransaction TransactionId: xxxx { \"commit\": false } Create multiple lines to an existing document A possible scenario is when you have a document created, but later you want to add its lines. PATCH ~/Crm_Sales_SalesOrders(283e4c71-2d77-4083-81b6-4c7f17668d7e) { \"Lines\": [ { \"LineNo\": 10, \"Product\": { \"@odata.id\": \"General_Products_Products(81d38b50-fd06-e611-8292-b31071e2ee7f)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 1, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 20, \"Currency\": \"BGN\" } }, { \"LineNo\": 20, \"Product\": { \"@odata.id\": \"General_Products_Products(08fc0b95-01d8-4876-9074-67898c0bd98b)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 5, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 10, \"Currency\": \"BGN\" } }, { \"LineNo\": 30, \"Product\": { \"@odata.id\": \"General_Products_Products(396f958d-1952-4c6f-ac66-9211962720d4)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 67, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 1.23, \"Currency\": \"BGN\" } } ] } Create a sales order with automatic calculation of line prices and amounts The term \"automatic\" actually means the execution of the front-end business rules, related to the sales order and its sales order lines. Therefore, this is only possible in a front-end transaction. POST ~/BeginTransaction { \"model\": \"frontend\" } After, just create the sales order and its lines at once: POST ~/Crm_Sales_SalesOrders TransactionId: xxxx { \"DocumentNo\": \"12345\", \"DocumentType\": { \"@odata.id\": \"General_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)\" }, \"EnterpriseCompany\": { \"@odata.id\": \"General_EnterpriseCompanies(b11b2f31-71b5-4443-a4b7-b5e9cd664a64)\" }, \"Customer\": { \"@odata.id\": \"Crm_Customers(eebf02a5-052e-4a8d-9a24-270546d73942)\" }, \"DocumentCurrency\": { \"@odata.id\": \"General_Currencies(3187833a-d3c1-4804-bfc0-e17e6aee3069)\" }, \"Lines\": [ { \"LineNo\": 10, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 2, \"Unit\": \"PCS\" }, \"Product\": { \"@odata.id\": \"General_Products_Products(bc5a90ed-eca3-4e70-9987-395da25f6487)\" } } ] } Finally, commit the transaction: POST ~/EndTransaction TransactionId: xxxx { \"commit\": true }"
  },
  "domain-api/complex-types/amount.html": {
    "href": "domain-api/complex-types/amount.html",
    "title": "Amount (Complex value) | ERP.net Developer Docs",
    "summary": "Amount (Complex value) The ERP domain model declares a special type for amount (currency) properties. The amount is represented by value and currency. Properties Name Type Description Currency String The currency of the amount represented by it's sign. Value Decimal The value of the amount. Domain API Example: { \"LineAmount\": { \"Value\": \"3.55\", \"Currency\": \"USD\" } } Note Because Amount is odata complex object it can not participate in uri $filter query parameter. To filter by Amount or Quantity properties you can use the following: ~/Logistics_Inventory_StoreTransactionLines?$filter=QuantityValue ge 5.555 ~/Crm_Sales_SalesOrderLines?$filter=LineAmountValue ge 5.555"
  },
  "domain-api/complex-types/custom-property-value.html": {
    "href": "domain-api/complex-types/custom-property-value.html",
    "title": "Custom Property Value | ERP.net Developer Docs",
    "summary": "Custom Property Value Custom Properties (also called Custom Attributes in the domain terminology) are user-defined attributes, which can supplement the predefined system attributes. Definition of а Custom Property For reference information about the definition of the custom properties, see @General.CustomProperties. Here are some highlights for the definition record: EntityName contains the name of the entity, for which the property is defined. You can find the entity name for each entity in the model documentation. For example, the entity name for @Crm.Customers is \"Crm_Customers\" (check it out in the link - see the tag line under the entity name). LimitToAllowedValues - this defines whether the property is free text or is limited to a list of allowed values. AllowedValuesEntityName - specifies that the allowed values are retrieved from the specified entity. When this is NULL, the allowed values are retrieved from @General.CustomPropertyAllowedValues . Data type and values In the Domain API, the custom properties are properties of type General_CustomPropertyValue. The API name of the custom property starts with 'CustomProperty_' followed by the user defined property code. Note Properties with Code, which does not conform to the specification for identifier name, might not be accessible through the API. See Identifier Name Specification. Each database contains different custom properties and that is why each database have different EDM model ($metadata). Reset If a user creates new custom property in the database, this custom property is not exposed in the Domain API in real time. This is because the Domain API caches all repositories and their attributes until next restart. To refresh the cached attributes you must call the ~/domain/reset endpoint. Example: https://demodb.my.erp.net/api/domain/reset Note Executing /reset requires authenticated user connection. Composition of the CustomPropertyValue type Name Type Description Value String The short value. This is the actual value of the custom property. Description MultilanguageString This is long, descriptive, multi-language value of the custom property. Can be null. ValueId Guid The Id of the entry represented by the property value. It's the id of the allowed value. Can be null. Example \"CustomProperty_color\": { \"Value\": \"аpple\", \"ValueId\": \"5263a2d3-88b0-41db-adae-31c76135719e\", \"Description\": { \"EN\": \"The Apple.\", \"DE\": \"Die Apfel.\" } } Note To filter by Custom Property you must use only the short value (only eq is supported): General_Products_Products?$top=10&$select=CustomProperty_color&$filter=CustomProperty_color eq 'apple'"
  },
  "domain-api/complex-types/index.html": {
    "href": "domain-api/complex-types/index.html",
    "title": "Complex types | ERP.net Developer Docs",
    "summary": "Complex types Complex types are used in OData to encapsulate richer data types for properties. Complex types are a composition of properties. ERP.net utilizes the following complex types: Amount Quantity CustomPropertyValue MultilanguageString"
  },
  "domain-api/complex-types/multi-language-string.html": {
    "href": "domain-api/complex-types/multi-language-string.html",
    "title": "Multilanguage string (Complex value) | ERP.net Developer Docs",
    "summary": "Multilanguage string (Complex value) Some text properties support value in more than one language. This properties are of multi-language string type. The multi-language string can store many language strings, indexing them by language key. The language key is a CultureInfo two letter ISO language name, like \"en\", \"de\", etc. For example, the name of a product is a data attribute, which can simultaneously contain translation of the product name in many languages. When you retrieve the value of this attribute with the Domain API, you get values similar to: { \"en\": \"Apple\", \"de\": \"Apfel\" } All translations are a single value All translations in a multi-language string are treated as a single value. You cannot change only one language pair - all pairs are updated simultaneously. The client applications are responsible for managing all language pairs. Filtering The equality comparison for multi-language string is ambiguous. The APIs generally do not support direct equality comparisons. Note Domain API supports only the filter function contains. For example, in Domain API, the following is supported: ~/General_Products_Products?$filter=contains(Name,'ppl') However, this is not valid: ~/General_Products_Products?$filter=Name eq 'Apple'"
  },
  "domain-api/complex-types/quantity.html": {
    "href": "domain-api/complex-types/quantity.html",
    "title": "Quantity (Complex value) | ERP.net Developer Docs",
    "summary": "Quantity (Complex value) The ERP domain model declares a special type for quantity properties. The quantity is represented by value and measurement unit. Properties Name Type Description Unit String TThe measurement unit of the quantity represented by it's code. Value Decimal The value of the quantity. Domain API Example: { \"LineAmount\": { \"Value\": \"5.555\", \"Unit\": \"PCS\" } } Note Because Quantity is odata complex object it can not participate in uri $filter query parameter. To filter by Amount or Quantity properties you can use the following: ~/Logistics_Inventory_StoreTransactionLines?$filter=QuantityValue ge 5.555 ~/Crm_Sales_SalesOrderLines?$filter=LineAmountValue ge 5.555"
  },
  "domain-api/data-manipulation/index.html": {
    "href": "domain-api/data-manipulation/index.html",
    "title": "Data Manipulation | ERP.net Developer Docs",
    "summary": "Data Manipulation Create Operations Creating Entities: Provide guidelines for creating new records. Required Fields: List mandatory fields for entity creation. Validation: Explain validation mechanisms during creation. Update Operations Updating Entities: Describe how to modify existing records. Partial Updates: Explain partial update strategies. Concurrency Control: Discuss handling concurrent updates. Delete Operations Deleting Entities: Provide steps to delete records. Soft vs. Hard Deletes: Explain the difference and when to use each. Cascade Deletes: Discuss implications of cascading deletes. Transactions BeginTransaction and EndTransaction: Explain how to start and commit transactions. Entity Changes: Detail how to track and apply changes to entities within a transaction. Concurrency Handling: Discuss strategies for managing concurrent data modifications. ERP.net action annotation Data Import Import Strategies: Outline methods for importing large datasets. Data Mapping: Discuss mapping external data to ERP.net entities. Error Handling: Provide guidelines for managing import errors. Data Synchronization Sync Mechanisms: Describe methods for synchronizing data between ERP.net and external systems. Conflict Resolution: Explain strategies for resolving data conflicts. Scheduling Syncs: Discuss scheduling and automating synchronization tasks."
  },
  "domain-api/data-sync/event-push.html": {
    "href": "domain-api/data-sync/event-push.html",
    "title": "Event push | ERP.net Developer Docs",
    "summary": "Event push Pushing events allows external app to be notified in real time when an event is triggered in ERP.net. Event push in ERP.net is implemented through Webhooks. Webhooks A Webhook is simply a way for ERP.net to call an external app in (near) real time. Webhooks are setup in two steps: A webhook template is setup in the Web Hooks entity. The template is activated using the WEBHOOK action in a User-defined business rule. Note Setting up user-defined business rules (UDBR) is outside the scope of this topic. UDBR allows you to select the business events which need to be pushed to the external app. For assistance in setting up UDBR, seek professional advice. Destination Webhooks allow ERP.net to call the external app in near real-time. However, if for any reason, the app is not able to accept the call, the event might be missed. We strongly advice, the usage of webhooks to be only for pushing an event to an enterprise grade messaging system, such as the Azure Service Bus. Usage It is up to the receiving application to decide what to do with the event. However, it usually updates some internal state, based on the event. In case the external app implements some forms of data sync between its private database and ERP.net, you might want to check the Object version topic."
  },
  "domain-api/data-sync/index.html": {
    "href": "domain-api/data-sync/index.html",
    "title": "Data synchronization | ERP.net Developer Docs",
    "summary": "Data synchronization Data sync occurs in many scenarios, where an external app synchronizes data betweed it and ERP.net. Data sync tasks of an external app include: Receive real time notifications for changes in ERP.net Check whether an object is updated in ERP.net since last check Implement UI with Optimistic locking for data, stored in ERP.net The data sync framework implemented in ERP.net Domain API allows efficient implementation of such scenarios. For more information, select from the topics below: Event push Object version Optimistic locking Note The data sync support is first available in ERP.net v.2022.1."
  },
  "domain-api/data-sync/object-version.html": {
    "href": "domain-api/data-sync/object-version.html",
    "title": "Object version | ERP.net Developer Docs",
    "summary": "Object version Object version is a system and API supported way for applications to track changes in ERP.net entities. Change tracking The changes are aggregated in the Entity aggregates. This means, that, if for example, an external app updates a single Sales Order Line, the update creates a new version for the whole Sales Order aggregate. Object version reflects this change by increasing its counter with 1. In short, Object version is owned by the aggregate root and it's a subject for the whole aggregate tree. The version will increment after each change in the aggregate tree- this means attributes, custom properties, references, etc. Note Applications should not depend on strict monotonically increasing values of Object version. In some scenarios, it might skip values. However, it is guaranteed, that upon update, the value is changed. Setup In order for the Object version system to start working, the aggregate (e.g, its root entity) must be setup to Track Changes with at least level 1. Usage Object version is available through the Domain API for each entity type. In order for the API to return the object version, it must be explicitly selected in the API call. For example: Crm_Sales_SalesOrders(a727114c-3b36-e311-81cb-00155d001f00)?$select=Lines,ObjectVersion&$expand=Lines($select=ObjectVersion,default) Note Retrieving the object version is resource intensive operation. Perform it only when strictly necessary and only for the entities, for which it is required."
  },
  "domain-api/data-sync/optimistic-locking.html": {
    "href": "domain-api/data-sync/optimistic-locking.html",
    "title": "Optimistic locking | ERP.net Developer Docs",
    "summary": "Optimistic locking Optimistic concurrency control is a no-lock concurrency control method. In ERP.net it is implemented through the Object version API. Optimistic locking is usually used in the following scenarios: Replication of data between external data source and ERP.net. Implementing external UI for data apps. Usage scenario External app allows its users to modify an entity, stored in an ERP.net instance. The external app reads the entity, including the Object version. The external app presents a UI to the end user and allows them to edit the entity. When the user saves the data, the app call the update API, providing the data + the previously read Object version. The system checks whether the Object version in the ERP.net instance is still the same and proceeds with the update ONLY if it is the same; otherwise, it returns error. Note For replication scenarios, the steps are the same, with the exception of step 2, which might not be a UI, but a time frame between two synchronizations. By implementing the above scenario, the app guarantees that it would not overwrite other apps changes if such have occurred in ERP.net between step 1 and step 3. Note It is the decision of the app to provide Object version when updating the entity. If Object version is not provided, the system would not perform the optimistic locking check."
  },
  "domain-api/erpnet-action.html": {
    "href": "domain-api/erpnet-action.html",
    "title": "instance annotation | ERP.net Developer Docs",
    "summary": "@erpnet.action instance annotation In OData instance annotations can be used to define additional information associated with a particular result, entity, property, or error. The @erpnet.action annotation can be provided in the body of update request (POST, PATCH) or in the Import action. Example usage POST General_Products_Products { \"@erpnet.action\": \"merge\", \"PartNumber\": \"DAT003\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": {\"Name\": \"Unit\" } }, \"MeasurementUnit\": { \"Code\": \"PCE\" }, \"Name\": {\"EN\": \"Domain API Test 002\"}, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": {\"EN\": \"Domain API Tests\"} } } The purpose of this annotation is to provide a better way to import, update, or create data. The value of the @erpnet.action annotation determines the type of operation that will be performed using the provided JSON data. Allowed values Action Description create Always creates a new object. update Updates an existing object. This is the default for the top-level JSON object in a PATCH request. If @erpnet.action: update is explicitly specified for a nested (referenced) object, the properties of the referenced object are modified. delete Deletes an existing object. Can be used in Import. find Searches for a matching object and uses the first found. If no matching object is found, an error is thrown. If the JSON object contains data properties, they are ignored — the found object remains unchanged. findOrNull Searches for a matching object and uses the first found. If none is found, returns null. If the JSON object contains data properties, they are ignored — the found object remains unchanged. findOrCreate Searches for a matching object and uses the first found. If none is found, a new object is created and populated with the provided data properties. findSingle Searches for a matching object and uses the first found. If no matching object is found or more than one matching object is found, an error is thrown. findSingleOrNull Searches for a matching object and uses the first found. If no matching object is found or more than one matching object is found, returns null. merge Searches for a matching object and uses the first found. If none is found, a new object is created and populated with the provided data properties. If an existing object is found, it is updated with the provided data properties. Default values If the @erpnet.action annotation is not present in the object, the following defaults are applied: For top-level objects: POST → @erpnet.action: create PATCH → @erpnet.action: update For nested objects: If only properties defining the search criteria are provided (either @erpnet.findBy or data properties usable in a find action), → @erpnet.action: find Otherwise → @erpnet.action: merge @erpnet.findBy Annotation The @erpnet.findBy annotation explicitly defines the search criteria used when an existing object should be located. It is applicable to the following @erpnet.action values: find findOrNull findOrCreate findSingle findSingleOrNull merge Structure The value of the annotation is an object with one or more of the following string properties: { \"ExternalId\": \"...\", \"ExternalSystem\": \"...\", \"Id\": \"...\", \"Code\": \"...\", \"Name\": \"...\", \"DisplayText\": \"...\" } Property Details ExternalId — Used to find an existing object by its specific external identifier. ExternalSystem — Optional. Can be provided alongside ExternalId to further qualify the search. Id — Used to find an object by its unique identifier (Guid). Code — Used to find an object by its code. This applies only to entities that provide a CodeDataMember. The CodeDataMember for a specific entity can be found in its documentation. Name — Used to find an object by its name. This applies only to entities that provide a NameDataMember. The NameDataMember for a specific entity can be found in its documentation. The search operation performs a case-insensitive contains match. DisplayText — Searches by the entity’s display text using a contains operation. This is equivalent to using the $search parameter in OData queries. Find Criteria Evaluation The find operation uses only the first available criterion from the @erpnet.findBy annotation in the following priority order: ExternalId (+ optional ExternalSystem) Id Code Name DisplayText If multiple properties are specified, only the first one (in the order they appear) is used. For example: \"@erpnet.findBy\": { \"ExternalId\": \"123\", \"ExternalSystem\": \"SomeSystem\", \"Code\": \"345\" } In this case, the search will be performed only by ExternalId and ExternalSystem, while Code will be ignored. Default behavior If the @erpnet.findBy annotation is omitted, the search criteria are automatically derived from the provided object’s properties. For example { \"Customer\": { \"Number\": \"Г89163\" } } is equivalent to { \"Customer\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": {\"Code\": \"Г89163\"} } } because \"Number\" is the CodeDataMember for customers we perform search by Code. This is a nested object and only CodeDataMember property is provided so the @erpnet.action is determined as find. Examples In this example, we create a sales order without using any IDs. The system automatically determines the @erpnet.action and @erpnet.findBy criteria based on the provided properties. POST Crm_Sales_SalesOrders { \"DocumentType\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"Code\": \"CRM_SALES_ORDER\" }, \"EnterpriseCompany\": { // defaults to: @erpnet.action = find \"@erpnet.findBy\": { \"Code\": \"546346373\" } }, \"EnterpriseCompanyLocation\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"PartyCode\": \"00193\" }, \"Customer\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"Number\": \"Г89163\" }, \"DocumentCurrency\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"CurrencySign\": \"BGN\" }, \"Lines\": [ { \"Product\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"PartNumber\": \"DAT001\" }, \"QuantityUnit\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"Code\": \"PCE\" }, \"Quantity\": { \"Value\": 1, \"Unit\": \"PCE\" }, \"UnitPrice\": { \"Value\": 20, \"Currency\": \"BGN\" } } ] }"
  },
  "domain-api/import.html": {
    "href": "domain-api/import.html",
    "title": "Import | ERP.net Developer Docs",
    "summary": "Import ERP.net Domain API defines an Import endpoint which can be used to import multiple entities at once. Import is unbound (not bound to any entity) action (actions are called with HTTP POST method) that inserts, updates or deletes multiple objects. Specification with example: { \"transaction\": \"all-objects\" | \"per-object\" (default), \"model\": \"frontend\" (default) | \"backend\", \"objects\": [ { \"@odata.type\": \"Crm_Sales_Customers\", \"@erpnet.action\": \"merge\" (default) | \"create\" | \"update\" | \"delete\" ... }, ... ] } Parameters model: - allowed values are common or frontend. This parameter indicates the data model used for the import. Front-end data model uses front-end business rules. For example front-end logic is when Quantity of a SalesOrderLine is changed the corresponding QuantityBase is calculated by a dedicated front-end business rule. Common model defines minimal business logic applicable in all cases - front-end or back-end. The default is frontend. transaction: - all-objects or per-object. This parameter defines when the changes will be commited to the database. If all-objects is specified all changes are committed at once at the end of the import. If per-object is specified every object is saved when it is ready. The default is per-object. objects - an array of entity objects for import. Properties of the objects element \"@odata.type\" - Each object must specify valid entity type. The entity type is the singular form of the entity set and can be found in the documentation for each entity. The @odata.type always starts with the default namespace Erp. - Example Erp.General_Products_Product \"@erpnet.action\" - This is an optional annotation for the desired import action. For top-level objects the default action is create. For more information see this article. \"@erpnet.findBy\" - This is an optional annotation that specifies the search criteria for the find action. For more information see this article. Any data property of the imported object. Return value Specification with example { \"result\": \"success\" | \"fail\", \"objects\": [ { \"@erpnet.result\": \"success\" | \"fail\", \"@odata.id\": \"Crm_Sales_Customers(<guid>)\", \"@erpnet.message\": \"<error-message>\" \"@erpnet.state\": \"Added\" | \"Modified\" | \"Deleted\" | \"Unchanged\" }, ... ] } Properties of the result value \"@erpnet.result\" - success or fail. The result is success only if all objects are imported successfully. objects - an array of object results - one object for each imported object. Properies of the each returned object \"@erpnet.result\" - success or fail. \"@odata.id\" - the ODATA Id of the imported object. If result is fail this is not available. \"@erpnet.message\" - the error message. \"@erpnet.state\" - the status of the imported object. One of \"Added\" | \"Modified\" | \"Deleted\" | \"Unchanged\". Indicates the operation performed for the object. Only the \"@odata.id\" is included in the result - no other properties. Examples The following example performs merge action for General_Products_Products. If existing product is found by the provided ExternalId it's PartNumber, BaseMeasurementCategory, MeasurementUnit, Name and ProductGroup are updated. The action for the referenced objects is find because the included properties are only these that can be used in find criteria. BaseMeasurementCategory is searched by Name (providing @erpnet.findBy), MeasurementUnit and ProductGroup are searched by Code. POST ~/Import { \"model\": \"frontend\", \"transaction\": \"per-object\", \"objects\": [ { \"@odata.type\": \"Erp.General_Products_Product\", \"@erpnet.action\": \"merge\", \"ExternalId\": \"EXT000\", \"PartNumber\": \"DATP000\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": { \"Name\": \"Unit\" } }, \"MeasurementUnit\": { \"Code\": \"PCE\" }, \"Name\": { \"EN\": \"Domain API Test 000\" }, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": { \"EN\": \"Domain API Tests\" } } }, { \"@odata.type\": \"Erp.General_Products_Product\", \"@erpnet.action\": \"merge\", \"ExternalId\": \"EXT001\", \"PartNumber\": \"DATP001\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": { \"Name\": \"Unit\" } }, \"MeasurementUnit\": { \"Code\": \"PCE\" }, \"Name\": { \"EN\": \"Domain API Test 001\" }, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": { \"EN\": \"Domain API Tests\" } } }, { \"@odata.type\": \"Erp.General_Products_Product\", \"@erpnet.action\": \"merge\", \"ExternalId\": \"EXT002\", \"PartNumber\": \"DATP002\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": { \"Name\": \"Unit\" } }, \"MeasurementUnit\": { \"Code\": \"PCE\" }, \"Name\": { \"EN\": \"Domain API Test 002\" }, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": { \"EN\": \"Domain API Tests\" } } } ] }"
  },
  "domain-api/index.html": {
    "href": "domain-api/index.html",
    "title": "Domain API | ERP.net Developer Docs",
    "summary": "Domain API Introduction The Domain API is the primary API for accessing and manipulating data in ERP.net. It is most useful for UI and service apps. For BI, you should use the Table API. For an overview and introduction of the Domain API, read the thorough presentation at the home page of the developer docs. Based on OData The Domain API is based on the OData protocol. It allows object-oriented access to the data exposed by the ERP.net domain objects. The OData API is structured along a number of entity types (called \"repositories\" in ERP.net), that represent the Domain Model of the ERP Instance. Each entity type contains data attributes, which can be filtered, sorted, etc. The model also provides information on how to navigate between the repositories. For a quick introduction to OData, check the beginners tutorial at the OData site: https://www.odata.org/getting-started/understand-odata-in-6-steps/ Step by step To learn more about the ERP.net Domain API, read below: Querying data - Introduction to data querying. URL components - OData is heavy on the URL. Read this topic to understand the structure of the URL. Query options - read more about the supported OData query constructs like $filter, $top and similar. Query Builder - the visual query designer can help you easily build complex $select/$expand queries. Complex types - ERP.net defines several OData complex types, including quantity, amount and multi-language string. Transactions - ERP.net supports server-side front-end transactions. Working with documents - working with documents is a common scenario when using the API. Batch requests (OData site) - ERP.net fully supports batch requests, saving round-trips to the server."
  },
  "domain-api/libraries.html": {
    "href": "domain-api/libraries.html",
    "title": "| ERP.net Developer Docs",
    "summary": "The Domain API is based on the OData protocol. It allows object-oriented access to the data exposed by the ERP.net domain objects. Since the Domain API is an HTTP RESTfull API, it can be accessed by simple HTTP requests. However there are many ODATA libraries that can be used. ERP.net libraries .NET ErpNet.Api.Client - Handles authentication of service clients and work with Domain API requests, both - untyped and typed. Javascript oidc-client - Library to provide OpenID Connect (OIDC) and OAuth2 protocol support for client-side, browser-based JavaScript client applications. Also included is support for user session and access token management. PHP OpenIdConnect client - A simple library that allows an application to authenticate a user through the basic OpenID Connect flow."
  },
  "domain-api/querying-data/filterable-references.html": {
    "href": "domain-api/querying-data/filterable-references.html",
    "title": "Filterable references | ERP.net Developer Docs",
    "summary": "Filterable references Overview Query filters allow each attribute from the entity to be filtered. References also can be filtered, by equalling them to single or multiple instances of the referenced entity. Sometimes however, we don't know the exact referened entity, but want to filter by the attributes of the referenced entity. Note In SQL terms, this is very similar to JOIN-ing the referenced table and then filtering in the WHERE by some of the columns of the referenced table. For example, in the Customers Entity, we might want to filter by the attributes of the related Parties Entity. Finding out if a reference is filterable Because of the static way the SQL data access layer is built (using only Stored Procedures), filtering by the attributes of a referenced entity is not always possible. To be able to filter by a reference, the auto-generated SQL procedures should already JOIN the referenced table. For this reason, only a handful of the referenes support filtering. Note Ownership references are ALWAYS filterable. For example, starting from SalesOrderLines Entity, you can filter by the attributes of the SalesOrder. To find out if an attribute supports filtering, look for the FilterableReference tag in the attribute details. For example, see how StoreOrderLine reference is filterable: https://docs.erp.net/model/entities/Crm.Customers.html#party Try in Query Builder To filter the customers by the attributes of the related party, you can use the following query: https://testdb.my.erp.net/api/domain/querybuilder?Crm_Customers?$filter=contains(Party/PartyName,'com')&$expand=Party($select=PartyName)&$select=Party To filter the sales order lines by the attributes of the owner sales order, you can use the following query: https://testdb.my.erp.net/api/domain/querybuilder?Crm_Sales_SalesOrderLines?$top=10&$filter=SalesOrder/State%20eq%20'Released'%20and%20SalesOrder/Void%20eq%20false To filter the unfulfilled store order lines view by the state of the store order use the following query: https://testdb.my.erp.net/api/domain/querybuilder?Logistics_Inventory_StoreOrderLinesUnfulfilledView?$top=10&$filter=StoreOrderLine/StoreOrder/State%20eq%20%27Released%27"
  },
  "domain-api/querying-data/index.html": {
    "href": "domain-api/querying-data/index.html",
    "title": "| ERP.net Developer Docs",
    "summary": "2. Querying Data The Querying Data section explains how to retrieve information from ERP.net using the Domain API. All queries use standard OData conventions, with some ERP.net-specific extensions. 2.1 OData Basics ERP.net exposes entities (repositories) through an OData-compliant service. Each entity represents a type of data in the system, such as Customer, Order, or Product. Service Root URL: The base URL for all queries. Example: Entity Types: Each entity can be queried independently. Common entities include: Crm_Sales_Customers Crm_Sales_SalesOrders General_Products_Products 2.2 Query Options ERP.net supports standard OData query options: $filter: Filter data using conditions. Example: Retrieve orders where Status eq 'Open'. $select: Retrieve only specific fields to reduce payload. Example: ?$select=Id,Name,Status $expand: Include related entities in the response. Example: ?$expand=Customer,Lines $orderby: Sort the results by a specific field. Example: ?$orderby=DocumentDate desc $top / $skip: Control pagination. Example: ?$top=50&$skip=100 $count: Get the total number of records matching the query. Example: ?$count=true $search: Search by DisplayText of the specific entity. Example: ?$search=\"Widget\" Here is an extended topic for Query Options 2.3 Query Builder ERP.net includes a Visual Query Designer to simplify query creation. For more examples and instructions, see Query Builder. Select the entity type to query. Choose fields and relationships. Add filters, sorting, and pagination. Preview and execute the query. 2.4 Query Tool ERP.net provides a Query Tool to quickly test and explore queries in your browser. You can run OData queries directly against your service without writing code. Example: Retrieve the top 10 products and include their product groups, sorted by part number: https://testdb.my.erp.net/api/domain/query?GET+General_Products_Products?$top=10&$expand=ProductGroup&$orderby=PartNumber Use this tool to experiment with $filter, $select, $expand, $orderby, and other query options interactively. Example Queries: https://testdb.my.erp.net/api/domain/odata/Crm_Sales_Customers?$top=5&$select=Party,Number,CreditLimit&$expand=Party https://testdb.my.erp.net/api/domain/odata/General_Products_Products?$top=10&$expand=ProductGroup&$orderby=PartNumber 2.5 Handling Complex Data Types Some entities include complex or multi-part data types. For detailed explanations and examples, see Complex Data Types. Multi-language Strings: Some fields may have different values for each language. These fields are represented as a complex object with one property per language. For example: { \"Name\": { \"EN\": \"Laptop\", \"DE\": \"Laptop\", \"FR\": \"Ordinateur portable\" } } Use the property corresponding to the desired language when displaying or processing the value. NOTE: Multi-language fields support only filtering with the contains(Field, 'value') function. Other filter operators are not supported. Quantities and Amounts: Fields with units (e.g., Quantity, Amount) require attention to precision and currency. Example: \"Quantity\": { \"Value\": 12.5, \"Unit\": \"kg\", } \"Amount\": { \"Value\": 250.00, \"Currency\": \"USD\" } Enums and References: Some fields reference other entities or use enumerated values. Use $expand or lookups to resolve them. Example: { \"State\": \"New\", \"Customer\": { \"Id\": 123, \"Number\": \"009987\" } } The enum values are represented as string. You can filter by enum value like this Crm_Sales_SalesOrders?$top=10&$filter=State eq 'Released'&$orderby=DocumentDate desc To filter by reference use it's odata id: Crm_Sales_SalesOrders?$top=10&$filter=DocumentType eq 'Systems_Documents_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)' 2.6 Filterable References Some ERP.net entities include reference fields, which point to other entities. In OData queries, you can filter data based on properties of the referenced entity. Example: Retrieve sales order lines where the parent order's document date is on or after October 23, 2025: Crm_Sales_SalesOrderLines?$filter=SalesOrder/DocumentDate ge 2025-10-23T00:00:00 Concept: The filter navigates through the reference (SalesOrder) to access a property (DocumentDate) of the related entity. Important: Not all reference fields support filtering. Only certain reference fields are filterable. For more information see Filterable References. 2.7 Batch Requests ERP.net supports batch requests, allowing multiple queries in a single HTTP request: Combine multiple read or write requests into one batch. Reduce network overhead and improve performance. Example use cases: retrieving multiple entity types or related data simultaneously. Best Practices: Keep batches reasonably sized to avoid timeouts."
  },
  "domain-api/querying-data/query-builder.html": {
    "href": "domain-api/querying-data/query-builder.html",
    "title": "Query Builder | ERP.net Developer Docs",
    "summary": "Query Builder Description ERP.net has an integrated visual Query Builder. The Query Builder allows building queries, specific to the ERP Instance. When you use the Query Builder, it allows you to select the user-defined data and calculated attributes in that instance. The Query Builder allows the developers to create the query visually and then just re-use the query text, replacing the parameters. Try it To access the Query Builder for DEMODB, go to: https://demodb.my.erp.net/api/domain/querybuilder Tip User: Admin Password: 123 While the query is built, the Query Builder changes its URL. For example, to preview the same query for the first 10 products in the Query Builder, head to: https://demodb.my.erp.net/api/domain/querybuilder#General_Products_Products?$top=10 When you press Execute in the Query Builder, you can preview the result both as table and as JSON. Note Pay attention to the link under the selected entity, which opens the documentation for the entity."
  },
  "domain-api/querying-data/query-options/filter.html": {
    "href": "domain-api/querying-data/query-options/filter.html",
    "title": "$filter query option | ERP.net Developer Docs",
    "summary": "$filter query option $filter is a standard OData query option, implemented with some limitations in ERP.net. Not every operation and function provided by the OData standard are implemented. For a great introduction to $filter, read the OData $filter tutorial. This article mostly emphasizes on the implementation details of $filter in ERP.net. Supported operators Operator Description eq Equal ge Greater than or equal le Less than or equal and Returns true if both the left and right operands evaluate to true. in The in operator returns true if the left operand is a member of the right operand. The right operand MUST be a comma-separated list of primitive value. Operator 'or' is not supported Operator 'or' is not supported. However all navigation properties and some properties of enumerable type (e.g. General_Document.State) support the 'in' operator. Operator 'in' The 'in' operator can be used for minimizing the query round trips. Examples: List of Id values: General_Products_Products?$filter=Id in (0e8fb111-5b04-4eab-a890-47cfb9cfa4c4, 14389ba0-ee5c-459e-afd0-d74c17240f28) List of enum values: Crm_Sales_SalesOrders?$top=10&$filter=State in ('FirmPlanned', 'Released')&$select=State List of reference values: Crm_Sales_SalesOrders?$top=10&$select=DocumentType&$filter=DocumentType in ('General_DocumentTypes(f8a93d3a-8cf3-4a09-9d45-667d664cb98d)', 'General_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)') List of reference values with different object types (the reference is of the base object type): Crm_Sales_SalesOrders?$top=10&$filter=ToParty in ('General_Contacts_Persons(adb66f3f-e173-4a37-878c-000920f44ff0)', 'General_Contacts_Companies(39148781-d316-4d4d-a392-0002f73710f2)') Filter by date and date-time attributes Example: Crm_Sales_SalesOrders?$top=10&$filter=DocumentDate ge 2020-01-01Z Note! Filter by date-time is not supported! A date-time value in the filter is truncated to date only. For example $filter=TransactionTimestamp le 2020-01-05T23:59:59.999Z is converted to $filter=TransactionTimestamp le 2020-01-05T00:00:00Z. If we want to find all store transaction lines for date 2020-01-05 we should make filter $filter=TransactionTimestamp ge 2020-01-05T00:00:00Z and TransactionTimestamp ge 2020-01-06T00:00:00Z and then in the result we must check for lines on 2020-01-06. Filter by complex attributes In ODATA complex objects can not participate in the $filter clause. The quantities and amounts in DomainApi are represented as complex objects that contain the value and the measurement unit (or currency). To filter by Amount or Quantity attribute you can use the name of the attribute followed by 'Value': ~/Logistics_Inventory_StoreTransactionLines?$filter=QuantityValue ge 5.555 ~/Crm_Sales_SalesOrderLines?$filter=LineAmountValue ge 5.555 CustomPropertyValue is another complex type. To filter by Custom Property you must use only the short value (only eq is supported): General_Products_Products?$top=10&$select=CustomProperty_color&$filter=CustomProperty_color eq 'blue' MultilanguageString is another complex type. Multi-language properties support only filter function contains: ~/General_Products_Products?$filter=contains(Name,'ppl') This is an invalid filter: ~/General_Products_Products?$filter=Name eq 'Apple' Supported standard functions Edm.Boolean contains(Edm.String, Edm.String) Edm.Boolean endswith(Edm.String, Edm.String) Edm.Boolean startswith(Edm.String, Edm.String) Supported non-standard $filter functions Edm.Boolean contains(Erp.MultilanguageString, Edm.String) Returns true if the second string is contained in any language of the first multi-language string. Example: ~/Crm_Customers?$filter=contains(Party/PartyName,'Peter') Edm.Boolean contains(NavigationProperty, Edm.String) Returns true if the string is contained in the entity, refereced by the navigation property. Example: ~/Crm_Customers?$filter=contains(SalesPerson,'Peter') Edm.Boolean equalnull(any-type,any-type) Returns true if the first argument is equal to the second argument or the first argument is null. Example: ~/Crm_Sales_SalesOrders?&$filter=equalnull(Store,'Logistics_Inventory_Stores(8d7dd360-17cc-47f4-a878-1ee0f06445ad)') Edm.Boolean lessequalnull(any-type,any-type) Returns true if the first argument is less than or equal to the second argument or the first argument is null. Example: ~/Crm_SalesPersons?$top=10&$filter=lessequalnull(ContractEndDate,2019-02-01T00:00:00.000Z) Edm.Boolean greaterequalnull(any-type,any-type) Returns true if the first argument is greater than or equal to the second argument or the first argument is null. Example: ~/Crm_SalesPersons?$top=10&$filter=greaterequalnull(ContractStartDate,2019-02-01T00:00:00.000Z)"
  },
  "domain-api/querying-data/query-options/index.html": {
    "href": "domain-api/querying-data/query-options/index.html",
    "title": "Query options | ERP.net Developer Docs",
    "summary": "Query options Query options allow you to control the amount and order of the data that a data service returns for the resource identified by the URI. OData system query options are provided by the OData framework and documented in detail in the OData specification at http://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part2-url-conventions.html. For a great introduction to query options, read the OData query data tutorial. List of supported query options Query Option Origin Description $count OData The $count system query option allows clients to request a count of the matching resources included with the resources in the response. The $count query option has a Boolean value of true or false. $expand OData The $expand system query option specifies the related resources or media streams to be included in line with retrieved resources. $filter OData The $filter system query option allows clients to filter a collection of resources that are addressed by a request URL. $metadata OData Returns the data model (which is the structure of all resources). $orderby OData Specifies an expression for determining which values are used to order the collection of records identified by the resource path section of the URI. $select OData Limits the data to the specified attributes. $skip OData The $skip query option requests the number of items in the queried collection that are to be skipped and not included in the result. $top OData The $top system query option requests the number of items in the queried collection to be included in the result. $search OData The $search system query option allows clients to request items within a collection matching a free-text. Each entity implements the searching in a different way. options Extension List of comma separated options/flags that affect the behavior of the system. Note Options marked as \"Extension\" are not part of the OData standard and are specific to the ERP.net Domain API. They do not use $ in front of their name, as it is reserved for standard OData query options."
  },
  "domain-api/querying-data/query-options/options.html": {
    "href": "domain-api/querying-data/query-options/options.html",
    "title": "| ERP.net Developer Docs",
    "summary": "options query option Note options is Domain API specific option and is not part of the OData standard. Therefore, this option DOES NOT have \"$\" in front of its name. options contains option flags, which are provided as url arguments. Flag Description skipnulls Indicates that properties with null value are not returned in the JSON result. Example: options=skipnulls"
  },
  "domain-api/querying-data/query-options/search.html": {
    "href": "domain-api/querying-data/query-options/search.html",
    "title": "$search query option | ERP.net Developer Docs",
    "summary": "$search query option Description $search is a system query option, a standard one in the OData protocol. The $search system query option restricts the result to include only those entities, matching the specified search expression. The search expression is a freeform string. For more detailed info, strictly defined according to the OData protocol, check this resource here. How the search works When an entity is searched, it's checked for a match between the searched string and the value of one or more attributes. Exactly which attributes of the entity will be checked for a match, depends on which are specified in the entity's default search members and display text format. Note The attributes for an entity to search for a match are those, defined in the Default search members and the Display text format. For each different entity. Default search members They're defined at the system level and may differ for different entities. The exact search members for each entity can be found in the documentation, but there's a rule that's generally true in most cases, Note The default search members (i.e. attributes) for an entity are these, supporting Code and Name. E.g. the Customers entity has its default search members: Number; Party.PartyName https://docs.erp.net/model/entities/Crm.Customers.html Display text The search is also performed on the attributes, part of the display text attribute. It's available for all entities. https://docs.erp.net/model/entities/Systems.Core.EntitySettings.html#displaytextformat https://docs.erp.net/tech/advanced/data-objects/display-format.html Usage Just see the query below, GET ~/Crm_Customers?$select=Number&$search=\"015\" This will return all customers, matching the searched string 015. E.g., { \"@odata.context\": \"~/$metadata#Crm_Customers\", \"value\": [ { \"@odata.id\":\"Crm_Customers(79480957-f0b6-49c4-9874-2cd150de982a)\", \"Number\": \"aa00015\" }, { \"@odata.id\":\"Crm_Customers(806637f2-abd1-4e7b-8ac0-71222a0b1afd)\", \"Number\": \"ab30151\" }, { \"@odata.id\":\"Crm_Customers(f812a533-0e56-4e57-8d1f-52d05b98c8b6)\", \"Number\": \"ab30156\" } ] } The result contains all customers that contain 015 in their number. OK, let's make an another try: GET ~/Crm_Customers?$select=Party&$expand=Party($select=PartyName)&$search=\"UNI\" Here's the result: { \"@odata.context\": \"~/$metadata#Crm_Customers\", \"value\": [ { \"@odata.id\":\"Crm_Customers(eebf02a5-052e-4a8d-9a24-270546d73942)\", \"Party\": { \"@odata.id\":\"General_Contacts_Parties(b8aa4272-3e55-435b-b1ab-170afee896d4)\", \"PartyName\": { \"EN\": \"UNI Sofia Ltd\", \"BG\": \"УНИ София Лтд\" } } } ] } Obviously, the result contains all customers, having a \"UNI\" in their name. The examples above were when we have a match on the default search members- i.e. the Number and Party.PartyName in the Customers entity. Let's see an example where the search will be performed on the members, defined in the entity's display text attribute. To do this, we'll first change the display text format for the customers entity (because the default one is {Party.PartyName:T}) to the following one: {Party.PartyName:T} / {GracePeriodDays} Now if we make a request such as: GET ~/Crm_Customers?$select=Number,GracePeriodDays,Party&$expand=Party($select=PartyName)&$search=\"50\" The result will be the following: { \"@odata.context\": \"~/$metadata#Crm_Customers\", \"value\": [ { \"@odata.id\":\"Crm_Customers(eca3ca4d-c4fa-44df-9983-d69388a8893a)\", \"GracePeriodDays\": 50, \"DisplayText\": \"Test Company 1 Ltd / 50\", \"Number\": \"number001\", \"Party\": { \"@odata.id\":\"General_Contacts_Parties(841e89e4-44c2-4c8f-b4d9-6402c3e5fb28)\", \"PartyName\": { \"EN\": \"Test Company 1 Ltd\" } } }, { \"@odata.id\":\"Crm_Customers(bc446b31-7326-4c35-bca6-55c918e33215)\", \"GracePeriodDays\": 7, \"DisplayText\": \"Test Company 2 Ltd / 7\", \"Number\": \"number050\", \"Party\": { \"@odata.id\":\"General_Contacts_Parties(395fa6b1-8fd4-418a-87f6-d8bece1fc7ad)\", \"PartyName\": { \"EN\": \"Test Company 2 Ltd\" } } } ] } Two customers- the first has a match on the attribute GracePeriodDays (50) and the second has a match on the Number (number050) attribute."
  },
  "domain-api/querying-data/query-options/select.html": {
    "href": "domain-api/querying-data/query-options/select.html",
    "title": "$select query option | ERP.net Developer Docs",
    "summary": "$select query option Description $select is an OData system query option. The $select system query option allows clients to request a specific set of properties for each entity or complex type. For a great introduction to $select, read the OData $filter tutorial. $expand The $select query option is often used in conjunction with the $expand system query option, to define the extent of the resource graph to return ($expand) and then specify a subset of properties for each resource in the graph ($select). Expanded navigation properties MUST be returned, even if they are not specified as a selectItem. Default attributes When there is no $select clause or '$select=*', only the default attributes are returned. The attributes, which are returned by default are: System attributes like Name, Description, PartNumber, etc. References like ProductType, ProductGroup, etc (in OData terminology - Navigation properties) The following attributes are not returned by default: The 'Id' attribute Custom (user-defined) attributes Child lists (OData terminology: Collection navigation properties) Calculated attributes Example: GET ~/General_Products_ProductTypes?$top=2 The result is: { \"@odata.context\": \"https://example-server.com/example-db/api/domain/odata/$metadata#General_Products_ProductTypes\", \"value\": [ { \"@odata.id\": \"General_Products_ProductTypes(c696c660-9aa4-4fe5-a396-126af4101792)\", \"IsDefault\": false, \"IsFixedAsset\": false, \"IsServiceActivityService\": false, \"IsServiced\": true, \"IsShipped\": true, \"IsStocked\": true, \"LotAutoCreation\": true, \"Code\": \"001\", \"Name\": { \"BG\": \"sdds\" } }, { \"@odata.id\": \"General_Products_ProductTypes(880b0c31-a9ef-4a3c-a0e7-13d39aa57464)\", \"IsDefault\": false, \"IsFixedAsset\": false, \"IsServiceActivityService\": false, \"IsServiced\": false, \"IsShipped\": false, \"IsStocked\": false, \"LotAutoCreation\": false, \"Code\": \"test sch\", \"Name\": { \"BG\": \"test sch\" } } ] } Note Non default properties must be explicitly specified in the $select clause. Example: GET ~/General_Products_Products?$top=2&$select=CustomProperty_WebName,CalculatedAttribute_ExampleAttr The result will only contain the selected properties. The default $select keyword You can explicitly use the keyword default in the $select clause to include all default properties. GET ~/General_Products_Products?$top=2&$select=default,CustomProperty_WebName,CalculatedAttribute_ExampleAttr The result will contain all default properties plus the selected CustomProperty_WebName and CalculatedAttribute_ExampleAttr."
  },
  "domain-api/querying-data/url-components.html": {
    "href": "domain-api/querying-data/url-components.html",
    "title": "URL components of an OData query | ERP.net Developer Docs",
    "summary": "URL components of an OData query https://demodb.my.erp.net/api/domain/odata/General_Products_Products?$top=10&$orderby=Name \\_________________________________________/\\_______________________/ \\___________________/ | | | service root URL resource path query options Service Root URL - this is the address of the API + /domain/odata/ Resource Path - The requested entity Query Options - optional query options NOTES: The address of the API is usually and by default: https://<<Instance_Name>>.my.erp.net/api/ However, this is not certain. Each site in ERP.net can have its own address, which is configurable. For example, this is also valid address: https://erpapi.example.com/ The ERP.net API Resource Path supports only specifying a single entity. REST style sub-entities are not supported. However, the API allows many other ways to expand into sub-entities. Query Options Allow the user to specify optional Query Options. For more information, visit the OData standards page: http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_URLComponents"
  },
  "domain-api/samples/build-ecommerce-website.html": {
    "href": "domain-api/samples/build-ecommerce-website.html",
    "title": "Build E-Commerce Website | ERP.net Developer Docs",
    "summary": "Build E-Commerce Website"
  },
  "domain-api/samples/build-payment-connector.html": {
    "href": "domain-api/samples/build-payment-connector.html",
    "title": "Build Payment Connector | ERP.net Developer Docs",
    "summary": "Build Payment Connector The Payment Connector sample demonstrates connecting ERP.net with Stripe. The app demonstrates simplified workflow: Internal user logins interactively. The most recent 10 payment orders, accessible by the user, are displayed. The user chooses a payment order. The selected payment order is exported to a demo Stripe account. After a demo payment is made, the app creates a Payment Transaction with the payment details. The app includes the following basic tasks: Register UI app. Login interactive. List Payment Orders. Create Payment Transaction. The app is written entirely in JavaScript and hosted in GitHub Pages. You can access the app source project here. To run the application, click here. You can use admin/123 for internal user logon."
  },
  "domain-api/samples/dotnet-service-app.html": {
    "href": "domain-api/samples/dotnet-service-app.html",
    "title": "Dot Net Service Application | ERP.net Developer Docs",
    "summary": "Dot Net Service Application This app demonstrates a Service Application created in .net. Register Trusted Application See source in GitHub"
  },
  "domain-api/samples/dotnet-web-app.html": {
    "href": "domain-api/samples/dotnet-web-app.html",
    "title": "Dot Net Web Application | ERP.net Developer Docs",
    "summary": "Dot Net Web Application Register Trusted Application See source in GitHub"
  },
  "domain-api/samples/javascript-client.html": {
    "href": "domain-api/samples/javascript-client.html",
    "title": "Javascript Interactive Client | ERP.net Developer Docs",
    "summary": "Javascript Interactive Client Register Public Trusted Application See source in GitHub For more detailed tutorial for authentication, see https://identityserver4.readthedocs.io/en/latest/quickstarts/4_javascript_client.html"
  },
  "domain-api/samples/php-interactive-client.html": {
    "href": "domain-api/samples/php-interactive-client.html",
    "title": "PHP Interactive Web Application | ERP.net Developer Docs",
    "summary": "PHP Interactive Web Application Register Confidential Trusted Application See source in GitHub"
  },
  "domain-api/samples/php-service-client.html": {
    "href": "domain-api/samples/php-service-client.html",
    "title": "PHP Service Application | ERP.net Developer Docs",
    "summary": "PHP Service Application Register Service Trusted Application See source in GitHub"
  },
  "domain-api/samples/src/dotnet/ErpNetDemoClient/wwwroot/lib/jquery-validation/LICENSE.html": {
    "href": "domain-api/samples/src/dotnet/ErpNetDemoClient/wwwroot/lib/jquery-validation/LICENSE.html",
    "title": "The MIT License (MIT) | ERP.net Developer Docs",
    "summary": "The MIT License (MIT) Copyright Jörn Zaefferer Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "domain-api/samples/step-by-step/basic-acquire-access-token.html": {
    "href": "domain-api/samples/step-by-step/basic-acquire-access-token.html",
    "title": "Basic example of acquiring an access token | ERP.net Developer Docs",
    "summary": "Basic example of acquiring an access token Objective Your external application just wants to acquire an access token so can access the Domain API. As short as possible. Or, Your external app is a service application. It will be authenticated and authorized via an internal user. Your external app won't provide UI and/or interaction with external users, so it's also a condfidential application. There will be no interaction, so your external app will use client credentials authorization flow. Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app Frankly, this value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app/first This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true SystemUserAllowed true You need this, because your external app will be logged as a service. SystemUser <an-internal-erp-user> The user, which will be used when the application logins as a service. ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ClientType Confidential Your external app is a service. I.e., it can keep a secret securely. ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. It's used in the process of authentication. All other attributes can have their default values. They are not covered by this example. Steps You just need to call a pretty simple HTTP request. POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app/first& client_secret=<my_plain_app_secret>& grant_type=client_credentials& scope=DomainApi Yes, it's that simple. Here are some clarifications: The POST request is sent to the identity server's token endpoint directly. The body of the request: client_id - your trusted app's application uri. client_secret - the plain secret phrase of the trusted app. grant_type - the way your app will get an access token. scope - what's needed to access. Note With the client_credentials flow (i.e., ERP.net service application), the scope argument can be omitted. Then your access token will contain all scopes, defined in the trusted application. If everything is correct, you'll receive a similar response: { \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTQwNzU1MjksImV4cCI6MTY1NDA3OTEyOSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsImNsaWVudF9zeXN0ZW1fdXNlciI6InAua29zdG92QGVycC5iZyIsImNsaWVudF9kYiI6IkUxX0RFViIsImp0aSI6IlNob3JjNVJ2MTM2ak5POHRCMF9yRHciLCJzY29wZSI6WyJEb21haW5BcGkiLCJzZWMiLCJ1cGRhdGUiXX0.RPzYKl9xPvFcLa0O8yqzJCJtmZUS88iDeWBFa9pyvYdzfQ18E4W8w6CLJPf9whFFiJWhgAsOASVuz98-MIgj9VwTjNtXMdMAPvZC0HYPnMusYUxxYRNejjqtPG7n4V0LVzyWYHu99-YUipFBmzXxCywR8TtaBv374CKfLdS4M1vaMMYShzD22L_R3kKc3uZhQ5Ygpci1tuNC8gC6CoXIv0a9gjthwgshCzmbEmiNhjvJ7WDZ98gnzkvl5_wLANRrDYUcLPvq04OfVRn2uS-dF-NLIeO5dr7Mn905YodY4Mngr4S5WbBvrWAt0hRLO6Oy_X2KCcQdmh0Nq73ELruoBw\", \"expires_in\": 3600, \"token_type\": \"Bearer\", \"scope\": \"DomainApi\" } As you can see, you now have an access token (access_token), expiring in an hour (expires_in). Now this token could be used for your Domain API requests. E.g, GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTQwNzU1MjksImV4cCI6MTY1NDA3OTEyOSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsImNsaWVudF9zeXN0ZW1fdXNlciI6InAua29zdG92QGVycC5iZyIsImNsaWVudF9kYiI6IkUxX0RFViIsImp0aSI6IlNob3JjNVJ2MTM2ak5POHRCMF9yRHciLCJzY29wZSI6WyJEb21haW5BcGkiLCJzZWMiLCJ1cGRhdGUiXX0.RPzYKl9xPvFcLa0O8yqzJCJtmZUS88iDeWBFa9pyvYdzfQ18E4W8w6CLJPf9whFFiJWhgAsOASVuz98-MIgj9VwTjNtXMdMAPvZC0HYPnMusYUxxYRNejjqtPG7n4V0LVzyWYHu99-YUipFBmzXxCywR8TtaBv374CKfLdS4M1vaMMYShzD22L_R3kKc3uZhQ5Ygpci1tuNC8gC6CoXIv0a9gjthwgshCzmbEmiNhjvJ7WDZ98gnzkvl5_wLANRrDYUcLPvq04OfVRn2uS-dF-NLIeO5dr7Mn905YodY4Mngr4S5WbBvrWAt0hRLO6Oy_X2KCcQdmh0Nq73ELruoBw"
  },
  "domain-api/samples/step-by-step/basic-exchange-auth-code-access-token.html": {
    "href": "domain-api/samples/step-by-step/basic-exchange-auth-code-access-token.html",
    "title": "Basic example- exchange an auth code for an access token | ERP.net Developer Docs",
    "summary": "Basic example- exchange an auth code for an access token Objective You have an external application that requires user login. You want to acquire an access token on behalf of the logged user. As short as possible. Or, Your external app is an interactive application (at least for the user to log in). It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal user). Your external application will access the ERP.net instance on behalf of the logged user. Will work with ERP.net internal users and it's able to keep a secret, so it's also a condfidential application. There'll be user interaction (because of the login), so your external app will use authorization code flow. Remarks This example doesn't show a specific implementiation, but the required steps you need to perform. You can find more information about specific implementations in the Resources section. The main difference with the Basic example of acquiring an access token is that there's an additional step, which is a subject of a specific technical implementation. I.e., Your external app performs an HTTP GET request to the authorize endpoint. Wait for the Identity Server to: Redirect to the ERP.net login page. \"Make\" an HTTP request to your external app, after the user logs in successfully. Now your external app can make an HTTP POST request to the token endpoint. The Identity Server creates an access token and and returns it to you. As you can see, the extra steps, compared to the other example, are (1) and (2). I.e., You have to provide a way to visualize the ERP.net login page (the usual way is via a web browser). Also a mechanism to handle a HTTP request. Actually, this is the essential difference between client_credentials flow and the authorization code flow. The first is bound to a specific, so-called service user while the other- to the user who will log in via the login form of the Identity Provider (i.e., the ERP.net Identity Server). Note It's important to clarify the following quote above, (2.2) \"Make\" an HTTP request to your external app, after the user logs in successfully., referring the ERP.net Identity Server. The HTTP request to your external app (i.e. the redirect) is made locally, as a result from your request to the authorize endpoint. In general, this means that your external app doesn't need to be accessible outside of the network where it's avaialble. So said, if your app is a \"pure\" local one, external callbacks such as localhost/signin-callback, 192.168.10.55/signin-callback are completely fine. Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app/first This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateLoginUrl http://localhost/signin-callback The url where your external app is listening. Redirection to this uri will be performed after the user logs in successfully. ClientType Confidential Your external app \"will work\" with internal users only, so there'll be no \"public\" acccess. We can assume that it can keep a secret securely (in fact, it's a must). ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. All other attributes can have their default values. They are not covered by this example. Steps Authorize endpoint You just need to call a simple GET request. GET /id/connect/authorize? client_id=my.trusted.app/first& redirect_uri=http://localhost/signin-callback& response_type=code id_token& scope=openid profile offline_access DomainApi& nonce=abc& state=dkZmYxMzE2 HTTP/1.1 Host: demodb.my.erp.net If everything is OK, the following will happen: A redirect to the ERP.net login page will be made. After the user logs in successfully, a redirect back to your external app will be performed. Sign in callback The previous step leads here. You'll receive a GET request such as: GET /signin-callback? code=g0ZGZmNjVmOWI& state=dkZmYxMzE2 HTTP/1.1 Host: localhost Where the code in the uri query is your authorization code. Now you're ready to exchange this authorization code for an access token. Token endpoint Once you have the authorization code, obtaining the access token is pretty easy. Just make the following POST request. POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app/first& client_secret=<my_plain_app_secret>& grant_type=authorization_code& code=g0ZGZmNjVmOWI& redirect_uri=http://localhost/signin-callback That's all. You'll receive something like this: { \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA1ODAyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJwayIsIm5vbmNlIjoiYWJjIiwiaWF0IjoxNjU1MDU3NzI0LCJhdF9oYXNoIjoibUhfSUZEUVppRHdZb2h5a0FZR2NJZyIsInNfaGFzaCI6IlRjMWtiNVB1U2lheEN2NXVJZHZ6ZlEiLCJzaWQiOiJ1Q3FiZkI4OHpYMXUzOW40NERwVjFRIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE2NTUwMjc3MTksImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.CzTk7SXiqcgpjVXCvdgDKJ92bt2a93R76l5WmCIZ6hMG6VDYHXlkBlqmG15l8Zsc1SpLn949f-OQn4nK1LaLkOA1rrMfT6lhMdrdBkQED7mYrjTyRqUJHnkriYpLsbL4Ze5gOP1M0HlDi6ZWjhZyzJgEyqi_T44lmlyZc0ujQ0Zba-_afXV7VpmgL9dIPwSmhuP14x2UJIGziBE8m23DL4GqTMQYgX0HNGLa2Tgiztp4h9ABBWWhj_iEKJ3ZoZ3CfMVMn53fqDaf9fuIrgYrOOTKqE7UrxH2bhdLUlaqka7KeGIsRd7f6wV2XqFDfY3vtW85CzQnjuGhj-qAJoZjCw\", \"access_token\": \"eycccGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA2MTMyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNjU1MDI3NzE5LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IlNQUyIsImVtYWlsIjoiYWRtaW5AbWFpbC5jb20iLCJ1c2VyX3R5cGUiOiJJbnRlcm5hbFVzZXIiLCJpc19hZG1pbi1ee6InRydWUiLCJlbWFpbF92ZXJpZmllZCI6ImZhb2NlIiwiZGIiOiJFMV9ERVYiLCJsb2NhbGUiOiJieyIsImp0aSI6Il9sdEJMS3djSlNLbUFhM25mbFpwNFEiLCJzaWQiOiJ1Q3FiZds2898pYMXUzOW40NqRwVjFRIiwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsIww1kRvbWFpbkFwaSIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AzHxj_iBM3bfcOtdaSNHNbPUHGCf0JAo7fV1fo9JT-rqCHjc0t8VEa1qO5R2jemvs7vDBf6GARxgul3pAy7YQpmqzzruswoLDkDdUMX1LXzHLgp0ppYoNa1A_M_O4UTXCe7xGBRHSyRRQLGsTTGMkv1pK0E3Xn3rAfOPvo4wfrQ8QabVcdA7mupY4qF01tIHPv_7NGS2SyPfCVdAYcxUy8HpQ-RdoXMaVWVz_JhXgMNZ9_nFTxedPGakZJMDjnvYss_GKjucbeYdZM9jSrqEmXDw6s8A3o1jKOyurzIBzug55Dxee8UBWepcO5S08GPguBFotamUvStMdDY0KkmZYvw\", \"expires_in\": 3600, \"refresh_token\": \"6-Cv7vQ5ouhYzs0AWg6tsG-YK7O5xP_kb5Qb8wEJMnw\", \"scope\": \"openid profile DomainApi offline_access\" } Authorized Domain API call Now you're authorized and we can make a legitimate call to the ERP.net Domain Api. E.g., GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net Authorization: Bearer eycccGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA2MTMyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNjU1MDI3NzE5LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IlNQUyIsImVtYWlsIjoiYWRtaW5AbWFpbC5jb20iLCJ1c2VyX3R5cGUiOiJJbnRlcm5hbFVzZXIiLCJpc19hZG1pbi1ee6InRydWUiLCJlbWFpbF92ZXJpZmllZCI6ImZhb2NlIiwiZGIiOiJFMV9ERVYiLCJsb2NhbGUiOiJieyIsImp0aSI6Il9sdEJMS3djSlNLbUFhM25mbFpwNFEiLCJzaWQiOiJ1Q3FiZds2898pYMXUzOW40NqRwVjFRIiwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsIww1kRvbWFpbkFwaSIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AzHxj_iBM3bfcOtdaSNHNbPUHGCf0JAo7fV1fo9JT-rqCHjc0t8VEa1qO5R2jemvs7vDBf6GARxgul3pAy7YQpmqzzruswoLDkDdUMX1LXzHLgp0ppYoNa1A_M_O4UTXCe7xGBRHSyRRQLGsTTGMkv1pK0E3Xn3rAfOPvo4wfrQ8QabVcdA7mupY4qF01tIHPv_7NGS2SyPfCVdAYcxUy8HpQ-RdoXMaVWVz_JhXgMNZ9_nFTxedPGakZJMDjnvYss_GKjucbeYdZM9jSrqEmXDw6s8A3o1jKOyurzIBzug55Dxee8UBWepcO5S08GPguBFotamUvStMdDY0KkmZYvw Resources Authorization code flow with a web based external application Authorization code flow with a console based external application -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "domain-api/samples/step-by-step/basic-renew-access-token.html": {
    "href": "domain-api/samples/step-by-step/basic-renew-access-token.html",
    "title": "Basic example- renew an access token via a refresh token | ERP.net Developer Docs",
    "summary": "Basic example- renew an access token via a refresh token Objective You have an external application that requires user login. You want to acquire an access token on behalf of the logged user. Because the access token has a validity of 1 hour, you want to renew it, instead of forcing the user to log in again. Or, Your external app is an interactive application (at least for the user to log in). It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal user). Your external application will access the ERP.net instance on behalf of the logged user. Will work with ERP.net internal users and it's able to keep a secret, so it's also a condfidential application. There'll be user interaction (because of the login), so your external app will use authorization code flow. Aditionally, you want to renew the access token when it expires, instead of forcing the user to login in. Remarks This example uses as a basis the following one: Basic example- exchange an auth code for an access token. The reason for this is simple. The referened example already shows how an access token is obtained, along with a refresh token. In fact, it's more accurate to say- your first access token with its corresponding refresh token. Your \"first\" access token, because it will change when you renew it (i.e., you'll obtain a new one). Note Refreshing the access token only makes sense in the authorization code flow. This will help the user by not having to enter their credentials each time their access token expires. In flows such as client_credentials refreshing an access token is pointless, because you can always obtain a new one with a single request, directly to the token endpoint. Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app/first This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateLoginUrl http://localhost/signin-callback The url where your external app is listening. Redirection to this uri will be performed after the user logs in successfully. ClientType Confidential Your external app \"will work\" with internal users only, so there'll be no \"public\" acccess. We can assume that it can keep a secret securely (in fact, it's a must). ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. All other attributes can have their default values. They are not covered by this example. Steps Authorize endpoint You just need to call a simple GET request. GET /id/connect/authorize? client_id=my.trusted.app/first& redirect_uri=http://localhost/signin-callback& response_type=code id_token& scope=openid profile offline_access DomainApi& nonce=abc& state=xyz HTTP/1.1 Host: demodb.my.erp.net If everything is OK, the following will happen: A redirect to the ERP.net login page will be made. After the user logs in successfully, a redirect back to your external app will be performed. Sign in callback The previous step leads here. You'll receive a GET request such as: GET /signin-callback? code=g0ZGZmNjVmOWI& state=dkZmYxMzE2 HTTP/1.1 Host: localhost Where the code in the uri query is your authorization code. Now you're ready to exchange this authorization code for an access token. Token endpoint Once you have the authorization code, obtaining the access token is pretty easy. Just make the following POST request. POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app/first& client_secret=<my_plain_app_secret>& grant_type=authorization_code& code=g0ZGZmNjVmOWI& redirect_uri=http://localhost/signin-callback That's all. You'll receive something like this: { \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA1ODAyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJwayIsIm5vbmNlIjoiYWJjIiwiaWF0IjoxNjU1MDU3NzI0LCJhdF9oYXNoIjoibUhfSUZEUVppRHdZb2h5a0FZR2NJZyIsInNfaGFzaCI6IlRjMWtiNVB1U2lheEN2NXVJZHZ6ZlEiLCJzaWQiOiJ1Q3FiZkI4OHpYMXUzOW40NERwVjFRIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE2NTUwMjc3MTksImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.CzTk7SXiqcgpjVXCvdgDKJ92bt2a93R76l5WmCIZ6hMG6VDYHXlkBlqmG15l8Zsc1SpLn949f-OQn4nK1LaLkOA1rrMfT6lhMdrdBkQED7mYrjTyRqUJHnkriYpLsbL4Ze5gOP1M0HlDi6ZWjhZyzJgEyqi_T44lmlyZc0ujQ0Zba-_afXV7VpmgL9dIPwSmhuP14x2UJIGziBE8m23DL4GqTMQYgX0HNGLa2Tgiztp4h9ABBWWhj_iEKJ3ZoZ3CfMVMn53fqDaf9fuIrgYrOOTKqE7UrxH2bhdLUlaqka7KeGIsRd7f6wV2XqFDfY3vtW85CzQnjuGhj-qAJoZjCw\", \"access_token\": \"eycccGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA2MTMyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNjU1MDI3NzE5LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IlNQUyIsImVtYWlsIjoiYWRtaW5AbWFpbC5jb20iLCJ1c2VyX3R5cGUiOiJJbnRlcm5hbFVzZXIiLCJpc19hZG1pbi1ee6InRydWUiLCJlbWFpbF92ZXJpZmllZCI6ImZhb2NlIiwiZGIiOiJFMV9ERVYiLCJsb2NhbGUiOiJieyIsImp0aSI6Il9sdEJMS3djSlNLbUFhM25mbFpwNFEiLCJzaWQiOiJ1Q3FiZds2898pYMXUzOW40NqRwVjFRIiwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsIww1kRvbWFpbkFwaSIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AzHxj_iBM3bfcOtdaSNHNbPUHGCf0JAo7fV1fo9JT-rqCHjc0t8VEa1qO5R2jemvs7vDBf6GARxgul3pAy7YQpmqzzruswoLDkDdUMX1LXzHLgp0ppYoNa1A_M_O4UTXCe7xGBRHSyRRQLGsTTGMkv1pK0E3Xn3rAfOPvo4wfrQ8QabVcdA7mupY4qF01tIHPv_7NGS2SyPfCVdAYcxUy8HpQ-RdoXMaVWVz_JhXgMNZ9_nFTxedPGakZJMDjnvYss_GKjucbeYdZM9jSrqEmXDw6s8A3o1jKOyurzIBzug55Dxee8UBWepcO5S08GPguBFotamUvStMdDY0KkmZYvw\", \"expires_in\": 3600, \"refresh_token\": \"6-Cv7vQ5ouhYzs0AWg6tsG-YK7O5xP_kb5Qb8wEJMnw\", \"scope\": \"openid profile DomainApi offline_access\" } As you see, the result contains the following: Your first access token. When it will expire (in seconds). The corresponding refresh token. Authorized Domain API call Now you're authorized and we can make a legitimate call to the ERP.net Domain Api. E.g., GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net Authorization: Bearer eycccGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA2MTMyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNjU1MDI3NzE5LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IlNQUyIsImVtYWlsIjoiYWRtaW5AbWFpbC5jb20iLCJ1c2VyX3R5cGUiOiJJbnRlcm5hbFVzZXIiLCJpc19hZG1pbi1ee6InRydWUiLCJlbWFpbF92ZXJpZmllZCI6ImZhb2NlIiwiZGIiOiJFMV9ERVYiLCJsb2NhbGUiOiJieyIsImp0aSI6Il9sdEJMS3djSlNLbUFhM25mbFpwNFEiLCJzaWQiOiJ1Q3FiZds2898pYMXUzOW40NqRwVjFRIiwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsIww1kRvbWFpbkFwaSIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AzHxj_iBM3bfcOtdaSNHNbPUHGCf0JAo7fV1fo9JT-rqCHjc0t8VEa1qO5R2jemvs7vDBf6GARxgul3pAy7YQpmqzzruswoLDkDdUMX1LXzHLgp0ppYoNa1A_M_O4UTXCe7xGBRHSyRRQLGsTTGMkv1pK0E3Xn3rAfOPvo4wfrQ8QabVcdA7mupY4qF01tIHPv_7NGS2SyPfCVdAYcxUy8HpQ-RdoXMaVWVz_JhXgMNZ9_nFTxedPGakZJMDjnvYss_GKjucbeYdZM9jSrqEmXDw6s8A3o1jKOyurzIBzug55Dxee8UBWepcO5S08GPguBFotamUvStMdDY0KkmZYvw Access token renewal When your access token expires, all requests will begin to return HTTP 401 - Unauthorized. So, now's the time to renew your access token. You can do it via the token endpoint, this way: POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app/first& client_secret=<my_plain_app_secret>& grant_type=refresh_token& refresh_token=6-Cv7vQ5ouhYzs0AWg6tsG-YK7O5xP_kb5Qb8wEJMnw Done. If everything is correct, you'll get a response like this: { \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA1ODAyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJwayIsIm5vbmNlIjoiYWJjIiwiaWF0IjoxNjU1MDU3NzI0LCJhdF9oYXNoIjoibUhfSUZEUVppRHdZb2h5a0FZR2NJZyIsInNfaGFzaCI6IlRjMWtiNVB1U2lheEN2NXVJZHZ6ZlEiLCJzaWQiOiJ1Q3FiZkI4OHpYMXUzOW40NERwVjFRIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE2NTUwMjc3MTksImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.CzTk7SXiqcgpjVXCvdgDKJ92bt2a93R76l5WmCIZ6hMG6VDYHXlkBlqmG15l8Zsc1SpLn949f-OQn4nK1LaLkOA1rrMfT6lhMdrdBkQED7mYrjTyRqUJHnkriYpLsbL4Ze5gOP1M0HlDi6ZWjhZyzJgEyqi_T44lmlyZc0ujQ0Zba-_afXV7VpmgL9dIPwSmhuP14x2UJIGziBE8m23DL4GqTMQYgX0HNGLa2Tgiztp4h9ABBWWhj_iEKJ3ZoZ3CfMVMn53fqDaf9fuIrgYrOOTKqE7UrxH2bhdLUlaqka7KeGIsRd7f6wV2XqFDfY3vtW85CzQnjuGhj-qAJoZjCw\", \"access_token\": \"eyJhbGciOiJIUzI1NiJ9.eyJuYmYiOjE2NTU2NTM3MTYsImV4cCI6MTY1NTY1NzMxNiwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOlsiRG9tYWluQXBpIiwidXBkYXRlIl0sImNsaWVudF9pZCI6InBrIiwiY2xpZW50X2RiIjoiRTFfREVWIiwianRpIjoiT0pycTFjX1owNzBUbHZJVTVoUlhFZyIsInNjb3BlIjpbIkRvbWFpbkFwaSIsInVwZGF0ZSJdfQ.syDIwziTNy1m2XNSSKD_E8wScuuuS2ZENzaxdd9ClOU\", \"expires_in\": 3600, \"refresh_token\": \"SvQvQ9cxcYzs0AWg6tsGW1-YK7O5xP_k98868wEEMjr\", \"scope\": \"openid profile DomainApi offline_access\" } A new pair of access and refresh tokens. You should use them now. If you've noticed, refreshing the access token is the same as getting it the first time. The only difference is, grant_type=authorization_code&code=xxx to initially obtain the access token. grant_type=refresh_token&refresh_token=xxx when you want to acquire a new one - i.e., to refresh it. Resources Basic example- exchange an auth code for an access token Authorization code flow with a web based external application Authorization code flow with a console based external application -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "domain-api/samples/step-by-step/console-app-access-token-auth-code.html": {
    "href": "domain-api/samples/step-by-step/console-app-access-token-auth-code.html",
    "title": "Access token via authorization code flow in a console app | ERP.net Developer Docs",
    "summary": "Access token via authorization code flow in a console app Objective You have an external application that will be authorized via the ERP.net login form on behalf of an internal user. The application MAY or MAY NOT provide an UI, but there'll be user interaction at least for the initial login. Or, Your external app is an interactive application. It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal user). Your external application will access the ERP.net instance on behalf of the logged user. Your external app MAY provide UI. It's able to keep a secret, so it's also a condfidential application. There'll be user interaction (at least for the internal user to log in), so your external app will use authorization code flow. The whole process in a nutshell Note This example uses Windows console application, which is why some points further require a deeper understanding. It's highly recommended, if you haven't done so, that you read the following topic first, Access token via authorization code flow in a web app After all, your final goal is to acquire an access token. The process is very similar to this example Basic example of acquiring an access token, but here is added another intermediate step - the process of impersonating a user. Here's a summary of how the whole process goes: Your external app will open the so called authorize endpoint with your trusted app details (the trusted app, corresponding to your external app). Note An important detail is that the authorize endpoint must be opened in a browser (see next point and its note). If all's OK, the browser will be redirected to the ERP.net login page, where the user will enter their credentials. Note Because of the redirect, initially the step (1) have to be performed in a browser. If your external app is web-based, you don't have to do anything (because it will work in a browser anyway). If your external app is NOT web-based, you have to handle this process by yourself (the example below is just like that). If the user logs in successfully, the ERP.net login page (i.e. ERP.net Identity Server) will be redirect to a uri where your external app is listening. There you'll receive an authorization code. Finally you'll exchange the auth code for an access token at the token endpoint. You'll obtain an access token on behalf of the logged user (2). Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app/first This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateLoginUrl http://localhost/signin-callback/ The url where your external app is listening. Redirection to this uri will be performed after the user logs in successfully (see step 3 in the section above). ClientType Confidential Your external app \"will work\" with internal users only, so there'll be no \"public\" acccess. We can assume that it can keep a secret securely (in fact, it's a must). ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. All other attributes can have their default values. They are not covered by this example. Steps Unlike the Basic example of acquiring an access token, where everything is clear enough to describe with simple HTTP requests, here the examples are shown in the context of a simple C# console application (i.e. an external app). Initialization First we'll declare and initialize some constants and variables which we'll use later. const string AuthorizeUri = \"https://demodb.my.erp.net/id/connect/authorize\"; const string TokenUri = \"https://demodb.my.erp.net/id/connect/token\"; const string CallbackUri = \"http://localhost/signin-callback/\"; const string TrustedAppUri = \"my.trusted.app/first\"; const string TrustedAppSecret = \"<my_plain_app_secret>\"; const string DomainApiTestUri = \"https://demodb.my.erp.net/api/domain/odata/Crm_Customers?$top=10\"; We won't waste time, explaining about the constants, their names are self-explanatory. The next two variables are a little more interesting, string authCode = string.Empty; string authState = Guid.NewGuid().ToString(); ClientAuthData clientData; The authCode keeps the authorization code you'll receive after the internal user logs in successfully. So, initially will be an empty string. The authState is a random string, used for security purpose. You'll pass it to the authorize endpoint and the Identity Server will return it back to your CallbackUri uri (as you can guess, you need to compare them- if they differ, it's most likely a malicious attempt). The last variable clientData will help us, holding the client (i.e. internal user) auth data such as access token, scopes, access token expiration, etc. Here's what the ClientAuthData type looks like: public struct ClientAuthData { [JsonPropertyName(\"id_token\")] public string IdToken { get; set; } [JsonPropertyName(\"access_token\")] public string AccessToken { get; set; } [JsonPropertyName(\"expires_in\")] public int ExpiresIn { get; set; } [JsonPropertyName(\"refresh_token\")] public string RefreshToken { get; set; } [JsonPropertyName(\"scope\")] public string Scope { get; set; } } Because we'll receive this data as a raw json string, the JsonPropertyName attribute will help us deserialize it with a \"one-liner\". HTTP server (a.k.a. the callback listener) This is also part of the initialization, but it's an essential part of the whole process. That's why we condider it separately. Note If your external application is web-based, you don't need this step, because you already \"have\" a web server. You just have to handle the CallbackUri as an additional page, route, etc. var httpListener = new HttpListener(); httpListener.Prefixes.Add(CallbackUri); httpListener.Start(); We're creating an object of type HttpListener (that's the HttpListener Class, based on HTTP.sys). After, we are adding our CallbackUri (as a place where we'll \"listen\") and we just start the server. The server is started, but we have to handle when the CallbackUri is requested. Because we're listening on just one uri, the following code is enough: var signCallbackTask = httpListener .GetContextAsync() .ContinueWith(HandleSignInCallback); GetContextAsync() waits for an incoming request, but as an asynchronous operation. After, ContinueWith() will proceed when the task is completed (i.e. an incoming request is made). There our delegate HandleSignInCallback will be passed the completed task. The HandleSignInCallback implementation is below. Note It doesn't matter what the http server is. Here we're using the HTTP.sys implementation only because it's super simple to initialize. Warning HTTP.sys is Windows based web server. This code won't work on non-win OS. Also the process of \"adding a prefix\", requires elevated permissions to work, so you have to start this example as an administrator. Authorize endpoint Now this is the first step towards the essentials- you'll request an authorize code. This is done by submitting a GET request to the authorize endpoint. Here're the needed request parameters: var authorizeUriArgs = $\"client_id={TrustedAppUri}&\" + $\"redirect_uri={CallbackUri}&\" + \"response_type=code id_token&\" + \"response_mode=form_post&\" + \"scope=openid profile offline_access DomainApi&\" + \"nonce=abc&\" + $\"state={authState}\"; As you see, you're passing the following: The uri of your trusted app TrustedAppUri. The CallbackUri - the uri where you're waiting for the callback, when the user signs in. The scopes your external app needs. The authState, described at the beginning. In addition, there are two other important arguments: response_type=code id_token. This \"instructs\" the Identity Server to send you a code (i.e. authorization code) and an identity token (not discussed in this topic). response_mode=form_post. This \"tells\" the Identity Server that you are expecting the callback request as an HTTP POST request. Our request args are prepared, so we just have to execute the GET request (i.e. the authorize endpoint). // Start the authorize endpoint with your default browser. // This way you'll be able to enter your credentials. var processStartInfo = new ProcessStartInfo(\"cmd\", $\"/c start {AuthorizeUri}?{authorizeUriArgs.Replace(\"&\", \"^&\").Replace(\" \", \"%20\")}\") { CreateNoWindow = true }; Process.Start(processStartInfo); This is Windows based code that will open the GET request via the windows command shell. This is necessary, because as described above, if the request is successful, a redirect to the ERP.net login page will be made. Because our example external app is console application (i.e. we can't easily handle such a redirect, nor can we visualize the login page itself), so we'll just make the request with our default browser. In the meantime we'll wait the signin callback to trigger. // Wait until the redirect is made. signCallbackTask.Wait(); In other words, we're blocking our external app here, until the sign in callback is called. More precisely our HandleSignInCallback function completes after the the callback is called. Sign in callback And here's how we handle the callback: void HandleSignInCallback(Task<HttpListenerContext> httpListenerContextTask) { var body = new Dictionary<string, string>(); using (var streamReader = new StreamReader(httpContext.Request.InputStream)) { body = streamReader.ReadToEnd() .Split('&') .Select(v => v.Split('=')) .ToDictionary(pair => pair[0], pair => pair[1]); } if (!body.Any()) throw new Exception(\"empty body :(\"); if (body[\"state\"] != authState) throw new Exception(\"The returned state differs from the one we've passed.\"); authCode = body[\"code\"]; if (string.IsNullOrEmpty(authCode)) throw new Exception(\"No or invalid authorization code.\"); } Only the essential part of the function's body is shown (the full code is available below) In short, you process a simple POST request, in which you're interested in only two parameters, part of its body. The state - it must be equal to our authState, passed to the authorize endpoint. The code - this is our authorization code. Token endpoint Now when you have an authorization code, you can easily acquire an access token. For this to happen, you need to make a POST request to the token endpoint (i.e. TokenUri). But first you need to prepare the body of the POST request. Here's how: var tokenUriBody = $\"client_id={TrustedAppUri}&\" + $\"client_secret={TrustedAppSecret}&\" + \"grant_type=authorization_code&\" + $\"code={authCode}&\" + $\"redirect_uri={CallbackUri}\"; As you can see, it's quite simple. You're passing the following: Your trusted app uri and its secret TrustedAppUri, TrustedAppSecret. The authorization code you received in the previous step authCode. The CallbackUri. And the very important one grant_type=authroization_code - this is the moment when you \"tell\" the Identity Server that you'll use the authorization code flow. Then just send it and make sure that the returned http status code is a successful one: httpRequest = new HttpRequestMessage() { Method = HttpMethod.Post, RequestUri = new Uri(TokenUri), Content = new StringContent( tokenUriBody, Encoding.UTF8, \"application/x-www-form-urlencoded\") }; httpResponse = httpClient.Send(httpRequest); // This will throw if the returned status code is not 2xx. httpResponse.EnsureSuccessStatusCode(); Finally, you have our access token. It's in the response: // Deserialize the JSON response as a ClientAuthData struct. clientData = JsonSerializer.Deserialize<ClientAuthData>(httpResponse.Content.ReadAsStream()); Console.WriteLine($\"Access token: {clientData.AccessToken}\"); Console.WriteLine($\"Refresh token: {clientData.RefreshToken}\"); Authorized Domain API call Now you're authorized and you can make a legitimate call to the ERP.net Domain Api. E.g. httpRequest = new HttpRequestMessage() { Method = HttpMethod.Get, RequestUri = new Uri(DomainApiTestUri) }; httpRequest.Headers.Add(\"Authorization\", $\"Bearer {clientData.AccessToken}\"); httpResponse = httpClient.Send(httpRequest); The response will contain the result of the query. Everything together using System.Diagnostics; using System.Net; using System.Text; using System.Text.Json; using System.Text.Json.Serialization; const string AuthorizeUri = \"https://demodb.my.erp.net/id/connect/authorize\"; const string TokenUri = \"https://demodb.my.erp.net/id/connect/token\"; const string CallbackUri = \"http://localhost/signin-callback/\"; const string DomainApiTestUri = \"https://demodb.my.erp.net/api/domain/odata/Crm_Customers?$top=10\"; const string TrustedAppUri = \"my.trusted.app/first\"; const string TrustedAppSecret = \"<my_plain_app_secret>\"; string authCode = string.Empty; string authState = Guid.NewGuid().ToString(); ClientAuthData clientData; var httpListener = new HttpListener(); httpListener.Prefixes.Add(CallbackUri); httpListener.Start(); var signCallbackTask = httpListener.GetContextAsync().ContinueWith(HandleSignInCallback); var authorizeUriArgs = $\"client_id={TrustedAppUri}&\" + $\"redirect_uri={CallbackUri}&\" + \"response_type=code%20id_token&\" + \"response_mode=form_post&\" + \"scope=openid%20profile%20offline_access%20DomainApi&\" + \"nonce=abc&\" + $\"state={authState}\"; // Start the authorize endpoint with your default browser. // This way you'll be able to enter your credentials. var processStartInfo = new ProcessStartInfo(\"cmd\", $\"/c start {AuthorizeUri}?{authorizeUriArgs.Replace(\"&\", \"^&\").Replace(\" \", \"%20\")}\") { CreateNoWindow = true }; Process.Start(processStartInfo); // Wait until the redirect is made. signCallbackTask.Wait(); try { #region Create an http client and request/response message objects. var handler = new HttpClientHandler { ClientCertificateOptions = ClientCertificateOption.Manual, ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) => { return true; } }; var httpClient = new HttpClient(handler); HttpRequestMessage? httpRequest = null; HttpResponseMessage? httpResponse = null; #endregion #region Acquire an access token. var tokenUriBody = $\"client_id={TrustedAppUri}&\" + $\"client_secret={TrustedAppSecret}&\" + \"grant_type=authorization_code&\" + $\"code={authCode}&\" + $\"redirect_uri={CallbackUri}\"; httpRequest = new HttpRequestMessage() { Method = HttpMethod.Post, RequestUri = new Uri(TokenUri), Content = new StringContent( tokenUriBody, Encoding.UTF8, \"application/x-www-form-urlencoded\") }; httpResponse = httpClient.Send(httpRequest); // This will throw if the returned status code is not 2xx. httpResponse.EnsureSuccessStatusCode(); // Deserialize the JSON response as a ClientAuthData struct. clientData = JsonSerializer.Deserialize<ClientAuthData>(httpResponse.Content.ReadAsStream()); Console.WriteLine($\"Access token: {clientData.AccessToken}\"); Console.WriteLine($\"Refresh token: {clientData.RefreshToken}\"); #endregion #region Domain Api call - select top 10 Crm_Customers httpRequest = new HttpRequestMessage() { Method = HttpMethod.Get, RequestUri = new Uri(DomainApiTestUri) }; httpRequest.Headers.Add(\"Authorization\", $\"Bearer {clientData.AccessToken}\"); httpResponse = httpClient.Send(httpRequest); httpResponse.EnsureSuccessStatusCode(); Console.WriteLine(\"=================\"); var domainApiResponse = await httpResponse.Content.ReadAsStringAsync(); Console.WriteLine(domainApiResponse); #endregion } catch (Exception ex) { Console.WriteLine(ex.Message); } void HandleSignInCallback(Task<HttpListenerContext> httpListenerContextTask) { var httpContext = httpListenerContextTask.Result; var logMessage = \"Well done, everything is OK.\\r\\nNow you have an authorization code.\"; try { #region Request an authorization code. var body = new Dictionary<string, string>(); using (var streamReader = new StreamReader(httpContext.Request.InputStream)) { body = streamReader.ReadToEnd() .Split('&') .Select(v => v.Split('=')) .ToDictionary(pair => pair[0], pair => pair[1]); } if (!body.Any()) throw new Exception(\"empty body :(\"); if (body[\"state\"] != authState) throw new Exception(\"The returned state differs from the one we've passed.\"); authCode = body[\"code\"]; if (string.IsNullOrEmpty(authCode)) throw new Exception(\"No or invalid authorization code.\"); #endregion } catch (Exception ex) { logMessage = ex.Message; } byte[] buffer = Encoding.UTF8.GetBytes(logMessage); httpContext.Response.ContentLength64 = buffer.Length; using var output = httpContext.Response.OutputStream; output.Write(buffer, 0, buffer.Length); } public struct ClientAuthData { [JsonPropertyName(\"id_token\")] public string IdToken { get; set; } [JsonPropertyName(\"access_token\")] public string AccessToken { get; set; } [JsonPropertyName(\"expires_in\")] public int ExpiresIn { get; set; } [JsonPropertyName(\"refresh_token\")] public string RefreshToken { get; set; } [JsonPropertyName(\"scope\")] public string Scope { get; set; } } Resources The sample project in this example can be found here: https://github.com/ErpNetDocs/dev/tree/master/domain-api/samples/src/step-by-step/AccessTokenCodeConsole -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "domain-api/samples/step-by-step/index.html": {
    "href": "domain-api/samples/step-by-step/index.html",
    "title": "Step by step guides | ERP.net Developer Docs",
    "summary": "Step by step guides Below you can find step by step examples, grouped by topic. Security Access token via authorization code flow in a SPA (Single Page Application) Access token via authorization code flow in a console app Access token via authorization code flow in a web app Basic example of acquiring an access token Basic example- exchange an auth code for an access token Basic example- renew an access token via a refresh token"
  },
  "domain-api/samples/step-by-step/spa-access-token-auth-code.html": {
    "href": "domain-api/samples/step-by-step/spa-access-token-auth-code.html",
    "title": "Access token via authorization code flow in a SPA (Single Page Application) | ERP.net Developer Docs",
    "summary": "Access token via authorization code flow in a SPA (Single Page Application) Objective You have an external SPA that will be authorized via the ERP.net login form on behalf of an internal or external user. The application WILL provide an UI, so there'll be user interaction. Your application will be a \"pure\" front-end and will run entirely in the client's browser. Or, Your external app is an interactive application. Your external app is a web application. It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal or external user). Your external application will access the ERP.net instance on behalf of the logged user. Your external app WILL provide UI. Will work entirely in a client environment, so it won't be able to keep a secret. I.e., it's a public application (without a secret). There'll be user interaction, so your external app will use authorization code flow. The whole process in a nutshell After all, your final goal is to acquire an access token. The process is very similar to this example Basic example of acquiring an access token, but here is added another intermediate step - the process of impersonating a user. Here's a summary of how the whole process goes: Your external app will navigate to the authorize endpoint, passing your trusted app details (the trusted app, corresponding to your external app). If all's OK, the browser where your app is opened will be redirected to the ERP.net login page, where the user will enter their credentials. If the user logs in successfully, the ERP.net login page (i.e. ERP.net Identity Server) will be redirect to an uri, back to your external SPA. There you'll receive an authorization code. Finally you'll exchange the auth code for an access and refresh tokens at the token endpoint. You'll obtain an access and refresh tokens on behalf of the logged user (2). Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateAsCommunityUserAllowed true If your application allows external users. ImpersonateLoginUrl https://my.trusted.app/index.html The url where your external app will receive the authorization code when the user logs in successfully (see step 3 in the section above). ClientType Public Your external app will run entirely in a client-side uncontrolled environment, meaning it cannot keep a secret. Meaning it must be a public applicaiton. All other attributes can have their default values. They are not covered by this example. Steps The application below presents a single user page using html and pure javascript. Warning Don't use this code in production. Its purpose is only demonstrative. It lacks input validations, error handling and so. Initialization First we'll define some constants which we'll use later. var config = { client_id: \"my.trusted.app\", redirect_uri: \"https://my.trusted.app/app.html\", authorization_endpoint: \"https://demodb.my.erp.net/id/connect/authorize\", token_endpoint: \"https://demodb.my.erp.net/id/connect/token\", requested_scopes: \"offline_access DomainApi update\" }; We won't waste time, explaining about the constants, their names are self-explanatory. But there's one important detail- the offline_access in the requested_scopes. Its presence means that together with the access token you want also to receive a refresh token. It can be omitted, but then you'll only receive an access token and when it expires the user has to repeat the auth steps - i.e. to reenter its credentials. Body <a href=\"#\" id=\"start\">Click to Sign In</a> <div id=\"token\" class=\"hidden\"> <h2>Access Token</h2> <div id=\"access_token\" class=\"code\">no access token :(</div> </div> <div id=\"token\" class=\"hidden\"> <h2>Refresh Token</h2> <div id=\"refresh_token\" class=\"code\">no refresh token :(</div> </div> That's all the UI. A button that initiates the auth process. Two \"boxes\" visualizing the acquired access and refresh tokens. Authorization request (Authorize endpoint) The snippet below adds an event listener to the \"Click to Sign In\" button. When you press it, you'll trigger the authorization request - i.e. the defined function. document.getElementById(\"start\").addEventListener(\"click\", async function(e) { e.preventDefault(); // Create and store a random \"state\" value var state = generateRandomString(); localStorage.setItem(\"pkce_state\", state); var url = config.authorization_endpoint + \"?response_type=code\" + \"&client_id=\" + config.client_id + \"&state=\" + state + \"&scope=\" + config.requested_scopes + \"&redirect_uri=\" + config.redirect_uri; window.location = url; }); Just set-up the necessary arguments for the authroize endpoint and initiate a redirect. The Identity Server will take care of everything else, i.e., Will navigate to the ERP.net login page. After successful user login, will redirect to your config.redirect_uri. As you see, you're passing the following: The uri (i.e. the client id) of your trusted app config.client_id. The config.redirect_uri - the uri where you're waiting for the callback, when the user signs in. The scopes your external app needs. response_type=code. This \"instructs\" the Identity Server to send you a code (i.e. authorization code). Access token request (Token endpoint) The process of acquiring an access token is very simple also. When you already have the authorization code, you just have to send (i.e. make a POST request) it to the token endpoint. After, you will receive your access and refresh tokens as a response to your callback uri. First, we'll define a helper function, that will send a POST request. function sendPostRequest(url, params, success, error) { var request = new XMLHttpRequest(); request.open('POST', url, true); request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); request.onload = function() { var body = JSON.parse(request.response); if(request.status == 200) { success(request, body); } else { error(request, body); } } var body = Object.keys(params).map(key => key + '=' + params[key]).join('&'); request.send(body); } Now, the following is the actual request to the token endpoint: var args = window.location.search.substring(1); if (args != \"\") { // OAUTH REDIRECT HANDLING var idServerResponse = JSON.parse( '{\"' + args.replace(/&/g, '\",\"').replace(/=/g,'\":\"') + '\"}', function(key, value) { return key===\"\"?value:decodeURIComponent(value) }); if (idServerResponse.code) { // Exchange the authorization code for an access token sendPostRequest(config.token_endpoint, { grant_type: \"authorization_code\", code: idServerResponse.code, client_id: config.client_id, redirect_uri: config.redirect_uri }, function(request, body) { // Here you have your access and refresh tokens. document.getElementById(\"access_token\").innerText = body.access_token; document.getElementById(\"refresh_token\").innerText = body.refresh_token; }); }; } Or here's what it does broken into steps: Get the arguments from the current URI. That's because we're expecting the redirect_uri callback. I.e. the identity server sends our authorization code. If there're arguments (i.e. we are in the redirect scenario)- proceed. Parse the arguments and extract the authorization code - idServerResponse.code. Send a POST request, including the authorization code, client id and the redirect uri. The redirect uri is passed again, just as a security measure. Response is received- parse the access and refresh tokens and update the corresponding UI elements. Everything together <html> <title>ERP.net - Pure JS access token acquisition</title> <script> var config = { client_id: \"my.trusted.app\", redirect_uri: \"https://my.trusted.app/app.html\", authorization_endpoint: \"https:///demodb.my.erp.net/id/connect/authorize\", token_endpoint: \"https:///demodb.my.erp.net/id/connect/token\", requested_scopes: \"offline_access DomainApi update\" }; </script> <a href=\"#\" id=\"start\">Click to Sign In</a> <div id=\"token\" class=\"hidden\"> <h2>Access Token</h2> <div id=\"access_token\" class=\"code\">:(</div> </div> <div id=\"token\" class=\"hidden\"> <h2>Refresh Token</h2> <div id=\"refresh_token\" class=\"code\">:(</div> </div> <script> document.getElementById(\"start\").addEventListener(\"click\", async function(e) { e.preventDefault(); // Create and store a random \"state\" value var state = generateRandomString(); var url = config.authorization_endpoint + \"?response_type=code\" + \"&client_id=\" + config.client_id + \"&state=\" + state + \"&scope=\" + config.requested_scopes + \"&redirect_uri=\" + config.redirect_uri; window.location = url; }); var args = window.location.search.substring(1); if (args != \"\") { // OAUTH REDIRECT HANDLING var idServerResponse = JSON.parse( '{\"' + args.replace(/&/g, '\",\"').replace(/=/g,'\":\"') + '\"}', function(key, value) { return key===\"\"?value:decodeURIComponent(value) }); if (idServerResponse.code) { // Exchange the authorization code for an access token sendPostRequest(config.token_endpoint, { grant_type: \"authorization_code\", code: idServerResponse.code, client_id: config.client_id, redirect_uri: config.redirect_uri, code_verifier: localStorage.getItem(\"pkce_code_verifier\") }, function(request, body) { // Here you have your access token. document.getElementById(\"access_token\").innerText = body.access_token; }); }; } function sendPostRequest(url, params, success, error) { var request = new XMLHttpRequest(); request.open('POST', url, true); request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); request.onload = function() { var body = JSON.parse(request.response); if(request.status == 200) { success(request, body); } else { error(request, body); } } var body = Object.keys(params).map(key => key + '=' + params[key]).join('&'); request.send(body); } </script> </html> Resources The sample project in this example can be found here: https://github.com/ErpNetDocs/dev/blob/master/domain-api/samples/src/step-by-step/AccessTokenCodeSPA -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "domain-api/samples/step-by-step/web-app-access-token-auth-code.html": {
    "href": "domain-api/samples/step-by-step/web-app-access-token-auth-code.html",
    "title": "Access token via authorization code flow in a web app | ERP.net Developer Docs",
    "summary": "Access token via authorization code flow in a web app Objective You have an external web application that will be authorized via the ERP.net login form on behalf of an internal user. The application MAY or MAY NOT provide an UI, but there'll be user interaction at least for the initial login. Or, Your external app is an interactive application. Your external app is a web application. It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal user). Your external application will access the ERP.net instance on behalf of the logged user. Your external app MAY provide UI. It's able to keep a secret, so it's also a condfidential application. There'll be user interaction (at least for the internal user to log in), so your external app will use authorization code flow. The whole process in a nutshell After all, your final goal is to acquire an access token. The process is very similar to this example Basic example of acquiring an access token, but here is added another intermediate step - the process of impersonating a user. Here's a summary of how the whole process goes: Your external app will navigate to the so called authorize endpoint, passing your trusted app details (the trusted app, corresponding to your external app). If all's OK, the browser where your app is opened will be redirected to the ERP.net login page, where the user will enter their credentials. If the user logs in successfully, the ERP.net login page (i.e. ERP.net Identity Server) will be redirect to a uri, back to your external web app. There you'll receive an authorization code. Finally you'll exchange the auth code for an access token at the token endpoint. You'll obtain an access token on behalf of the logged user (2). Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateLoginUrl https://my.trusted.app/app.php The url where your external app will receive the authorization code when the user logs in successfully (see step 3 in the section above). ClientType Confidential Your external app \"will work\" with internal users only, so there'll be no \"public\" acccess. We can assume that it can keep a secret securely (in fact, it's a must). ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. All other attributes can have their default values. They are not covered by this example. Steps Unlike the Basic example of acquiring an access token, where everything is clear enough to describe with simple HTTP requests, here the examples are shown in the context of a simple PHP application (i.e. an external app). Warning Don't use this code in production. Its purpose is only demonstrative. It lacks input validations, error handling and so. Initialization First we'll define some constants which we'll use later. const AUTHORIZE_URI = \"https://demodb.my.erp.net/id/connect/authorize\"; const TOKEN_URI = \"https://demodb.my.erp.net/id/connect/token\"; const CALLBACK_URI = \"https://my.trusted.app/app.php\"; const TRUSTED_APP_URI = \"my.trusted.app\"; const TRUSTED_APP_SECRET = \"<my_plain_app_secret>\"; const DOMAIN_API_TEST_URI = \"https://demodb.my.erp.net/api/domain/odata/Crm_Customers?\\$top=10\"; We won't waste time, explaining about the constants, their names are self-explanatory. Main code Take a look at this snippet: if (isset($_POST) && isset($_POST[\"code\"])) { $authCode = $_POST[\"code\"]; $accessToken = acquireAccessToken($authCode); domainApiCall($accessToken); exit(); } sendAuthorizationRequest(); This is the main \"algorithm\" of our example external app. What does it do? Easy, If a POST request is made and its array contains code: Assume that this code is the authorization code, sent back from the Identity Server. Pass this code to acquireAccessToken, so an access code will be acquired. Make a call to the DomainApi via domainApiCall, passing the access token. Else send a new authorization request. Authorization request (Authorize endpoint) It's quite simple: function sendAuthorizationRequest() { $authorizeRequest = AUTHORIZE_URI . \"?\" . \"client_id=\" . TRUSTED_APP_URI . \"&\" . \"redirect_uri=\" . CALLBACK_URI . \"&\" . \"response_type=code%20id_token&\" . \"response_mode=form_post&\" . \"scope=openid%20profile%20offline_access%20DomainApi&\" . \"nonce=abc&\" . \"state=xyz\"; header(\"Location: $authorizeRequest\"); } Just set-up the necessary arguments for the authroize endpoint and initiate a redirect. The Identity Server will take care of everything else, i.e., Will navigate to the ERP.net login page. After successful user login, will redirect to your CALLBACK_URI. As you see, you're passing the following: The uri of your trusted app TRUSTED_APP_URI. The CALLBACK_URI - the uri where you're waiting for the callback, when the user signs in. The scopes your external app needs. In addition, there're two other important arguments: response_type=code id_token. This \"instructs\" the Identity Server to send you a code (i.e. authorization code) and an identity token (not discussed in this topic). response_mode=form_post. This \"tells\" the Identity Server that you're expecting the callback request as an HTTP POST request. Access token request (Token endpoint) The process of acquiring an access token is very simple also. When you already have the authorization code, you just have to send (i.e. make a POST request) it to the token endpoint. After, you will receive your access token as a response. function acquireAccessToken($authCode) { $tokenRequestBody = array( \"client_id\" => TRUSTED_APP_URI, \"client_secret\" => TRUSTED_APP_SECRET, \"grant_type\" => \"authorization_code\", \"code\" => $authCode, \"redirect_uri\" => CALLBACK_URI ); $opt = array( 'http' => array( 'header' => \"Content-type: application/x-www-form-urlencoded\\r\\n\", 'method' => 'POST', 'content' => http_build_query($tokenRequestBody) ) ); $context = stream_context_create($opt); $result = file_get_contents(TOKEN_URI, false, $context); if ($result == FALSE) { return false; } $clientAuthData = json_decode($result, true); return $clientAuthData[\"access_token\"]; } Authorized Domain API call Now we're authorized and we can make a legitimate call to the ERP.net Domain Api. E.g., function domainApiCall($accessToken) { $opt = array( 'http' => array( 'header' => 'Authorization: Bearer ' . $accessToken) ); $context = stream_context_create($opt); $response = file_get_contents(DOMAIN_API_TEST_URI, false, $context); print_r($response); } The response will contain the result of the query. Everything together <?php const AUTHORIZE_URI = 'https://demodb.my.erp.net/id/connect/authorize'; const TOKEN_URI = 'https://demodb.my.erp.net/id/connect/token'; const CALLBACK_URI = 'https://my.trusted.app/app.php'; const TRUSTED_APP_URI = 'my.trusted.app'; const TRUSTED_APP_SECRET = '<my_plain_app_secret>'; const DOMAIN_API_TEST_URI = 'https://demodb.my.erp.net/api/domain/odata/Crm_Customers?$top=10'; if (isset($_POST) && isset($_POST['code'])) { $authCode = $_POST['code']; $accessToken = acquireAccessToken($authCode); domainApiCall($accessToken); exit(); } sendAuthorizationRequest(); function sendAuthorizationRequest() { $authorizeRequest = AUTHORIZE_URI . '?' . 'client_id=' . TRUSTED_APP_URI . '&' . 'redirect_uri=' . CALLBACK_URI . '&' . 'response_type=code%20id_token&' . 'response_mode=form_post&' . 'scope=openid%20profile%20offline_access%20DomainApi&' . 'nonce=abc&' . 'state=xyz'; header(\"Location: $authorizeRequest\"); } function acquireAccessToken($authCode) { $tokenRequestBody = array( 'client_id' => TRUSTED_APP_URI, 'client_secret' => TRUSTED_APP_SECRET, 'grant_type' => 'authorization_code', 'code' => $authCode, 'redirect_uri' => CALLBACK_URI ); $opt = array( 'http' => array( 'header' => 'Content-type: application/x-www-form-urlencoded', 'method' => 'POST', 'content' => http_build_query($tokenRequestBody) ) ); $context = stream_context_create($opt); $result = file_get_contents(TOKEN_URI, false, $context); if ($result == FALSE) { return false; } $clientAuthData = json_decode($result, true); return $clientAuthData['access_token']; } function domainApiCall($accessToken) { $opt = array( 'http' => array( 'header' => 'Authorization: Bearer ' . $accessToken ) ); $context = stream_context_create($opt); $response = file_get_contents(DOMAIN_API_TEST_URI, false, $context); print_r($response); } ?> Resources The sample project in this example can be found here: https://github.com/ErpNetDocs/dev/blob/master/domain-api/samples/src/step-by-step/AccessTokenCodeWeb -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "domain-api/transactions.html": {
    "href": "domain-api/transactions.html",
    "title": "Domain API Transactions | ERP.net Developer Docs",
    "summary": "Domain API Transactions Тhe ErpNet Domain API introduces a server-side transaction that holds any change of an entity object made between calls of BeginTransaction and EndTransaction. An api transaction is a data set that contains the data for the objects used in the transaction. When we create a domain object in a transaction, a data set containing the data for this object is created in the memory of the api process. If we create another object in the same transaction, the second object is also saved in the same data set. The data is not yet present in the database until we commit the transaction. If we update the same field with different API requests in the same transaction, the value of the field remains the one submitted last. If we use a front-end transaction, each submission of a value for a given field will trigger front-end events that may update other fields. When the transaction is committed, the entire dataset is submitted to the database. At this point, we don't guarantee the order in which records from the same table are inserted into database. That's why several objects that have reference to the same entity type must be created in different transactions (for example parent-child related documents). BeginTransaction BeginTransaction is unbound (not bound to any entity) action (actions are called with HTTP POST method) that initializes an object transaction on the server and returns a TransactionId token as a plain text (not json - for example XXXXX). This object transaction is something like memory data-set that holds copies of database records. If any subsequent request includes the TransactionId token in the HTTP header (like this: TransactionId:XXXXX) the requested operation will not be executed against the database but against the memory transaction. This means that any POST, PATCH and DELETE requests will be executed only in memory. Parameters model: allowed values are common or frontend. This parameter indicates the data model used for the transaction. Front-end data model uses front-end business rules. For example front-end logic is when Quantity of a SalesOrderLine is changed the corresponding QuantityBase is calculated by a dedicated front-end business rule. Common model defines minimal business logic applicable in all cases - front-end or back-end. The default is common. trackChanges: true or false. This parameter enables the usage of GetChanges and WaitForChanges functions. This means that if parameter trackChanges is not true any call to GetChanges and WaitForChanges will return error. GetChanges GetChanges is unbound function - functions are invoked through GET HTTP method. This function requires the HTTP header TransactionId to be passed. It also requires the front-end transaction to be initialized with trackChanges: true. Front-end transactions support front-end business rules. These are rules that are usually triggered on attribute change. For example if we change the DocumentDate attribute of a SalesOrder (using regular PATCH request including the TransactionId in the request header), this change will trigger updates of several other attributes. If the front-end transaction is initialized with trackChanges: true, the changes will be collected in the server side (inside the front-end transaction). GetChanges returns all changes made after the last call of GetChanges or WaitForChanges. The changes are grouped by operation type (insert, update, delete), entity name, entity id. The call of GetChanges (or WaitForChanges) clears the collected changes in the transaction. If no change is made after the last call of GetChanges it will return empty result (empty JSON object). WaitForChanges WaitForChanges is unbound function that returns the same result as GetChanges but if there is not any change the function blocks until a change occurs or until it times out. The wait timeout is 2 minutes. This function requires the HTTP header TransactionId to be passed. It also requires the front-end transaction to be initialized with trackChanges: true. The response format of GetChanges and WaitForChanges follows this JSON schema: \"insert\" | \"update\" | \"delete\" : { \"<entity-name>\" : { // example: \"General_Products_Products\" \"<id>\": { // example: 59098bcf-f331-478f-91c2-f5520590f534 (Guid) \"<attribute>\": <value> // example: \"ABCClass\": \"A\" } } } EndTransaction EndTransaction is unbound action that disposes the memory transaction created with BeginTransaction. After EndTransaction the transaction id becomes invalid. Parameters commit: true or false. Specifies whether to commit the transaction (save the changes) or not. Default is true. To commit the changes made in the memory transaction to the database you should provide the parameter commit = true. Note The object transaction is called Front-End because any change of an entity object will trigger front-end business rules. For example if Quantiy of a SalesOrderLine is changed the corresponding QuantityBase will be automatically recalculated. This is front-end behavior - if front-end transaction is not used the QuantityBase will not be automatically recalculated and it's value must be explicitly set. Through Front-End Transaction, GetChanges or WaitForChanges we can synchronize our UI passing only the user actions to the server - such as update of an attribute, creating new object or deleting existing object. Transaction Lifespan and Management Each transaction has a defined lifespan. In a typical scenario: The lifespan of a transaction starts with the BeginTransaction call and ends with the EndTransaction call Additionally, each transaction has an absolute maximum lifespan, which is 25 minutes. Note Every transaction will be automatically cleared 25 minutes after its creation unless it has already been explicitly cleared with EndTransaction. If you reference the TransactionId of a cleared (or not existing) transaction, an error will be returned: \"Invalid TransactionId {id}\". Note It is best practice to keep transactions short and always close them when your work with them is complete. Examples Simple usage of a front end transaction BeginTransaction POST /api/domain/odata/BeginTransaction HTTP/1.1 Host: https://example.com Content-Type: application/json { \"model\": \"frontend\" } Response (Transaction id): 843f05ff3f62400c990d2a3b119e256e Update Make subsequent updates of products PATCH /api/domain/odata/General_Products_Products(59098bcf-f331-478f-91c2-f5520590f534) HTTP/1.1 Host: https://example.com Content-Type: application/json TransactionId: 843f05ff3f62400c990d2a3b119e256e { \"ABCClass\":\"A\", \"StandardLotSizeBase\":{\"Value\":3.45,\"Unit\":\"PCS\"}, \"MeasurementUnit@odata.bind\":\"https://example.com/api/domain/odata/General_MeasurementUnits(5c5e77ce-60bb-4338-abd0-3a2acb27ff93)\" } CommitTransaction POST /api/domain/odata/EndTransaction HTTP/1.1 Host: https://example.com Content-Type: application/json TransactionId: 843f05ff3f62400c990d2a3b119e256e { \"commit\": true } Updating SalesOrder.DocumentDate and calling GetChanges BeginTransaction POST /api/domain/odata/BeginTransaction HTTP/1.1 Host: https://example.com Content-Type: application/json { \"model\": \"frontend\", \"trackChanges\": true } Response (Transaction id): fd5d3bbc38ae4dd9a8a5c0ff46c8e3af Updating DocumentDate This update triggers many front-end business rules that update many other attributes in the sales order and it's lines. PATCH /api/domain/odata/Crm_Sales_SalesOrders(33cd6cb9-0f43-df11-a1e1-0018f3790817) Host: https://example.com Content-Type: application/json TransactionId: fd5d3bbc38ae4dd9a8a5c0ff46c8e3af { \"DocumentDate\": \"2020-05-08T00:00:00Z\" } Response: nocontent Call GetChanges The result is a JSON object with all changes made after the last call to GetChanges (or BeginTransaction if GetChanges is not called yet). GET /api/domain/odata/GetChanges HTTP/1.1 Host: https://example.com Content-Type: application/json TransactionId: fd5d3bbc38ae4dd9a8a5c0ff46c8e3af Response: { \"@odata.context\": \"https://clients.inco.bg/api/domain/odata/$metadata#Erp.OpenObject\", \"update\": { \"Crm_Sales_SalesOrders\": { \"33cd6cb9-0f43-df11-a1e1-0018f3790817\": { \"PaymentDueDate\": \"2020-05-08T00:00:00Z\", \"PaymentDueStartDate\": \"2020-05-08T00:00:00Z\", \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"DocumentDate\": \"2020-05-08T00:00:00Z\" } }, \"Crm_Sales_SalesOrderLines\": { \"c253add9-0f43-df11-a1e1-0018f3790817\": { \"HistoricalUnitCost\": null, \"RequestedQuantity\": null, \"StandardUnitPrice\": null, \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"LineAmount\": { \"Value\": 1.62, \"Currency\": \"BGN\" }, \"Quantity\": { \"Value\": 2, \"Unit\": \"бр\" }, \"QuantityBase\": { \"Value\": 2, \"Unit\": \"бр\" }, \"StandardQuantityBase\": { \"Value\": 2, \"Unit\": \"бр\" }, \"UnitPrice\": { \"Value\": 0.9, \"Currency\": \"BGN\" } }, \"c653add9-0f43-df11-a1e1-0018f3790817\": { \"HistoricalUnitCost\": null, \"RequestedQuantity\": null, \"StandardUnitPrice\": null, \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"LineAmount\": { \"Value\": 5.53, \"Currency\": \"BGN\" }, \"Quantity\": { \"Value\": 3, \"Unit\": \"бр\" }, \"QuantityBase\": { \"Value\": 3, \"Unit\": \"бр\" }, \"StandardQuantityBase\": { \"Value\": 3, \"Unit\": \"бр\" }, \"UnitPrice\": { \"Value\": 2, \"Currency\": \"BGN\" } }, \"c753add9-0f43-df11-a1e1-0018f3790817\": { \"HistoricalUnitCost\": null, \"RequestedQuantity\": null, \"StandardUnitPrice\": null, \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"LineAmount\": { \"Value\": 4.38, \"Currency\": \"BGN\" }, \"Quantity\": { \"Value\": 6, \"Unit\": \"kg\" }, \"QuantityBase\": { \"Value\": 6, \"Unit\": \"kg\" }, \"StandardQuantityBase\": { \"Value\": 6, \"Unit\": \"kg\" }, \"UnitPrice\": { \"Value\": 0.8, \"Currency\": \"BGN\" } }, \"c153add9-0f43-df11-a1e1-0018f3790817\": { \"HistoricalUnitCost\": null, \"RequestedQuantity\": null, \"StandardUnitPrice\": null, \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"LineAmount\": { \"Value\": 10.56, \"Currency\": \"BGN\" }, \"Quantity\": { \"Value\": 10, \"Unit\": \"l\" }, \"QuantityBase\": { \"Value\": 20, \"Unit\": \"бр\" }, \"StandardQuantityBase\": { \"Value\": 20, \"Unit\": \"бр\" }, \"UnitPrice\": { \"Value\": 1.17348, \"Currency\": \"BGN\" } } } } }"
  },
  "includes/erpnet.html": {
    "href": "includes/erpnet.html",
    "title": "| ERP.net Developer Docs",
    "summary": "ERP.net"
  },
  "includes/name.html": {
    "href": "includes/name.html",
    "title": "| ERP.net Developer Docs",
    "summary": "ERP.net"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the ERP.net Developer Documentation | ERP.net Developer Docs",
    "summary": "Welcome to the ERP.net Developer Documentation Here you will find all the necessary resources for building applications targeting the ERP.net services. This documentation contains developer resources. For business logic and other technical documentation, you might want to check the Technical Documentation. ERP Instances The ERP.net service is a hosted ERP service. Accessing the data is done through ERP Instances. When you sign up at erp.net, you can create and manage a new ERP Instance. An ERP Instance is a tenant in the hosting environment. It is multi-company, e.g. it allows managing multiple related legal entities (companies) in one instance. You don't need to create separate instances for each managed company. Each ERP Instance has a unique name. The instance can be accessed at: https://<<instance_name>>.my.erp.net For example, the demonstration database, DEMODB, is located at: https://demodb.my.erp.net The API Each ERP Instance CAN have an API site. It \"can\" have, because, the API is a site, similar to other sites, which the instance can launch. In order for the API to function, it needs to be configured and launched for the ERP Instance. The common URL for the API site is /api/ inside the ERP instance. For example, the DEMODB has an API site at: https://demodb.my.erp.net/api/ The Domain API The Domain API is the primary means for accessing and manipulating data in the ERP Instance. It can currently be consumed in OData 4 format. The Domain API is an API proxy for the object-oriented Domain Model of ERP.net. It is targeted towards UI and service apps. These kinds of apps usually read and update moderate amounts of data. The Domain API is NOT adequate for read-only dumping of very large amounts of data, which is usually done by BI applications. BI applications should find other solutions or try to read data in small chunks. The Domain API is located at /domain/odata/ within the API site. For DEMODB, this is at: https://demodb.my.erp.net/api/domain/odata/ Tip User: Admin Password: 123 If you try the above link, it will ask you for user credentials. Most ERP Instances should, by default, be configured to NOT accept basic authentication. However, for demonstration purposes, DEMODB is configured to allow it. Sample Query OData v4 allows the creation of URL-based queries. For example, to take the first 10 products (in undefined order), you can use: https://demodb.my.erp.net/api/domain/odata/General_Products_Products?$top=10 [!NOTE:] The above will return unformatted JSON result, intended to be consumed by client app. For a quick overview of OData, see this topic - Understand OData in 6 steps. The Query Builder ERP.net has integrated visual Query Builder. The Query Builder allows building queries, specific to the ERP Instance. When you use the Query Builder, it allows you to select the user-defined data and calculated attributes in that instance. The Query Builder allows the developers to create the query visually and then just re-use the query text, replacing the parameters. To access the Query Builder for DEMODB, go to: https://demodb.my.erp.net/api/domain/querybuilder While the query is built, the Query Builder changes its URL. For example, to preview the same query for the first 10 products in the Query Builder, head to: https://demodb.my.erp.net/api/domain/querybuilder#General_Products_Products?$top=10 When you press Execute in the Query Builder, you can preview the result both as a table and as JSON. Note Pay attention to the link under the selected entity, which opens the documentation for the entity. The Query Tool The Query Tool is a simple Postman-like tool for querying the database. It does not have the visual building abilities of the Query Builder. However, it can represent all possible REST requests and is very simple to use. Note The Query Tool is the default tool, which is used to represent queries in forum posts, tickets, etc. To access the Query Tool for DEMODB, go to: https://demodb.my.erp.net/api/domain/query Query Basics ERP.net allows only a subset of the full OData queries. Generally, you cannot do JOINs and filter with OR. However, you can filter by multiple values, like the SQL IN operator: https://demodb.my.erp.net/api/domain/odata/General_Products_Products?$top=10&$filter=Id%20in%20(edf2bd2a-7e4d-e111-a06c-00155d00050a,cf728601-1fd5-4853-ab23-01deeee7d038) Instance API Reference Each ERP Instance has its own API reference documentation. The instance-specific API reference documentation is like the Model docs. The main difference is that the reference documentation of a specific ERP Instance lists also the user-defined attributes. The user-defined attributes can be queried mostly like the system attributes. The instance reference documentation of DEMODB is at: https://demodb.my.erp.net/api/domain/docs Tip Since the instance API reference contains user-defined objects from the database, it is accessible only after authentication. For general-purpose information, check the Model. Security Someone said: \"Security is hard, deal with it\". The hard truth is that security today is much harder than it was 10 years ago. Once upon a time, there was a user and a password. Today, we have OAuth with Trusted Apps, Security Tokens, complicated security workflows, and all the other things. There are some good things, though. Single Sign-On, multi-factor authentication, and other extras come to mind. But, at the end of the day, you have to do much more work to create a secure app. ERP.net is based on the OAuth 2 security paradigm with OpenID Connect support. For more information about security, read Introduction to authentication in ERP.net. Next Steps See the general topics in General. Check the Domain API documentation. Check the Domain Model for reference information about objects, API methods, integrated business rules, and more."
  },
  "testinclude.html": {
    "href": "testinclude.html",
    "title": "| ERP.net Developer Docs",
    "summary": "The includes/erpnet.md file exists for the sole reason of containing the proper writing of \"ERP.net\". It is intended to be included inline in the text of other topics. Unfortunately, DocFX seems to handle the matter of inline-inclusion with a pretty heavy-weight syntax. Example: I can easily create a link to the erpnet topic. But this is a link. We need just to include the file contents. For more information: https://dotnet.github.io/docfx/tutorial/links_and_cross_references.html#shorthand-form I can include the file contents, but with a pretty heavy syntax ERP.net. This syntax is not adequate for everyday writing. For more information: https://dotnet.github.io/docfx/spec/docfx_flavored_markdown.html#inline Ideally, the following syntax should include the text inline: This is the ERP.net service! The above line should render as: This is the ERP.net service!"
  },
  "topics/application-types.html": {
    "href": "topics/application-types.html",
    "title": "Application types | ERP.net Developer Docs",
    "summary": "Application types To aid in correctly choosing the authentication and API types, we have compiled a list of common application types. Summary of application types Below, you can find a summarization of the application types and the respective user, authentication and API types. Application Type User Type Authentication API Internal Web app Internal Authorization Code Domain API External Web app External Client Credentials Domain API Service application Application Client Credentials Domain API Business Intelligence Application Basic Authentication Table API Backup Application Basic Authentication Table API Application type details Internal Web App These are internal enterprise applications, used by the internal users. User type: Internal users Authentication: Authorization Code API: Domain API External Web App External web apps are geared towards external users and allow them limited and specialized access. External web apps use Application Accounts to access the ERP resources on behalf of the external users. User type: External users Authentication: Client Credentials API: Domain API Note Some applications might allow both external and internal users. In this case, the app should use the same authentication like internal web app. Service application Service applications are applications, which run usually in background and do not require user login. User type: Application Account Authentication: Client Credentials API: Domain API BI application Business Intelligence (BI) apps use platforms like Power BI to visualize user data in various dashboards, charts, etc. User type: Application Account Authentication: Basic Authentication API: Table API Backup Backup applications transfer data to external sources. User type: Application Account Authentication: Basic Authentication API: Table API"
  },
  "topics/authentication/authentication-flows.html": {
    "href": "topics/authentication/authentication-flows.html",
    "title": "Authentication Flows | ERP.net Developer Docs",
    "summary": "Authentication Flows Authentication Flows are the process flows, which an external app can use to request access to the ERP Instance. Authorization Code This authorization flow is used by interactive user applications, which access the ERP Instance on behalf of the logged user. If we relate to Tom and Jane scenario, this would be the case when we want Toms app to create the Sales Orders using Jane account and access permissions. Jane wants to start using Toms app to create her Sales Orders. Toms app is generally authorized for the ERP Instance (with Trusted Application record), but Jane has not yet authorized it to work on her behalf! If Toms app presents a login screen to get Janes credentials and use them to access the ERP Instance, this would expose the credentials to the app author. So, instead, the app asks the platform to verify that it is Jane in front of the computer. Toms app requests the ERP Instance to authenticate the user using the browser. Jane is presented with a familiar log-in screen, which is used by ALL apps. Since Jane trusts the platform, she securely enters her user name and password. The ERP Instance validates Janes credentials and creates a special id token. The token is actually just a string, which contains Janes details, like name, profile picture and email. The token is passed back to the app, using the apps Login URL. Now, Toms app knows that it is Jane which is using his app, but without ever gaining access to her credentials! Client Credentials Client Credentials is an authorization flow, with which an app requests service access. The service account, which is used to create the session is configured in the Trusted Application record. Note The service session is not related to any specific interactive user. It can be created on service startup and renewed whenever necessary. Lets relate this to the Tom and Jane scenario from the Overview. With service access, Toms app will create all Sales Orders with the same service account. It would not use Janes or any other user account to access the ERP Instance. The basic flow is the following: Toms app provides its application URI and application secret to the ERP Instance. The URI and secret are much like user name and password, but for application. The ERP Instance looks up the Trusted Application record for Toms app. Based on the Service Account specified in the record, the ERP Instance creates a special access token and passes it to Toms app. The access token is just a string, containing the granted access permissions, which is digitally signed. Toms app uses the access token to call the ERP APIs and create the Sales Orders. Basic Authentication In basic HTTP authentication, a request contains a header field in the form of Authorization: Basic , where credentials is the Base64 encoding of user name and password joined by a single colon :. Note Basic Authentication is not recommended because it is less secure than OAuth! In ERP.net basic authentication can be used by applications, which access the ERP Instance on behalf of the logged user. Some legacy external applications use the obsolete SDK API to access the ERP Instance. To authenticate they must provide username, password and application name. If the provided application name is not found among the trusted applications in the ERP Instance the authentication will fail. Domain API and Table API allow basic authentication but require their corresponding trusted application to allow basic authentication. Possible errors: Authentication faled for user 'test'. Current request uses basic authentication but the provided application 'DEMOAPP' is not found among the trusted applications. Contact your system administrator to create trusted application 'DEMOAPP' and configure it to allow basic authentication. Authentication failed for user 'test'. Current request uses basic authentication but the trusted application 'DEMOAPP' is not enabled. Contact your system administrator to enable the trusted application 'DEMOAPP' and configure it to allow basic authentication. Authentication failed for user 'test'. Current request uses basic authentication but the provided application 'DEMOAPP' is not configured to allow basic authentication. Contact your system administrator to configure the trusted application 'DEMOAPP' to allow basic authentication. Authentication failed for user 'test'. Current request uses basic authentication but the corresponding trusted application 'DEMOAPP' is configured for system user that is different from the provided user 'test'. Use the correct application user to log in or contact your system administrator to configure the trusted application 'DEMOAPP' for different user."
  },
  "topics/authentication/index.html": {
    "href": "topics/authentication/index.html",
    "title": "Introduction to authentication in ERP.net | ERP.net Developer Docs",
    "summary": "Introduction to authentication in ERP.net ERP.net APIs use OAuth 2 for authentication and authorization. In OAuth 2, the authentication and authorization is performed by an identity provider. ERP.net has built-in identity provider, which conforms to the OpenID Connect specification. Why do we need OAuth 2? In the good old days of lesser security, there was just a user and a password. If we need to access an app, we enter the user name and the password and voila - we get access! So, what is the problem to continue like this? Suppose Tom has created a good little app, which automates the Sales Order creation. You just select from one of three predefined templates and your sales order is created. The problem is: How should Toms app access your ERP Instance? Option 1 would be to give him your user name and password. OK, but then your user name and password are no longer so secure, aren't they? Even if you don't give them directly to Tom, but \"just\" enter them in a web form, Tom still receives your precious security secret! Option 2 would be ... Can't we can just give Toms app access to the ERP Instance, but without sharing our credentials? This is where OAuth 2 comes in. A group of very clever people have come up with a standard, which allows users to authorize apps to do things on their behalf. Enter the age of platforms and apps. Note To be more precise, it should be called age of Identity providers and apps. But in the current case, the platform is also the Identity provider. Trust an application When you install an app on your phone, you authorize this app to do certain things with your data. The Android or iOS platform allows the app to access only the data you have authorized it to access. You fully trust the platform, but you don't fully trust any app out there. The platform should stop malicious attempts to steal and manipulate your data. Similar, but still a bit more complicated paradigm can be applied to ERP Instances. The administrator of the ERP Instance plays the role of the phone owner. The ERP Instance is the platform and the app is, well, the app. In our phones, before using an app, we need to install it. With ERP Instances, we don't actually install the app, because the app is already hosted somewhere. So, this step is skipped. We just have to tell the system, that we trust this app. Manually trust an application To manually trust an application, you create a Trusted Application record, which informs the ERP Instance, that you trust this application. For more information, see Trusted Applications. Install from a marketplace Another way to trust an application is to activate it from a marketplace. In this case, the marketplace redirects the browser to a \"Register Trusted Application\" endpoint in your ERP Instance. The registration process verifies that you are an administrator of the ERP Instance and then simply asks you if you want to trust this application. Note This is very similar to the way your phone asks you if you trust a new application. Access data in the ERP Instance Once an application is trusted, it can use two ways to access ERP data - through user account or through service access. Interactive applications Interactive applications have UI and use Authorization Code flow to request user access. Service applications Service applications have no UI and use only service accounts. They use the Client Credentials flow to request service access. Note A single application can use both interactive user login and service access to perform different functions. Read more about Authentication Flows."
  },
  "topics/authentication/trusted-applications.html": {
    "href": "topics/authentication/trusted-applications.html",
    "title": "Trusted Applications | ERP.net Developer Docs",
    "summary": "Trusted Applications A trusted application record tells the system that a specific application is allowed to access the ERP Instance. General information Trusted Application record can be created manually or through a marketplace activation. Anyway, it is good to understand the information stored in such a record. Anatomy of a Trusted Application record A Trusted Application record contains many fields. To better understand them, read below. Name This is the multi-language name of the application. Used mostly for interactive display in UI clients. Not important for the functioning of the application. Application URI This is the application identifier. It is passed as parameter by the applications, when they claim who they are in front of the ERP Instance. The Application URI should be unique for the ERP Instance. Preferably, it should be globally unique, so that the application can be listed in a marketplace. Use short, concise identifier. This will appear in logs and other files. Avoid non-latin and special characters. It is advised, that you incorporate this identifier as constant in your application and use the same URI for all \"trusts\" for your app. Note It is best to base your app URIs on your web site and some extension. For example, mywebsite.com/myapp1 is a good URI. Client Type Client Type specifies the confidentiality abilities of the your application. Client types are: Confidential Public Confidential client applications are able to keep secrets. Public apps are generally unable to hide a secret from an advanced intruder. For example: JavaScript apps, executed in the user browser, are public apps. Generally they cannot hide a secret from an advanced user. If a JavaScript app has a secret in its code, it can easily be revealed (and probably abused). Server executed apps are usually confidential. They are executed in a trusted environment and, if properly secured, can keep a secret. Application Secret Hash This is a bit of a challenge. You have to use a tool to get the hash. Type this in the browser (replace \"mysecret\" with your secret): https://demodb.my.erp.net/sys/tools/sha256?secret=mysecret Basic Authentication Allowed If true, this application allows login with user name and password. When a client application uses basic authentication it must provide the application uri along with user name and password. Use with caution, because basic authentication is less secure than oauth! If a user is specified in System User, the basic authentication is allowed only for this user. Impersonate As Community / Internal User Allowed Allows the app to request login from a community (external) or internal user. When both options are OFF, the app would not be allowed to request a user to be authenticated. This is a common scenario for service applications with no UI. If any or both options are ON, the app is allowed to impersonate, e.g. request login. The login would be successful only if the authenticated user is of one of the allowed types. Common scenarios: Service app - both options OFF. Internal interactive app - only Internal users allowed. Public web app - both Community and Internal users allowed. Note Avoid allowing only Community and disallowing Internal users. Usually, community accounts can be freely created by anybody. So, allowing only community accounts could create confusion for the internal users and force them to create a separate, external (community) account. Note It is strongly not recommended for a user to have duplicate accounts, just for the purpose of having both community and internal accounts. Impersonate Login URL This is used only for applications, which use the Authorization Code Flow. It is called after a successful login and receives the generated code used to retrieve identity and access tokens. Usually, this URL is a dedicated endpoint in the app environment. The endpoint should conform to: https://openid.net/specs/openid-connect-core-1_0.html#AuthResponse Note You can specify multiple valid URLs by comma-separating them (typically, to handle different environments like QA or testing). Impersonate Logout URL Specifies a comma separated list of allowed URIs to redirect to after logout. Is Enabled Disables the access of the application. Scope The scope (according to RFC 6749) for which the application was trusted. The scope is an unordered list of space-delimited case-sensitive strings. Each string denotes a permission. The following token scopes are used : update Allows the user application to update data in the ERP Instance. Without this scope, the application can only read data. Introduced: 22 The following token scopes are PLANNED for near future developments: sec Allows the application to access the security infrastructure of the ERP Instance. Generally, this scope should NEVER be trusted to user apps. Scopes, reserved for future use: profile general crm logistics production finance personaldata System User This is the service user, which will be used to initiate sessions, when the application requests token with Client Credentials. System User Allowed Specifies whether the application is allowed to request service access. System User Login URL Reserved."
  },
  "topics/erp-instances.html": {
    "href": "topics/erp-instances.html",
    "title": "ERP Instance | ERP.net Developer Docs",
    "summary": "ERP Instance Each tenant in the ERP.net infrastructure is called an ERP Instance. General info When a client creates a subscription with the ERP.net service, they get an ERP Instance. A single account can create and manage more than one ERP Instance. This might be required for testing, validation or other purposes. Note A single ERP Instance can manage multiple legal entities (companies). Under the hood, each ERP Instance is managed as a single database. For this reason, the terms ERP Instance and database are sometimes used interchangeably. The proper term is ERP Instance, since this is more abstract and not related to any underlying technology. The ERP Instances are provided as a service from the ERP.net infrastructure and the actual storage is undistinguishable to the end user. UIN Each ERP Instance has a Unique Instance Name (UIN) or simply name. For example, the demonstration database is named \"demodb\". Root URL The ERP Instances are accessible through their root URL address. The root URL address is https://<<UIN>>.my.erp.net For example, the root URL of demodb is: https://demodb.my.erp.net You can go ahead and click that address. It opens the home page of the ERP Instance. For security reasons, it does not give access to much else than some general info and public downloads. The root URL is usually also used as base address for the instance-related web sites. For example, demodb has several web sites active. One of the sites is the Domain API site, available at: https://demodb.my.erp.net/api Note The web sites can be hosted at custom URL addresses. Using the Root URL is just a default."
  },
  "topics/index.html": {
    "href": "topics/index.html",
    "title": "Introduction | ERP.net Developer Docs",
    "summary": "Introduction Explore the ERP.net developer documentation to quickly learn how to build great integrations with the platform. ERP Instances Each ERP database is an instance. To learn more, see ERP Instances. Choose application type When designing a new app, the first step is to choose which authentication type and API should be used. To simplify this, we have compiled a list of common application types. Authentication All APIs in ERP.net use the same authentication mechanism, based on OAuth2. To understand authentication, see Authentication. Select API Choose the correct API: Domain API - Object oriented API, based on the Domain Model. The main API for processing data by web sites, services and other business logic apps. Table API - Limited purpose read-only, fast-forward API based on the raw table data model. Intended for Business Intelligence and backup apps, requiring fast dumping of big quantities of raw data. Data Access API - Legacy API, exposing table-based methods for retrieving and manipulating data. Not documented and not recommended for new developments."
  },
  "topics/table-api/index.html": {
    "href": "topics/table-api/index.html",
    "title": "Table API | ERP.net Developer Docs",
    "summary": "Table API The primary purpose of the Table API is to allow external BI (Business Intelligence) tools to quickly pull raw data for further analysis. Authentication The Table API supports the following types of authentication: OAuth 2.0 Basic Authentication Caution Although Basic Authentication is supported, its use is strongly NOT recommended due to its significantly lower level of security. For more information, see Authentication. Tables For information about the tables that can be queried, see the Table Model. Best practices for refreshing data when building external BI systems based on a TableAPI site Introduction The first step in building a BI system is loading (Extract) data from the source database. This is done using a TableAPI site that allows an authorized user to access raw data at the table level. It is essential to achieve optimal transfer speed by using the capabilities provided for filtering the primary information to minimize data refresh time. For this reason, we describe best practices when using TableAPI (OData) data source to power PowerBI and BI data analysis platforms in general. The information is organized with increasing complexity and presented through examples for ease of understanding, allowing for step-by-step code copying and testing. Following these guidelines is necessary to avoid potential errors and delays when loading data. There are two main ways to download data: Using OData.Feed to read data from the source Using Web.Contents to read data from the source In both approaches, you must manually set parameters and filters for queries to achieve optimal results. This includes specifying the fields returned by the query (listed in the select clause) and setting the filter that will be applied to determine the data. Filters can be applied either on fields of the table that will be loaded, or on related tables at a higher level in the hierarchical model. This means that a table containing document rows can be filtered by fields in the document head (e.g., filtering by Document_Date), which will enable incremental refreshing of data. Both options use authentication via Basic identification (username and password). These access authorization parameters must be entered in both PowerBI Desktop and the PowerBI model published online. For a small database, it may be possible to skip the presets described below. However, as databases grow, BI models extend, and service configurations change, it becomes imperative to define initial parameters to be used throughout the entire BI project. Pre-defining and setting important common parameters The main parameters required for work are: RangeStart - System mandatory parameter when using incremental refresh, setting the start time for a subperiod RangeEnd - System required parameter when using incremental refresh, setting the end time for a subperiod TopCount - User parameter to facilitate project editing, containing the number of records to download baseURL - User parameter specifying a site (TableAPI) from which data is downloaded The RangeStart and RangeEnd parameters are of type Date/Time and must have values set so that preview data can be loaded when working with the model in PowerBI Desktop. The TopCount parameter is of type Decimal number and sets the number of records to be fetched with a single query. In the PowerBI Desktop development environment, this should be a relatively small value, such as 500, so that preview data can be loaded quickly. The baseURL parameter is of type Text and contains the address of the TableAPI site. It's good to define it this way because it can be easily changed from one location in the entire project should any change occur. For example, it could have the following value: \"https://test-tableAPI.erp.net\" Picture 1 Loading model information Select \"OData feed\" from the menu using the \"New source\" button. Fill in the data as shown in the picture (assuming we have defined the baseURL parameter as shown above). Picture 2 The available objects data will be loaded, allowing you to see what each one looks like. This is necessary to determine the field names you'll need to filter by or use when filtering by a reference field. The following picture shows what the Crm_Sales_Orders object looks like, particularly the field used to reference the document head needed for filtering (the Document_Reference field). Picture 3 You can choose to load data directly this way, as it supports additional filtering by fields in the table and selecting which fields to load. This method does NOT SUPPORT filtering by reference fields and is therefore not applicable if incremental refresh is to be used! Loading data via OData.Feed reading from source This method is suitable for testing only in PowerBI Desktop because it is NOT SUPPORTED by online PowerBI. It is described here as it provides basic insights into understanding and working with TableAPI queries. Some of the steps described below are also applicable to other data sources. General guidelines for operation are provided through the following points: Set the data source for each Query that uses TableAPI in the first step (Source) as follows: = OData.Feed(baseURL & \"/tableapi/odata/{Table_Name}{Parameters}\", null, [Implementation=\"2.0\"]) {Table_Name} - replaced with the name of the table to be loaded, e.g., Gen_Documents {Parameters} - replaced with OPTIONAL parameters to the query If access authorization is not set yet, you must select one with Basic type and specify the values of the \"User name\" and \"Password\" parameters for the user who has access to the TableAPI application. The parameter section (if present) must begin with a \"?\" symbol. Parameters are separated from one other by the \"&\" symbol. Possible parameters are: \"$filter=\" - Specifies the conditions that the returned data will meet \"$select=\" - Sets the fields to be returned by the query \"$top=\" - Sets the maximum number of records to return from the query Use permanent filtering. Add the appropriate filter in the URL using the options supported by TableAPI. An example of filtering table Gen_Document by active (Void=false) and released (State>=30) documents: let Source = OData.Feed(baseURL & \"/tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30\", null, [Implementation=\"2.0\"]) in Source To get this step code, you can add the following in the OData source URL (in addition to the one shown in picture 2): /tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30 Add filtering by fields with listed values. To the above example, you also need to add filtering by Entity_Name for values 'Inv_Transactions' and 'Crm_Sales_Orders': =OData.Feed(baseURL & \"/tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30 and Entity_Name in ('Inv_Transactions','Crm_Sales_Orders')\", null, [Implementation=\"2.0\"]) Note that TableAPI supports filtering by enumerated values, and this can be done directly from the PowerBI Desktop interface. Here is what the query generated by PowerBI Desktop looks like before adding the filtering: HTTP GET /tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30&$top=1000 This happens if the Void and State filterings for Gen_Documents, as well as Gen_Documents, are selected entirely through the interface. The steps generated in this process can be viewed in the Advanced editor: let Source = OData.Feed(baseURL & \"/tableapi/odata/\", null, [Implementation=\"2.0\"]), Gen_Documents_table = Source{[Name=\"Gen_Documents\",Signature=\"table\"]}[Data], #\"Filtered Rows\" = Table.SelectRows(Gen_Documents_table, each([Void] = false)), #\"Filtered Rows1\" = Table.SelectRows(#\"Filtered Rows\", each [State] >= 30) in #\"Filtered Rows1\" Through the interface, we can also add Entity_Name filtering as shown in the following picture: Picture 4 This will trigger the creation of the next step with code: = Table.SelectRows(#\"Filtered Rows1\", each([Entity_Name] = \"Crm_Sales_Orders\" or [Entity_Name] = \"Inv_Transactions\")) The following query will be executed to the data source, where the addition from this filtering is shown: HTTP GET /tableapi/data/Gen_Documents?$filter=Void eq false and State ge 30 and (Entity_Name eq 'Crm_Sales_Orders' or Entity_Name eq 'Inv_Transactions')&$top=1000 This example shows the support in the TableAPI filter construct: and (Field_Name eq 'Value1' or Field_Name eq 'Value2' ... or Field_Name eq 'ValueN') Everything described in this section can be used for nomenclatures that will be fully loaded or do not need filtering by reference fields. Filtering by date type fields. As an example, we will use the Document_Date field to select documents only from the first 6 months of the year: =OData.Feed(baseURL & \"/tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30 and Document_Date ge 2023-01-01T00:00:00Z and Document_Date le 2023-06-30T00:00:00Z\", null, [Implementation=\"2.0\"]) Note the date format 'YYYY-MM-DDThh:mm:ssZ' and respect it when using dates. Filter by referenced fields (fields from related tables that are not present in the current table). An example of such a query is filtering records from the Inv_Transactions table by taking only those for active (Void=false) and released (State>=30) documents: =OData.Feed(baseURL & \"/tableapi/odata/Inv_Transactions?$filter=Document_Reference/Void eq false and Document_Reference/State ge 30\", null, [Implementation=\"2.0\"]) This filtering is similar to the one in step 2, the only difference being a reference to the field by which we will filter. You can define the names of the fields pointing to reference tables as shown in picture 3. In order to support filtering by reference, this needs to be explicitly documented in the Table model documentation. Filter by fields from tables present in the Owner Tables Hierarchy list. Filtering by fields for tables present in the Owner Tables Hierarchy list described in the Table model documentation is always supported! Additionally, you can filter on a field that is not in a directly related table (located more than one level away in the hierarchy). For example, if we want to filter Inv_Transaction_Lines by a date of the document in which the rows are included (Document_Date field of Gen_Documents), we must pass through two consecutive references as shown in the example: =OData.Feed(baseURL & \"/tableapi/odata/Inv_Transaction_Lines?$filter=Transaction_Reference/Document_Date ge 2023-01-01T00:00:00Z and Transaction_Reference/Document_Reference/Document_Date le 2023-01-31T23:59:59Z\", null, [Implementation=\"2.0\"]) This is due to the hierarchical relationship between the tables, which follows a certain connectivity scheme (Field(Table) format): Transaction_Reference(Inv_Transaction_Lines) -> Transaction_Id(Inv_Transactions) Document_Reference(Inv_Transactions) -> Id(Gen_Documents) Filter data by the date of the document in which it is included. Using OData feed does NOT allow incremental refresh of data. The example below uses Web.Contents as a way to fetch data: =Json.Document(Web.Contents(baseURL & \"/tableapi/odata/Inv_Transaction_Lines\",[Query=[#\"$filter\" = \"Transaction_Reference/Document_Reference/Document_Date ge \" & DateTime.ToText(RangeStart,[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"]) & \" and Transaction_Reference/Document_Reference/Document_Date le \" & DateTime.ToText(Date.EndOfDay(Date.AddDays(RangeEnd,-1)),[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"])]], 65001) Since a comparison using 'le' (operator <=) must be used, the following statement calculates the correct end date of the period: Date.EndOfDay(Date.AddDays(RangeEnd,-1)) Important In the filter, you can use only: The logical operator 'and' The comparison operators 'eq', 'le', 'ge' The operator 'like' The comparison operator with list of values 'in' If a logical OR operator is needed in the filter, the query must be split into several separate queries that do not contain OR, which are then combined into a single query using \"Append queries\". An exception is the above-described statement for filtering by enumerated values of the type: **and (Field eq 'Value1' or Field eq 'Value2' ... or Field eq 'ValueN')** <br> which is equivalent to the standard supported statement: **and Field in ('Value1', 'Value2', ...,'ValueN')** <br> In PowerBI, it is possible to set up incremental updating. For this purpose, you must create two parameters (RangeStart, RangeEnd) of type DateTime whose values automatically change according to the incremental updating policy set for the specific object in PowerBI. Here, it is necessary to manually modify the query after the initial URL is set, because there is no way to add the information from the input parameters formatted in the desired way. Using incremental refresh to accelerate data updates in PowerBI To achieve filtering for lines and other tables by the Document_Date field of the document head, it is necessary to filter by a reference field. However, an incremental refresh problem will then arise. It is not possible to set the required filtering without manually setting parameters by which to filter, and PowerBI online does not support refreshing from the source that was set this way. It is imperative that you set the general parameters described at the beginning of this article before proceeding! Data loading via Web Content with the ability to filter by reference fields and compatibility with incremental refresh Let's apply the following approach: Use Web Content as data source Manually set all possible filters that should be applied in the data source to reduce the transferred data as much as possible Manually set the list of fields to be returned to reduce the amount of data Convert the returned data to JSON Convert the result to a table, after which other processings can continue It is easiest to use the example provided, which can be changed as needed. An example of data filtering for table Crm_Sales_Order_Lines_Table: let strEntity = \"Crm_Sales_Order_Lines\", strEntityHeadReference = \"Sales_Order_Reference\", strSelectFields = \"\", strEntHead = strEntityHeadReference & (if strEntityHeadReference = \"\" then \"\" else \"/\"), strDocHead = strEntHead & \"Document_Reference/\", strFilter = strDocHead &\"Void eq false and \" & strDocHead & \"State ge 30 and \" & strDocHead & \"Document_Date ge \" & strRangeStart &\" and \" & strDocHead & \"Document_Date le \"& strRangeEnd, strRangeStart = DateTime.ToText(DateTime.From(RangeStart),[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"]), strRangeEnd = DateTime.ToText(Date.AddDays(DateTime.From(RangeEnd),-1),[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"]), Source1 = Json.Document(Web.Contents(baseURL & \"/tableapi/odata/\" & strEntity, [Query=[#\"$filter\" = strFilter, #\"$select\" = strSelectFields, #\"$top\" = Text.From(TopCount)], Timeout=#duration(0, 2, 0, 0)]), 65001), ResultList = Source1[value], value = if List.NonNullCount(ResultList) = 0 then List.Union({ResultList, {null}}) else ResultList, #\"Converted to Table\" = Table.FromList(value, Splitter.SplitByNothing(), null, null, ExtraValues.Error), #\"Result\" = Table.ExpandRecordColumn(#\"Converted to Table\", \"Column1\", {\"Sales_Order_Id\", \"Line_No\", \"Product_Id\", \"Quantity\", \"Quantity_Unit_Id\", \"Product_Price_Id\", \"Unit_Price\", \"Line_Discount_Id\", \"Line_Standard_Discount_Percent\", \"Line_Custom_Discount_Percent\", \"Line_Amount\", \"Line_Store_Id\", \"Requested_Quantity\", \"Quantity_Base\"}, {\"Sales_Order_Id\", \"Line_No\", \"Product_Id\", \"Quantity\", \"Quantity_Unit_Id\", \"Product_Price_Id\", \"Unit_Price\", \"Line_Discount_Id\", \"Line_Standard_Discount_Percent\", \"Line_Custom_Discount_Percent\", \"Line_Amount\", \"Line_Store_Id\", \"Requested_Quantity\", \"Quantity_Base\"}) in #\"Result\" Add new table with incremental refresh capability (step-by-step) Switch to edit data sources mode (select from Home -> Queries -> Transform data). Create a new query (table) from Home -> New Source -> Blank Query. Then, navigate to Home -> Query -> Advanced editor to open the window in which the M code of the query is written. The result is as follows: Picture 5 Replace the text in the window with the above sample text (for Crm_Sales_Order_Lines_Table). Edit the value of the strEntityHeadReference variable with the reference field pointing to the new entity whose will be loaded. Edit the value of strEntity with the name of the new entity. If it will be loaded from the head of the entity, the field must be empty. If you are going to load Crm_Sales_Orders_Table, for example, edit the fields as follows: strEntity = \"Crm_Sales_Orders\", strEntityHeadReference = \"\", If it is loaded from Gen_Documents, then change the strDocHead to: strDocHead = \"\", Then, select the columns to be included in the table by deleting the last step of the conversions. Using the expanding feature (the yellow highlighted icon) from the \"Converted to Table\" step, we select the necessary fields as shown in the picture: Picture 6 This assumes that the string in strSelectFields is empty (strSelectFields=\"\"). If it is filled with certain fields like: strSelectFields=\"Sales_Order_Id, Customer_Id, Store_Id, Sales_Person_Id, Dealer_Id, Document_Currency_Id\", then only these will be visible, and only they will be returned from TableAPI, which will save time in data transfer and speed up loading. For this reason, specifying the field names to be returned by the query is highly recommended. Picture 7 There is one line in the code above: value = if List.NonNullCount(ResultList) = 0 then List.Union({ResultList, {null}}) else ResultList, which may seem redundant but is very important for the synchronization to run without error. It is used to check the returned result, and if no data is returned, an empty line is added. Missing data causes an error in the next steps of conversion to the tabular form in which we need the data. An error would occur if any information is missing in any incremental refresh period. Executing the code above will result in sending the following data fetch command: HTTP GET /tableapi/data/Crm_Sales_Orders?$filter=Document_Reference/Void eq false and Document_Reference/State ge 30 and Document_Reference/Document_Date ge 2015-01-01T00:00:00Z and Document_Reference/Document_Date le 2024-01-09T00:00:00Z&$select=Sales_Order_Id, Customer_Id, Store_Id, Sales_Person_Id, Dealer_Id, Document_Currency_Id&$top=500 The Document_Date filtering and the value of the $top parameter are determined by the parameters we have defined. This applies to PowerBI Desktop queries. When querying from online PowerBI with incremental update defined for the object, the parameter values will be automatically filled, and separate queries will be generated and executed for each update period. Once the project is published to PowerBI, the first thing to set is chaning TopCount parameter to a large enough value, for example 500000000. After that, a manual Refresh can be run at an appropriate time as this will cause the data to be fully loaded (from the processing period set in the incremental refresh). Let's also pay attention to the Timeout parameter set in this sample query: Timeout=#duration(0, 2, 0, 0) It is used to set the timeout of a single data download request. The above setting changes it to 2 hours. This is the maximum time given to one request (each incremental period) at a time. In PowerBI, this value defaults to 600 seconds, which can be insufficient, especially during the initial data load when the archive period data is loaded. The default time for a single query may not be enough if the settings are as follows: Picture 8 Archival data periods will be 1 year in size. This means the amount of data to be loaded will be very large, and the query will be slow to execute. We need to increase the timeout, as we have done in the example, or change the period to an equivalent but with a smaller size. We can set the following: Archive data starting 60 Month before refresh date which is equivalent to the above settings, but the period of data processed with one query will be one month. This will reduce the execution time and the probability of timeout of single queries on initial data load. The archive period data is loaded once on the first Refresh after the project is published. Data loading in the periods defined by Incrementally refresh data is done on each Refresh, but the refresh time will not increase proportionally to the total data in the database - rather, to the volume of data in the periods being processed. The use of TableAPI allows multiple queries to pull data from the database simultaneously without overloading the server and disrupting the primary operations. Optimized loading of custom properties Custom properties are also used in the analyses performed in PowerBI. Since their volume is significant, it is very important for them to be loaded and used efficiently. Optimized loading of all necessary properties For this purpose, we use the following code defining a query named Gen_Property_Values: let Source = OData.Feed(baseURL & \"/tableapi/odata/\", null, [Implementation=\"2.0\"]), Gen_Property_Values_table = Source{[Name=\"Gen_Property_Values\",Signature=\"table\"]}[Data], #\"Filtered Rows1\" = Table.SelectRows(Gen_Property_Values_table, each ([Property_Id] = \"18eb8480-a19b-4336-b935-c2715730f988\" or [Property_Id] = \"28e65696-2d8e-4e22-9932-686737235d88\" or [Property_Id] = \"41324c1d-6f64-4fa3-85e4-4c99fcf4f407\" or [Property_Id] = \"46d58fad-4ef2-409e-ba92-b5c55f7ea20b\")), #\"Removed Other Columns\" = Table.SelectColumns(#\"Filtered Rows1\",{\"Entity_Item_Id\", \"Property_Id\", \"Property_Value\", \"Description\"}), #\"Filtered Rows\" = Table.Buffer(#\"Removed Other Columns\") in #\"Filtered Rows\" In this example, the four GUID feature numbers listed are randomly selected. You need to replace and supplement them with the IDs of the properties you need. The construct: ... or [Property_Id] = \"Guid\" can be reduced or expanded with more members. Note the following operation: #\"Filtered Rows\" = Table.Buffer(#\"Removed Other Columns\") It specifies that the data will be statically buffered in memory. In the next operations that use as a source Gen_Property_Values (the query we define), data will be retrieved from the buffer in the memory which will save significant re-fetching time. Another optimization comes from loading only the required fields listed in the Table.SelectColumns operation. This reduces the returned data and speeds up the query. This is possible thanks to the Folding support which is active when using an OData feed data source. Dividing the loaded properties by entities to which they refer The processing can continue by creating a new query (e.g., Entity1_Property_Values) with the following code: let Source = Gen_Property_Values, #\"Filtered Rows\" = Table.SelectRows(Source, each ([Property_Id] = \"41324c1d-6f64-4fa3-85e4-4c99fcf4f407\" or [Property_Id] = \"46d58fad-4ef2-409e-ba92-b5c55f7ea20b\") and ([Property_Value] <> null and [Property_Value] <> \"\")), #\"Added Custom\" = Table.AddColumn(#\"Filtered Rows\", \"Param1\", each if [Property_Id]=\"41324c1d-6f64-4fa3-85e4-4c99fcf4f407\" then [Property_Value] else null), #\"Added Custom1\" = Table.AddColumn(#\"Added Custom\", \"Param2\", each if [Property_Id] = \"46d58fad-4ef2-409e-ba92-b5c55f7ea20b\" then [Property_Value] else null), #\"Added Custom2\" = Table.AddColumn(#\"Added Custom1\", \"Descr1\", each if [Property_Id] = \"41324c1d-6f64-4fa3-85e4-4c99fcf4f407\" then [Description] else null), #\"Added Custom3\" = Table.AddColumn(#\"Added Custom2\", \"Descr2\", each if [Property_Id]=\"46d58fad-4ef2-409e-ba92-b5c55f7ea20b\" then [Description] else null), #\"Grouped Rows\" = Table.Group(#\"Added Custom3\", {\"Entity_Item_Id\"}, {{\"Par1\", each List.Max([Param1]), type nullable text}, {\"Descr1\", each List.Max([Descr1]), type nullable text}, {\"Par2\", each List.Max([Param2]), type nullable text}, {\"Descr2\", each List.Max([Descr2]), type nullable text}}) in #\"Grouped Rows\" In the first step, select the Gen_Property_Values query created earlier as the data source, which will buffer the data load. The next step performs filtering, taking the values of only two of the properties that apply to a single entity to optimize and reduce the data to process. They must not be null or empty (\"\"). If needed, the filtering list can be expanded or reduced according to the properties being processed and already loaded by the previous query. In the following steps, new columns are created that contain only values for a particular Property_Id. This is necessary to prepare data for grouping by Entity_Item_Id, which will convert the table into one with no more than one row for each entity. Afterwards, you can link it to the entity table to which the custom properties apply. These steps must be edited or completed for the specific Property_Id that are processed. As a final step, grouping by Entity_Item_Id is performed and data is ready to be associated with the entity data it refers to. If you add the link to the same query, the linking dialog would look something like this: Picture 9 The link must be Outher (not all records in the entity table have a match in the table with feature values), and in this case, it is Right because the base table where all data is stored is second (named Documents_ODATA). If we add the properties in Entity1_Property_Values to Documents_ODATA, then we would have a Join Kind of type Left Outer. Warning Reading data from the Gen_Property_Values_Table is always slow because it triggers a scan (full crawl) of the table, which is very large. This has a very negative impact on the SQL server and slows down the updating of PowerBI. Therefore, it is imperative to follow the recommended approach shown here! There may be other optimal methods, but the table scanning and large execution time of a query should always be considered. The only exception might be if you filter by a list of values for Entity_Item_Id, in which case the query will execute quickly as it will use SEEK in the database. However, due to the nature of BI, this option is likely not practical. When reading custom properties, there is no way to filter by the date of the document they refer to and therefore no way to use incremental refresh. That is why the example uses the standard OData feed as a data source. PowerBI setup after uploading the project These settings are required to set the access rights when connecting to the data source (in this case, TableAPI). It is important to configure the correct values for these settings to avoid creating additional problems and disturbances when loading the data. For each source (table) read from TableAPI when using the WEB Content access method, it is necessary to set the rights separately. For a source using OData Feed, the necessary access rights are set once. Only the Basic authentication method is supported! Picture 10 For these settings, it is necessary to check the \"Skip test connection\" box, as shown in the picture: Picture 11 For the OData source, you may leave this box empty. It is even advisable to first set the access for the OData source with an empty check box, verifying that the correct credentials (user, password) are set. If there is a problem, you will receive a notification. If everything is alright, you can proceed to configure the access for the other sources in the same way, but with the check box selected. As of version 23.2 SP4, it is no longer necessary to uncheck \"Skip test connection\", because the system behavior when disconnecting from TableAPI has been adjusted. Before the first run which loads the data after uploading the project, it is necessary to set the \"TopCount\" parameter to a value that does not limit the volume of the loaded data (e.g. 500000000, as shown in the picture). Be careful not to set a too large value for the parameter. The maximum allowed value is 2^31 (MAXINT), after which the query will return an error. Picture 12 If for whatever reason the data source has been renamed, this can be easily corrected here by changing the \"baseURL\" parameter to match the correct one, without needing to make project corrections and re-uploads. Conclusion Through these techniques, you are ready to take advantage of PowerBI's incremental refresh capability, which makes the refresh time relatively constant and proportional to the growth of data in the last selected refresh periods. This capability has been tested in practice with 4 parallel connections, which did not lead to a significant load on the TableAPI site, AppServer, or SQL Server. We can assume that Refresh even with 5-10 connections will still be within the permissible load limits and will not significantly affect the system's performance. However, it is best to track the specific refresh process to determine its impact and the load it causes. This will make it possible to choose appropriate values for the number of parallel refresh requests that are possible without interfering with the normal system operations."
  },
  "topics/table-api/usage-guide.html": {
    "href": "topics/table-api/usage-guide.html",
    "title": "Recommendations for using TableAPI as a data source for BI | ERP.net Developer Docs",
    "summary": "Recommendations for using TableAPI as a data source for BI Respecting the technical capabilities of the TableAPI, such as its filtering and data presentation capabilities, is necessary to ensure fast, efficient, and trouble-free operation. To achieve this, the following recommendations should be followed: Select only the necessary tables from which you will load data. Filter the table as early as possible by using solid constraints that the data must meet. Negative constructions, OR statements, and unsupported types of filtering should not be used. This should be aligned with the documentation for each field being filtered. For example, do not use \"<>\", \"<\", \">\", \"OR\", \"NOT\" as they are not supported. The supported constructions are \"AND\" ,\"=\" (including \"= null\"), \"<=\", \">=\". Remove unnecessary fields as early as possible. Here it matters whether you choose \"Remove other columns\" or \"Remove columns\" (different functions, where one keeps the listed columns and the other removes them). Use the former (\"Remove other columns\"), which will ensure that if there is a modification in the table structure, the result will remain the same. Supplement the data (add rows) from other sources if more complex data filtering containing OR clauses is required. All OR-separated filters should be divided into several sub-filters, where each sub-filter requires a separate query to the same table with the respective sub-filter. Finally, all these sub-queries should be combined into one table by appending queries. When filtering data based on related tables (filter is not on a field from the current table), use table merging (Merge queries), where the main table to which you are making a connection should already be filtered, and use the \"Inner join - only matching rows\" type of join. For example, if you need to filter only certain documents from Crm_Sales_Orders, you should first filter Gen_Documents for the desired documents (based on Entity_Name, Void, State, Document_Date, etc.), and then merge Crm_Sales_Orders with Gen_Documents using an Inner join and specifying the corresponding fields Document_Id (Crm_Sales_Orders) -> Id (Gen_Documents). If the tables have a relatively small volume (number of records), you may not need to follow the above filtering recommendations, as in that case, the entire table will likely be loaded into BI, and the filtering will be applied afterwards by BI."
  },
  "whats-new/index.html": {
    "href": "whats-new/index.html",
    "title": "What’s New in ERP.net | ERP.net Developer Docs",
    "summary": "What’s New in ERP.net The What’s New section highlights the latest updates and improvements for developers working with ERP.net. It includes detailed information about changes to the API, Data Model, and other developer-focused components. This page provides a clear overview of technical modifications, schema updates, and integration enhancements — helping developers stay aligned with the latest platform capabilities. You can explore the version-specific threads to review changes, migration notes, and new development tools introduced in each release. Version 26.2"
  },
  "whats-new/v26-2/index.html": {
    "href": "whats-new/v26-2/index.html",
    "title": "Version 26.2 | ERP.net Developer Docs",
    "summary": "Version 26.2 TBD"
  }
}