{
  "README.html": {
    "href": "README.html",
    "title": "Welcome to the ERP.net Developer Documentation | ERP.net Developer Docs",
    "summary": "Welcome to the ERP.net Developer Documentation The documentation uses DocFX to build."
  },
  "auth/client-libraries.html": {
    "href": "auth/client-libraries.html",
    "title": "OAuth2 and OpenID Connect Client Libraries | ERP.net Developer Docs",
    "summary": "OAuth2 and OpenID Connect Client Libraries ERP.net uses standard OAuth 2.0 and OpenID Connect (OIDC) protocols for authentication and authorization. You can connect using any compliant client library - no proprietary SDK is required. Supported Standards ERP.net Identity implements: OAuth 2.0 Authorization Framework (RFC 6749) OpenID Connect Core 1.0 (openid.net/specs/openid-connect-core-1_0.html) PKCE (Proof Key for Code Exchange) (RFC 7636) OpenID Discovery Document Available at: https://<your-instance>.my.erp.net/id/.well-known/openid-configuration Any library or framework that supports these standards will work with ERP.net. Choosing a Library You can use either a generic OAuth2/OIDC library or a framework-integrated solution. Choose one that matches your environment and flow type. Platform Recommended Libraries Notes .NET / C# IdentityModel, Microsoft.Identity.Client (MSAL) Full OAuth2 + OIDC support JavaScript / SPA oidc-client-ts, Auth.js / NextAuth Built-in PKCE and redirect handling Python Authlib, requests-oauthlib Simple flow helpers Java / Spring Spring Security OAuth2 Client Integrated token management PHP League OAuth2 Client Clean API for Auth Code and Client Credentials Node.js (backend) simple-oauth2, openid-client Handles tokens and discovery automatically Go golang.org/x/oauth2 Minimal and reliable Swift / iOS AppAuth-iOS Native OIDC flow with PKCE Android / Kotlin AppAuth-Android Official OIDC SDK for Android Example: Using IdentityModel (C#) using IdentityModel.Client; using System.Net.Http; // Discover endpoints from metadata var client = new HttpClient(); var disco = await client.GetDiscoveryDocumentAsync(\"https://your-instance.my.erp.net/id\"); if (disco.IsError) throw new Exception(disco.Error); // Request token using Client Credentials. var tokenResponse = await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest { Address = disco.TokenEndpoint, ClientId = \"myapp\", ClientSecret = \"supersecret\", Scope = \"read update\" }); Console.WriteLine(tokenResponse.AccessToken); Example: Using oidc-client-ts (JavaScript SPA) import { UserManager } from \"oidc-client-ts\"; const settings = { authority: \"https://your-instance.my.erp.net/id\", client_id: \"myapp\", redirect_uri: \"https://app.example.com/auth/callback\", response_type: \"code\", scope: \"openid profile read update\", }; const userManager = new UserManager(settings); await userManager.signinRedirect(); // Redirects to ERP.net login page Example: Using requests-oauthlib (Python) from requests_oauthlib import OAuth2Session client_id = \"myapp\" client_secret = \"supersecret\" token_url = \"https://your-instance.my.erp.net/id/connect/token\" oauth = OAuth2Session(client_id) token = oauth.fetch_token( token_url=token_url, client_id=client_id, client_secret=client_secret, scope=[\"read\", \"update\"] ) print(token[\"access_token\"]) Notes for ERP.net Developers All token requests and authorizations must go through your instance's Identity (/id path). Always request scopes explicitly (read, update, etc.). Use PKCE for public apps that cannot store secrets. Never hardcode client secrets in browser code or mobile apps. Refresh tokens are supported for interactive apps. For service integrations, prefer Client Credentials flow - simpler and more stable. Testing and Debugging You can safely test authentication flows in: https://<your-instance>.my.erp.net/id/.well-known/openid-configuration Use tools like Postman, curl, or jwt.io to: Inspect tokens Validate scopes and claims Check expiration and issuer View key rotation metadata (JWKS) Learn More OAuth 2.0 Overview Understand the core principles behind ERP.net authentication. ERP.net Identity Learn how ERP.net issues and validates tokens. Auth Flows Overview Explore the different OAuth flows for interactive, service, and hybrid apps. Access Tokens See how tokens are structured and used to access APIs. Reference Access Tokens (PAT, SAT) Learn how to use long-lived tokens for integrations and automation."
  },
  "auth/concepts/erpnet-as-external-idp.html": {
    "href": "auth/concepts/erpnet-as-external-idp.html",
    "title": "Using ERP.net Identity for SSO | ERP.net Developer Docs",
    "summary": "Using ERP.net Identity for SSO ERP.net Identity can act as a fully compliant OpenID Connect (OIDC) identity provider for any external application - web, desktop, mobile, or service-based. Integrating with it allows your application to authenticate users using their ERP.net accounts and receive industry-standard identity and access tokens (ID token, access token, refresh token). This guide explains how an application can connect to ERP.net Identity and use it as an external identity provider. Note This page describes the ERP.net global identity provider (https://id.erp.net/id) used when ERP.net acts as an external Identity Provider (SSO/sign-in) for your application. It is not the mechanism for per-instance API access. To call the APIs of a specific ERP.net instance, use the Instance Identity Service (https://{instance}.my.erp.net/id) and configure a Trusted Application in that instance. If you’re unsure which authority applies, see Choose an identity authority (instance vs global). When to Use ERP.net as an External IdP Use ERP.net as the Identity Provider when: Your application needs to authenticate users with their ERP.net accounts You want single sign-on (SSO) between ERP.net and other systems You do not want to manage user passwords yourself You want standardized identity data via OIDC claims ERP.net supports standard OAuth 2.0 + OIDC flows, so any OIDC-compatible framework or library can integrate with it. Quick Start (Platform-Agnostic) To integrate your application with ERP.net Identity, configure an OIDC client with the following parameters: Required settings Authority https://id.erp.net/id (or your tenant-specific ERP.net Identity URL) Client ID (provided by ERP.net) Client Secret (provided by ERP.net; confidential clients only) Scopes openid profile (optional) offline_access (refresh tokens) Response type code id_token Login callback (redirect URI) URL where ERP.net redirects after successful login. Logout callback URL where ERP.net redirects after logout. Example: ASP.NET Core (Confidential Web App) .AddOpenIdConnect(\"ErpNet\", options => { options.Authority = \"https://id.erp.net/id\"; options.ClientId = \"<your-client-id>\"; options.ClientSecret = \"<your-client-secret>\"; options.ResponseType = \"code id_token\"; options.CallbackPath = \"/signin-erpnet\"; options.SignedOutCallbackPath = \"/signout-erpnet\"; options.Scope.Add(\"openid\"); options.Scope.Add(\"profile\"); options.Scope.Add(\"offline_access\"); options.GetClaimsFromUserInfoEndpoint = true; options.SaveTokens = true; }); Redirect / Callback URLs Your integration must define: Login Callback URL ERP.net Identity redirects here after user authentication. Logout Callback URL Used for federated sign-out and user session cleanup. Both URLs must be registered inside ERP.net Identity for your specific client application. Claims After authentication, your application receives standard OIDC user claims, such as: sub name preferred_username email Additional custom ERP.net claims may also be available depending on configuration. Required ERP.net Client Application (Important) To authenticate against ERP.net Identity, your application must be registered as an OIDC client inside ERP.net. The ERP.net team must configure: Client ID Client Secret (for confidential clients) Allowed redirect URLs Allowed logout URLs Allowed scopes PKCE / confidential client settings Token lifetimes These settings are specific to your app and are not public. How to Obtain a Client ID and Secret Contact ERP.net Support or your ERP.net system administrator and request a new OIDC client application. Provide: Your login callback URL(s) Your logout callback URL Required scopes (API access, offline access, etc.) Whether your application is: a public client (SPA, mobile, desktop - no client secret), or a confidential client (server-side - requires secret) Once the ERP.net team creates the client, you will receive the credentials needed for integration. Summary ERP.net Identity is a standards-based OIDC provider. To authenticate users with ERP.net: Register your application as an OIDC client inside ERP.net Configure your application with the provided Client ID and (if applicable) Client Secret Use https://id.erp.net/id as the authority Register correct login and logout callback URLs Use OIDC claims to identify the user This allows your application to authenticate users securely through ERP.net using standard OpenID Connect protocols."
  },
  "auth/concepts/identity-authorities.html": {
    "href": "auth/concepts/identity-authorities.html",
    "title": "Identity authorities (instance vs global) | ERP.net Developer Docs",
    "summary": "Identity authorities (instance vs global) When building ERP.net apps and integrations, it's important to choose the correct identity authority (the OAuth 2.0 / OIDC \"issuer\"). ERP.net supports two different identity setups, which are used for different goals. This page explains which authority to use, where the client is registered, and what the issued tokens are meant for. Quick decision You want to… Use this authority Client registration / where you configure access Call the APIs of a specific ERP.net instance (Domain API / Table API) Instance Identity Service: https://{instance}.my.erp.net/id Configure a Trusted Application inside that ERP.net instance (incl. scopes/access rules) Enable SSO / sign-in to your external application using ERP.net accounts ERP.net global IdP: https://id.erp.net/id Client registration is managed centrally (see the external IdP page for the process/requirements) Instance Identity Service (per ERP.net instance) Use this when your app must access data or operations in a particular ERP.net instance. Authority (issuer): https://{instance}.my.erp.net/id Audience: tokens are intended for that same instance's APIs Where the client is registered: in the same ERP.net instance, as a Trusted Application The client_id corresponds to the Trusted Application identifier (see the Trusted Applications page for the exact rule used in ERP.net). Typical use cases: Background integration/service (sync, automation, ETL) Internal app/portal that needs to call the instance APIs Any scenario where API access must be controlled per instance and per scope See: Instance Identity Service and Trusted Applications. ERP.net global identity provider (external IdP) Use this when ERP.net must act as an external identity provider for your application (SSO/sign-in), not when your primary goal is \"call a specific instance API\". Authority (issuer): https://id.erp.net/id Primary purpose: user authentication / SSO for external applications Where the client is registered: centrally (not via instance Trusted Applications) Typical use cases: Your application needs users to sign in with their ERP.net identity You want OIDC login and user claims issued by ERP.net as an IdP See: ERP.net as an external Identity Provider. Common pitfalls (and how to avoid them) Mixing client registrations: A client registered as a Trusted Application is instance-scoped and applies to the instance Identity Service. It is not the same as a client registered for the global IdP. Using the wrong authority URL: If you need to call a specific instance API, always start from that instance’s authority (https://{instance}.my.erp.net/id), not the global one. Unclear \"ERP.net Identity\" wording: In ERP.net docs, always interpret \"Identity\" in context: \"Instance Identity Service\" -> per-instance API access \"External IdP\" (id.erp.net) -> SSO/sign-in for external apps See also OAuth 2.0 Instance Identity Service ERP.net as an external Identity Provider Trusted Applications and Access Control Scopes"
  },
  "auth/concepts/identity-server.html": {
    "href": "auth/concepts/identity-server.html",
    "title": "ERP.net Identity | ERP.net Developer Docs",
    "summary": "ERP.net Identity Every ERP.net instance includes a built-in Identity that acts as its authentication and authorization authority. It handles sign-in, token issuance, and access control for all users, apps, and services that connect to the instance. Note This page describes the Instance Identity Service (https://{instance}.my.erp.net/id) used to obtain tokens for accessing a specific ERP.net instance's APIs. If you're unsure which authority applies, see Choose an identity authority (instance vs global). If you need ERP.net to act as an external IdP for SSO into your application, see ERP.net as an external Identity Provider. What the ERP.net Identity does ERP.net Identity is responsible for: Authenticating users and service accounts Applying instance-level security and sign-in policies Issuing OAuth 2.0 tokens used to access ERP.net APIs Managing logout and session lifecycles Think of it as the gatekeeper of an ERP.net instance: it verifies who is requesting access, confirms what they are allowed to do, and issues a signed token if the request is permitted. Note ERP.net Identity acts as both an authorization server (issuing tokens) and an authentication server (verifying credentials). ERP.net Identity location Each ERP.net instance hosts its own ERP.net Identity, typically available at: https://{instance-root}/id For example, ERP.net Identity for the testdb instance is: https://testdb.my.erp.net/id You can discover this automatically through the system's discovery endpoint (see below). Discovering the ERP.net Identity Every ERP.net instance exposes an auto-discovery endpoint that lists all available sites and services - including ERP.net Identity, Domain API, and other functional components. This allows developers (and tools) to dynamically determine where to send authentication and API requests. Request: GET https://{instance-root}/sys/auto-discovery GET https://testdb.my.erp.net/sys/auto-discovery Response (truncated): { \"WebSites\": [ { \"Type\": \"ID\", \"Status\": \"Working\", \"Url\": \"https://testdb.my.erp.net/id\" }, { \"Type\": \"DomainAPI\", \"Status\": \"Working\", \"Url\": \"https://testdb.my.erp.net/api\", \"AdditionalProperties\": { \"ODataServiceRoot\": \"https://testdb.my.erp.net/api/domain/odata/\" } } ] } This tells you that the instance's ERP.net Identity is active at /id, and that the Domain API is available at /api. Standard endpoints ERP.net Identity exposes the standard OAuth 2.0 and OpenID Connect endpoints. The most commonly used ones are: 1) Discovery endpoint The discovery endpoint provides metadata about ERP.net Identity - including its issuer name, supported scopes, signing keys, and the exact URLs for authentication, token exchange, and logout. This information helps client libraries and apps automatically configure themselves without hardcoding endpoints. Request: GET https://{instance-root}/id/.well-known/openid-configuration GET https://testdb.my.erp.net/id/.well-known/openid-configuration Example response (truncated): { \"issuer\": \"https://testdb.my.erp.net/id\", \"authorization_endpoint\": \"https://testdb.my.erp.net/id/connect/authorize\", \"token_endpoint\": \"https://testdb.my.erp.net/id/connect/token\", \"end_session_endpoint\": \"https://testdb.my.erp.net/id/connect/endsession\", \"jwks_uri\": \"https://testdb.my.erp.net/id/.well-known/openid-configuration/jwks\", \"response_types_supported\": [ \"code\", \"token\", \"id_token\", \"code id_token\" ], \"grant_types_supported\": [ \"authorization_code\", \"client_credentials\", \"refresh_token\" ], \"scopes_supported\": [ \"openid\", \"profile\", \"offline_access\", \"update\" ] } Key properties: issuer - The base URL identifying ERP.net Identity. Used to validate tokens issued by this instance. authorization_endpoint - The URL where interactive user logins begin (used in the Authorization Code flow). token_endpoint - The URL used by apps to exchange authorization codes or client credentials for access tokens. end_session_endpoint - The logout URL used to terminate user sessions and trigger single sign-out. jwks_uri - Location of the public signing keys used to validate tokens issued by this ERP.net Identity. grant_types_supported - Lists which OAuth 2.0 grant types (flows) are available. scopes_supported - Lists available permission scopes that can be requested in tokens. Note The discovery document is automatically generated by each instance's ERP.net Identity and always reflects its current configuration. Applications should use it dynamically rather than hardcoding endpoints. Note Client libraries typically fetch this automatically to configure themselves. 2) Authorize endpoint Starts an interactive sign-in and authorization request. Used by apps that act on behalf of a user (Authorization Code flow). GET https://{instance-root}/id/connect/authorize Example request: GET https://testdb.my.erp.net/id/connect/authorize? client_id=MyApp& redirect_uri=https%3A%2F%2Fmyapp.com%2Fcallback& response_type=code& scope=openid%20profile%20offline_access& state=xyz123 After successful sign-in, the browser is redirected to redirect_uri with an code parameter that the app will exchange for tokens. 3) Token endpoint Exchanges an authorization code or client credentials for access tokens (and refresh tokens where applicable). POST https://{instance-root}/id/connect/token Example: exchange authorization code: POST /id/connect/token Content-Type: application/x-www-form-urlencoded client_id=MyApp& client_secret=secret& grant_type=authorization_code& code=abc123& redirect_uri=https%3A%2F%2Fmyapp.com%2Fcallback Example response: exchange authorization code: { \"access_token\": \"eyJhbGciOi...\", \"token_type\": \"Bearer\", \"expires_in\": 3600, \"refresh_token\": \"df9834jf...\", \"scope\": \"openid profile offline_access\" } Example: client credentials: POST /id/connect/token Content-Type: application/x-www-form-urlencoded client_id=MyServiceApp& client_secret=secret& grant_type=client_credentials& scope=update Example response: client credentials: { \"access_token\": \"eyJhbGciOi...\", \"token_type\": \"Bearer\", \"expires_in\": 3600, \"scope\": \"read update\" } Note Refresh tokens are issued only for suitable interactive confidential clients using Authorization Code flow. They are not issued for Client Credentials. 4) End session endpoint Triggers logout and single sign-out across participating apps. GET https://{instance-root}/id/connect/endsession Example: end session: GET https://testdb.my.erp.net/id/connect/endsession? id_token_hint=eyJhbGciOi...& post_logout_redirect_uri=https%3A%2F%2Fmyapp.com%2Flogout-complete Internal and external users ERP.net Identity can authenticate both: Internal users - Licensed users who can open sessions and access instance data through APIs. Internal users can obtain access tokens for Domain API and Table API, depending on scopes and permissions. External users - Community or customer users who can authenticate but typically cannot access data APIs directly. For these users, ERP.net Identity issues identity tokens for sign-in to external-facing apps (for example, portals), but not API-access tokens for Domain API or Table API. Typical flows at a glance Authorization Code - Interactive apps acting on behalf of a signed-in user. The app redirects to ERP.net Identity, gets a code, exchanges it for tokens. Client Credentials - Service or background apps acting as themselves. The app directly requests a token from ERP.net Identity using its client credentials. Reference tokens (API keys: PAT/SAT) - Opaque, manually issued tokens that represent long-lived delegated access. They are looked up by the instance on each request. Quick reference Purpose Path Used for Discovery /.well-known/openid-configuration Fetch metadata and endpoint locations Authorize /connect/authorize Start user sign-in and obtain an authorization code Token /connect/token Exchange code or credentials for tokens End session /connect/endsession Log out and propagate single sign-out All paths are relative to https://{instance-root}/id. Learn More OAuth 2.0 How apps obtain and renew tokens, and how delegated access is granted. Trusted Applications and Access Control How an app is registered, identified, and granted permissions within an instance. Authentication and Authorization Overview The big-picture view of how apps authenticate and authorize with ERP.net."
  },
  "auth/concepts/oauth2-overview.html": {
    "href": "auth/concepts/oauth2-overview.html",
    "title": "OAuth 2.0 | ERP.net Developer Docs",
    "summary": "OAuth 2.0 ERP.net uses a combination of security mechanisms, including OAuth 2.0 authorization flows, to allow applications to access its APIs without directly handling user credentials. OAuth 2.0 separates authentication from authorization, allowing an app to act on behalf of a user or as a service, under explicitly granted permissions. Note Internally, ERP.net may use OpenID Connect for user identity. External developers only need standard OAuth 2.0 concepts and flows described here. Why OAuth 2.0 Historically, applications asked for usernames and passwords and then called APIs directly. This is risky and hard to control. OAuth 2.0 replaces passwords with access tokens issued by a trusted authority, so apps can: Authenticate securely via the ERP.net Identity Request only the permissions they need Call APIs with a verifiable token instead of user credentials Be audited and revoked centrally Note In ERP.net, the trusted authority that issues and validates tokens is the built-in ERP.net Identity within each instance. Core Roles Client (App) - Your application that requests access. In ERP.net it is registered as a Trusted Application. Resource Owner (User or Organization) - The entity that owns the data. Authorization Server - The ERP.net Identity that issues tokens after successful authentication and authorization. Resource Server - The ERP.net APIs that validate tokens and enforce permissions. Note ERP.net Identity also acts as an authentication server, verifying user or service credentials before any tokens are issued. Supported Grants in ERP.net ERP.net supports the standard OAuth 2.0 grants used by modern applications. Note A grant in OAuth 2.0 is the method an application uses to obtain an access token. Different grant types define how the app proves who it is and whether a user is involved in the process. Authorization Code Used by interactive apps that act on behalf of a signed-in user. Typical clients: web apps, SPAs using a backend, mobile apps with a web view Properties: User is redirected to the ERP.net Identity to sign in App receives an authorization code, then exchanges it for an access token Can support refresh tokens for confidential clients When to use: any app with a user interface and user-specific access sequenceDiagram participant User participant App participant IdentityServer as ERP.net Identity participant API as ERP.net API User->>App: Open app and choose \"Sign in\" App->>IdentityServer: Redirect to /authorize with client_id and scopes IdentityServer->>User: Prompt for login and consent User->>IdentityServer: Enter credentials IdentityServer->>App: Redirect back with authorization code App->>IdentityServer: Exchange code for access token IdentityServer->>App: Return access token App->>API: Call API using access token API->>App: Return protected data Note Note: This flow is used by web apps, SPAs, and desktop clients that require user authentication and access on behalf of that user. Client Credentials Used by service or background apps that act as themselves, not a user. Typical clients: integrations, schedulers, background workers Properties: No user interaction App authenticates as a configured service identity in its Trusted Application record When to use: automation and system-to-system integration Note In ERP.net, client-credentials access is governed by the app's Trusted Application configuration (e.g., service permissions). Refresh tokens are not issued for the client credentials grant; request a new access token when needed. sequenceDiagram participant App participant IdentityServer as ERP.net Identity participant API as ERP.net API App->>IdentityServer: POST /token (grant_type=client_credentials, client_id, client_secret) IdentityServer-->>App: Access token (service context) App->>API: Call API with access token (Authorization: Bearer ...) API-->>App: Return authorized response Note A single app can use both models when appropriate. For example, a web app may sign in users via Authorization Code flow, and also perform background synchronization via Client Credentials. Tokens at a Glance Access token - A signed artifact presented to ERP.net APIs to prove authorization Refresh token - A long-lived token that allows obtaining new access tokens without user interaction Reference token (API key) - An opaque, manually issued token that represents long-lived delegated access (either user-based as a PAT or service-based as a SAT) Scopes - Named permissions that describe what the token allows In ERP.net, issuing an access token does not automatically create a session. The token itself is only a signed proof of granted access. A session is created (or reactivated) only when that token is first used to call an API within the instance. See Sessions for details about session behavior and licensing. Refresh tokens Issued only to appropriate interactive confidential clients using Authorization Code flow Not issued for Client Credentials flow See Token Lifetime and Renewal for renewal behavior and policies Reference Access Tokens (API Keys) Reference tokens are opaque, long-lived API keys issued explicitly for an app. They are not self-contained JWTs; the instance resolves them to a session at use time. Lifetime: Long-lived, set manually at issuance (until revoked or expired). Scopes: Limited to the permissions granted to the app (and, for PAT, the user). Best for: Scripts, CI/CD, headless integrations where browser sign-in isn't practical. Security: Store securely, rotate regularly, and revoke immediately if exposed. Types PAT (Personal Access Token): Tied to a specific user; calls run with that user's permissions. SAT (Service Access Token): Tied to a service identity; calls run with the app's service context. Note Because they are reference (opaque) tokens, the ERP.net instance looks them up on each request and enforces current policies, scopes, and revocations. Scopes and Permissions Scopes describe what an issued token is allowed to do. They are requested by the app and evaluated by the instance when issuing tokens. See Scopes and Permissions for details and examples. High-level Flow sequenceDiagram participant App participant IdentityServer as ERP.net Identity participant API as ERP.net APIs App->>IdentityServer: Request authorization (Authorization Code or Client Credentials) IdentityServer-->>App: Issue access token (and refresh token if applicable) App->>API: Call API with access token API-->>App: Return authorized data How OAuth 2.0 Fits into ERP.net Your app is registered as a Trusted Application in the target ERP.net instance. The app uses an OAuth 2.0 flow to authenticate with ERP.net Identity. ERP.net Identity issues a token that encodes the identity and allowed scopes. The app calls ERP.net APIs with that token, and the APIs enforce permissions. This model keeps credentials out of applications, centralizes access control, and makes every call auditable. OAuth 2.0 Quick Reference Flow Who Authenticates Interaction Type Token Lifetime Refresh Token Support Typical Use Case Authorization Code User Interactive (browser or web view) Short-lived access token Yes Web apps, mobile apps, SPAs with backend Client Credentials Application (service identity) Non-interactive Short-lived access token No Integrations, background jobs, automations Authorization Code + Refresh User Interactive with silent renewal Access token + long-lived refresh token Yes Long-running web or desktop sessions Reference Token (API Key) User (PAT) or Service (SAT) Non-interactive Long-lived, manually defined No CI/CD pipelines, scripts, or integrations without user login Basic Authentication (legacy) User Interactive Session-based No Legacy SDK or direct API integrations (not recommended) Note All flows rely on the same ERP.net Identity, which validates credentials, applies policies, and issues signed OAuth 2.0 tokens. Learn More Trusted Applications and Access Control Register and configure your app inside an ERP.net instance Auth Flows Choose and implement the right flow Tokens Access tokens, scopes, and renewal Sessions How tokens map to sessions and licensing"
  },
  "auth/concepts/overview.html": {
    "href": "auth/concepts/overview.html",
    "title": "Overview | ERP.net Developer Docs",
    "summary": "Overview This section explains the core concepts behind authentication and authorization in ERP.net: identity authorities, OAuth 2.0, and how permissions are expressed and enforced. If you're looking for step-by-step scenario guides (SPA, web apps, service integrations), start with Getting Started. If you need instance-side setup, see Configuration. What you'll find here OAuth 2.0 A conceptual overview of OAuth 2.0 in the ERP.net ecosystem. See: OAuth 2.0 Identity authorities (instance vs global) How ERP.net chooses the identity authority depending on application type and scenario. See: Identity authorities (instance vs global) Instance Identity Service (per ERP.net instance) Concepts for the per-instance identity service used in Instance ID scenarios. See: Instance Identity Service (per ERP.net instance) ERP.net as an external Identity Provider (global) Concepts for using ERP.net as a global external identity provider. See: ERP.net as an external Identity Provider (global) Scopes How scopes define permissions, how they are requested, and how they affect API access. See: Scopes When to use this section You need to understand which identity authority applies to your scenario. You want a clear mental model before choosing a flow or configuring a trusted app. You're troubleshooting authorization issues (for example, missing or invalid scopes). See also Quickstarts Configuration OAuth 2.0 Flows Tokens Sessions"
  },
  "auth/concepts/scopes.html": {
    "href": "auth/concepts/scopes.html",
    "title": "Scopes | ERP.net Developer Docs",
    "summary": "Scopes Scopes define what level of access an application or token has within ERP.net. They are included in access tokens and determine which APIs, operations, and data the holder can use. Scopes are requested by the app and granted by the ERP.net Identity based on the app's configuration and policies. Standard Scopes Scope Description Availability read Grants read-only access to ERP.net data through APIs. All trusted apps update Grants permission to create, modify, or delete ERP.net data. All trusted apps offline_access Allows issuing a refresh token, enabling apps to renew access tokens without user interaction. All trusted apps openid Indicates the request is an OpenID Connect authentication request. Required to issue an ID token and identify the authenticated subject. All trusted apps profile Grants access to basic user information (such as name, email, user type). All trusted apps sec Grants access to security namespace APIs (roles, permissions, etc.). Reserved for ERP.net internal use only. Internal only DomainApi Legacy scope. Obsolete and must not be used. Deprecated Note Note on Identity Scopes The openid, profile, and offline_access values are protocol-defined scopes, not application-specific permissions. They do not need to be explicitly configured or allowed in a Trusted Application definition. Their availability is determined by the authorization flow being used and the capabilities of the identity system. For example, in the client credentials flow, these scopes are not issued because there is no authenticated user and no interactive session. Requesting Scopes Applications request scopes during the authorization or token request using the scope parameter: POST /id/connect/token Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app client_secret=<secret> grant_type=client_credentials scope=read update The resulting access token will contain the allowed scopes as part of its payload. Scope Enforcement The ERP.net Identity verifies which scopes a Trusted Application is permitted to request. If a requested scope is not allowed, the server returns invalid_scope. APIs automatically validate scopes on every request. If no scopes are explicitly requested, the issued access token will automatically include all scopes defined in the Trusted Application configuration. Note Always request the minimal set of scopes required by your application. This limits exposure and improves overall security. Example Token Payload (Scopes) { \"client_id\": \"my.trusted.app\", \"scope\": [\"read\", \"update\", \"offline_access\"], \"aud\": [\"DomainAPI\"], \"iss\": \"https://demo.my.erp.net/id\", \"exp\": 1762189360 } Security Considerations Only grant update to apps that must modify data. Avoid combining user and system scopes in the same token. Regularly audit trusted apps and their allowed scopes. Learn More Access Tokens Learn how scopes are embedded in tokens and used for authorization. Reference Access Tokens (PAT, SAT) Understand how long-lived tokens also rely on scope definitions. Token Lifetime and Renewal See how token expiration interacts with scoped access. Trusted Applications and Access Control Learn how trusted app configurations define which scopes are permitted."
  },
  "auth/configuration/overview.html": {
    "href": "auth/configuration/overview.html",
    "title": "Overview | ERP.net Developer Docs",
    "summary": "Overview This section covers the instance-side configuration required to allow external applications to authenticate and access ERP.net APIs. If you're implementing a concrete scenario (SPA, web app, service integration), see the step-by-step guides in Getting Started. What is configured here Trusted Applications A Trusted Application is the ERP.net instance registration of an external application. It identifies the client (by client_id) and defines the access rules that apply when the instance issues tokens and authorizes API requests. See: Trusted Applications Typical workflow Register the app as a Trusted Application in the ERP.net instance. Use the appropriate OAuth 2.0 flow to obtain tokens for that app. Call ERP.net APIs using the issued tokens. Related topics Scopes Identity authorities (instance vs global) Tokens"
  },
  "auth/configuration/trusted-apps-access.html": {
    "href": "auth/configuration/trusted-apps-access.html",
    "title": "Trusted Applications | ERP.net Developer Docs",
    "summary": "Trusted Applications A Trusted Application defines the relationship between an app and a specific ERP.net instance. It represents the app's registration record inside the instance: who the app is, which authentication modes it can use, and what access it may request. Every app that connects to ERP.net APIs must first be registered as a Trusted Application in the target instance. This ensures that access is secure, auditable, and governed by consistent policies. Note One record per instance: If your app connects to multiple instances, register it separately in each. Relationship to ERP.net Identity and OAuth In ERP.net, the connection between an external app and the instance relies on three cooperating components: ERP.net Identity – authenticates users and services and issues tokens. OAuth 2.0 – defines the standard flows for obtaining and using those tokens. Trusted Application – defines which app is calling, how it may authenticate, and what access it may be granted. Together, these components ensure that all applications are known, trusted, and subject to the instance's access rules. What a Trusted Application Controls Each Trusted Application record defines several aspects of the app's identity and permissions: Identity – unique ApplicationUri used as the OAuth client_id. Client type – whether the app is Public (cannot keep a secret) or Confidential (can keep a secret). Allowed modes – whether the app supports user login, background service access, or both. Redirects – approved login/logout redirect URIs for interactive sign-in. Scopes – permissions (such as read or update) that the instance may grant. Service identity – an optional SystemUser that represents the app when running as a background service. Reference token policy – defines who can issue API keys (Personal Access Tokens or Service Access Tokens). Lifecycle – enable or disable the app, rotate secrets, and track changes. Key Attributes (Essentials) Attribute Purpose Notes ApplicationUri Unique app identifier (used as client_id). Required. Use a stable, globally unique value (for example, com.vendor/app). ClientType Defines whether the app is Public or Confidential. Public = no secret. Confidential = requires secret. ApplicationSecretHash SHA-256 hash of the app's client secret. Confidential apps only. Never store plain text secrets. ImpersonateLoginUrl Allowed login redirect URIs. Comma-separated list; exact match required. ImpersonateLogoutUrl Allowed post-logout redirect URIs. Comma-separated list; exact match required. ImpersonateAsInternalUserAllowed Allows login for internal users. Enables sign-in with internal accounts. ImpersonateAsCommunityUserAllowed Allows login for community or external users. For customer or partner apps. Avoid enabling only community while disabling internal. SystemUserAllowed Enables background or service (non-interactive) access. Required for client credentials flow. SystemUser The service account to use. Required when SystemUserAllowed = true. Use a least-privilege user. Scope Space-delimited list of permissions. Example: read update. Request only what is necessary. AccessTokens Controls who may issue reference tokens (PAT/SAT). None, AuthenticatedUsers, or AdministratorsOnly. BasicAuthenticationAllowed Enables legacy Basic Auth. Off by default. Avoid unless required. IsEnabled Enables or disables the app. Acts as an immediate kill switch. How ERP.net Identity Uses It When an app connects to ERP.net, the ERP.net Identity validates its identity using the Trusted Application record. sequenceDiagram participant App participant IDP as ERP.net Identity participant TA as Trusted Application Definitions App->>IDP: Authenticate (client_id [+ secret/redirects]) IDP->>TA: Lookup by ApplicationUri TA-->>IDP: ClientType, redirects, flags, scopes, service user IDP-->>App: Issues tokens (if policy allows) Common Configurations Interactive Web Application (Server-Side) Used by web applications that authenticate users through a browser and operate from a secure backend. Typical setup: ClientType = Confidential ApplicationSecretHash set with SHA-256 of the secret. ImpersonateLoginUrl and ImpersonateLogoutUrl define the redirect endpoints. ImpersonateAsInternalUserAllowed = true (and optionally community users). SystemUserAllowed = false Minimal Scope, typically read or read update. Use for: Company portals, admin dashboards, or internal business apps. Single-Page or Native Application Used by SPAs or device apps that cannot safely store secrets. Typical setup: ClientType = Public ImpersonateLoginUrl and ImpersonateLogoutUrl defined for app redirect endpoints. Appropriate impersonation flags set for internal and/or community users. SystemUserAllowed = false Scope = read or read update. Use for: Browser-based frontends, mobile apps, or desktop clients. Service or Integration Application Used by background services, integration agents, or scheduled jobs that run without user interaction. Typical setup: ClientType = Confidential ApplicationSecretHash set to the secret hash. SystemUserAllowed = true and SystemUser assigned. ImpersonateAsInternalUserAllowed = false Scope = read update or read only for data retrieval. Use for: ERP.net integrations, synchronization tools, data migration, or automation services. Scopes and Access Policies Scopes define what actions an application can perform. They are listed as space-delimited strings in the Scope attribute. Scope Meaning Recommended for read Allows reading ERP.net data. Default for most apps. update Allows modifying ERP.net data. Required for write operations. sec Access to instance security infrastructure. Reserved; not for external apps. Note Always follow least-privilege principles. Start with read, and add update only when required. AccessTokens Policy The AccessTokens field controls who (if anyone) can issue reference tokens for the app (for example, PAT/SAT). Options: None - Reference tokens cannot be issued. PAT/SAT are disabled. AuthenticatedUsers - Any signed-in user can issue reference tokens for this app. AdministratorsOnly - Only administrators can issue reference tokens. Guidance: Start with None. Moving away from None introduces additional security risk and should be considered carefully with a clear operational need. If you must allow reference tokens, prefer AdministratorsOnly. Avoid AuthenticatedUsers unless there is a narrowly scoped. Security Guidelines Always use OAuth 2.0. Keep BasicAuthenticationAllowed = false. Use Confidential clients for server-side apps; Public for SPAs and native clients. Store only secret hashes; never the raw secret. Rotate secrets and API keys periodically. Grant the minimal required scopes. Use a least-privilege SystemUser for service access. Restrict redirect URIs to exact, HTTPS-based matches. Disable unused apps with IsEnabled = false. Audit all trusted apps periodically for owners, scopes, and usage. Example Minimal Setups Read-Only Interactive App (Internal Users) ClientType = Confidential ApplicationSecretHash = base64(sha256(<client-secret>)) ImpersonateAsInternalUserAllowed = true Scope = read SystemUserAllowed = false ImpersonateLoginUrl = https://<your-app>/auth/callback Used for internal dashboards or web portals where employees log in through the browser and only need to view ERP.net data. Write-Enabled Service Integration ClientType = Confidential ApplicationSecretHash = base64(sha256(<client-secret>)) SystemUserAllowed = true SystemUser = <least-privilege user> Scope = read update ImpersonateAsInternalUserAllowed = true Used for backend integrations or scheduled jobs that must update data, such as inventory sync or reporting automation. Public SPA (Read-Only) ClientType = Public ImpersonateAsInternalUserAllowed = true Scope = read SystemUserAllowed = false ImpersonateLoginUrl = https://<your-app>/auth/callback Used for front-end applications (for example, customer portals or mobile apps) that display ERP.net data to community users but cannot modify it. Hybrid App (Interactive + Service) ClientType = Confidential ApplicationSecretHash = base64(sha256(<client-secret>)) ImpersonateAsInternalUserAllowed = true ImpersonateAsCommunityUserAllowed = true SystemUserAllowed = true SystemUser = <least-privilege user> Scope = read update ImpersonateLoginUrl = https://<your-app>/auth/callback Used when the same application has both an interactive UI (user sign-in) and background service features (scheduled sync or automation). By defining Trusted Applications carefully, administrators can ensure that every integration or app connection to ERP.net is authenticated, authorized, and traceable - providing both flexibility and strong access control. Learn More ERP.net Identity Learn about the built-in authentication authority in every ERP.net instance. OAuth 2.0 Understand how apps obtain tokens and delegate access securely. Auth Flows Choose and implement the right flow Tokens Access tokens, scopes, and renewal Sessions How tokens map to sessions and licensing"
  },
  "auth/faq.html": {
    "href": "auth/faq.html",
    "title": "Authentication and Authorization FAQ | ERP.net Developer Docs",
    "summary": "Authentication and Authorization FAQ This page answers the most common questions developers have when connecting apps to ERP.net. Why do I need to register a Trusted Application? Every app that signs in users or calls ERP.net APIs must be registered as a Trusted Application in your ERP.net instance. It defines who the app is, what permissions (scopes) it has, and which authentication flows it may use. Without this registration, ERP.net Identity will reject all authentication requests. See: Trusted Applications and Access Control Which authentication flow should I use? It depends on the type of app you're building: Interactive web or desktop apps: use Authorization Code Flow (with PKCE). Background services or automations: use Client Credentials Flow. Apps with both frontend and backend: use the Hybrid Flow (combined). See: Choosing the Right Flow Can I call ERP.net APIs without OAuth? No. Basic authentication and API keys are deprecated. All external access must go through the ERP.net Identity using OAuth 2.0. The only exception is reference tokens (PAT or SAT), which are manually issued and act like long-lived API keys - but even they require proper scope and authorization. See: Reference Access Tokens What's the difference between a user token and a service token? User token (Authorization Code Flow): represents a person who logged in. Service token (Client Credentials Flow): represents an application identity (system user). They are not interchangeable - user tokens have personal access; service tokens have system-level access. See: Tokens Overview My login works, but API calls return 401 Unauthorized. Why? You are probably sending an expired or missing token in your API request. Check these: Your request must include the header Authorization: Bearer <access_token> Access tokens expire after 1 hour. Refresh or re-authenticate the user before calling again. Make sure the token was issued for the same instance you're calling - tokens are instance-specific. My app says \"invalid_client\". What does that mean? It means your app's credentials don't match what ERP.net expects. Common reasons: The client_id is wrong. The app type is Public, but you're sending a secret. The secret has been rotated or deleted. Fix: Check your Trusted Application settings and make sure you use the correct client ID and secret. Public (JavaScript) apps must not send a secret at all. See: Interactive Apps Common Errors See: Service Apps Common Errors I get \"invalid_scope\". What does that mean? You're asking for permissions your app is not allowed to have. Example: You request update sec, but your Trusted Application only has read. Fix: Update the app's allowed scopes, or request only those configured in ERP.net. Common valid scopes are: read, update, offline_access, profile. See: Interactive Apps Common Errors See: Service Apps Common Errors My redirect URI is rejected as invalid. Why? The redirect_uri you send must exactly match one of the URIs defined in the Trusted Application - including https, casing, and trailing slash. Fix: Edit your Trusted Application and add the correct URI, for example: https://myapp.example.com/auth/callback My token expired after one hour. Can I make it live longer? No - access tokens are intentionally short-lived (1 hour) for security. However, confidential apps can use a refresh token to get a new one automatically. If your app is public (for example, runs only in the browser), it must ask the user to sign in again when the token expires. See: Token Lifetime and Renewal I have a refresh token, but it stopped working. Why? Refresh tokens can expire or be revoked: Confidential apps: 30-day lifetime. Public apps: 24-hour lifetime. If the user logs out or changes their password, old tokens stop working. Always be ready to prompt the user to sign in again if refreshing fails. See: Token Lifetime and Renewal What's the difference between a token and a session? The token proves you're authorized. The session is the actual connection that consumes a license. You can have a valid token but fail to open a session if all licenses are in use. Sessions close automatically after inactivity (about 20 minutes). See: Tokens and Sessions Relationship Can I log out programmatically? Yes - for interactive apps, redirect the user to: https://<your-instance>.my.erp.net/id/connect/endsession The user will see a confirmation page and, after confirming, their session will close and release the license. Service (non-interactive) apps do not use this endpoint - their sessions close automatically after expiration. See: Session Revocation and Logout Why does ERP.net reject my request with \"MaximumLicenseCountExceeded\"? All licenses are currently in use. Even with a valid token, the system cannot open a new session until a slot becomes free. Fix: Wait a few minutes - inactive sessions release automatically after 20 minutes. Plan license capacity based on concurrency. See: License Slot Usage Can I use one token for multiple apps? No - this violates ERP.net's license agreement. Each user or service must have their own session and token. Parallel requests with the same token share the same session and license. See: License Compliance and Violations How can I safely test authentication? Use a sandbox instance or a dedicated test tenant. Register a separate Trusted Application there, and use dummy users or test accounts. Never reuse production secrets or tokens in test environments. Where can I see all available endpoints? Each ERP.net Identity exposes a discovery document with full endpoint metadata: https://<your-instance>.my.erp.net/id/.well-known/openid-configuration This includes URLs for token exchange, authorization, logout, and JSON Web Keys (JWKS) for token validation. Learn More OAuth 2.0 Overview Trusted Applications and Access Control Token Lifetime and Renewal License Slot Usage"
  },
  "auth/flows/auth-code/interactive-apps-errors.html": {
    "href": "auth/flows/auth-code/interactive-apps-errors.html",
    "title": "Common Errors in Interactive Apps | ERP.net Developer Docs",
    "summary": "Common Errors in Interactive Apps When implementing Authorization Code flow in an interactive app, errors can occur at different stages of the process. Most are caused by incorrect configuration in the Trusted Application, invalid redirects, or token misuse. This table lists the most common issues, their causes, and how to fix them. Error Typical Message Cause Fix Invalid Redirect URI invalid_redirect_uri The redirect_uri in your request doesn’t match any value in ImpersonateLoginUrl or ImpersonateLogoutUrl of the Trusted Application. Make sure the URI matches exactly (case-sensitive). Use HTTPS in production. Example: https://app.example.com/auth/callback. Missing or Invalid Client Credentials invalid_client Wrong client_id or client_secret. Trying to use a secret for a Public client or missing it for a Confidential one. Verify client_id matches the app’s ApplicationUri. Use the correct secret for Confidential clients. Unauthorized Grant Type unsupported_grant_type The grant type is not allowed by the Trusted Application. Only use authorization_code or refresh_token. Check flags like SystemUserAllowed and impersonation settings. PKCE Validation Failed invalid_grant: PKCE verification failed The PKCE challenge or verifier does not match. Make sure your SPA/mobile app uses the same code_verifier and code_challenge (method S256). Invalid Scope invalid_scope The requested scopes aren’t allowed for the app. Verify the Trusted Application’s Scope field includes them. Example: openid profile offline_access DomainApi. Expired or Invalid Authorization Code invalid_grant Code expired, was reused, or redirect URIs don’t match. Exchange the code immediately, match redirect_uri exactly, and don’t reuse codes. Invalid or Expired Refresh Token invalid_grant: refresh token is expired or invalid The refresh token expired, was revoked, or the app config changed. Use a new authorization code (user sign-in). Always store the latest refresh token. Token Expired API returns 401 Unauthorized The access token expired or was revoked. Use refresh tokens to get a new access token or reauthenticate. Disabled or Missing Trusted Application unauthorized_client The Trusted Application record is disabled or missing. Verify the app exists, IsEnabled = true, and you’re using the correct instance. Learn More Interactive Apps (Authorization Code Flow) Overview of how interactive apps authenticate users. Redirect URIs and PKCE How to secure redirects and apply PKCE. Refresh Tokens How to renew tokens without requiring user reauthentication. Trusted Applications and Access Control Learn how app registration affects permissions and validation."
  },
  "auth/flows/auth-code/interactive-apps-redirects-pkce.html": {
    "href": "auth/flows/auth-code/interactive-apps-redirects-pkce.html",
    "title": "Redirect URIs and PKCE | ERP.net Developer Docs",
    "summary": "Redirect URIs and PKCE Interactive apps use browser redirects to sign users in and return an authorization code to the app. This page explains how redirect URIs are validated in ERP.net and how to secure the Authorization Code flow with PKCE. Redirect URIs A redirect URI is where ERP.net Identity sends the user after a successful sign-in (or error). For security, it must match exactly one of the URIs registered in the app’s Trusted Application. Rules Exact, case-sensitive match against the ImpersonateLoginUrl list in the Trusted Application. Use HTTPS for public internet apps. You may register multiple URIs (for example, dev, staging, production). Query string may be present in the registered value, but matching is exact. Do not rely on wildcard suffixes. For native apps, use loopback or custom scheme redirects (see below). Note If the redirect URI does not match exactly, ERP.net Identity will reject the request. Common redirect URI patterns App type Example redirect URI Notes Server-side web app https://app.example.com/auth/callback Confidential client; handles code exchange on server SPA (browser) https://spa.example.com/index.html Public client; must use PKCE Native desktop http://127.0.0.1:53177/callback Loopback with random port; PKCE required. Can also use embedded browsers such as WebView or Chromium for login and redirect handling. Mobile app myapp://auth/callback Custom scheme; PKCE required Local dev https://localhost:5001/signin-callback Use HTTPS with a dev certificate if possible Note Desktop and mobile apps typically use system or embedded browsers to perform the OAuth redirect, such as WebView, Chromium, or OS-provided login components. PKCE overview PKCE (Proof Key for Code Exchange) protects the authorization code from interception. It adds a one-time secret to the flow so only the app that started the login can finish the token exchange. PKCE is required for: SPAs and other public clients that cannot keep a client secret. Native apps (desktop and mobile). PKCE is recommended for confidential web apps too. How PKCE works (at a glance) The app generates a random code_verifier. The app computes code_challenge = BASE64URL(SHA256(code_verifier)). The app starts the authorize request with code_challenge and code_challenge_method=S256. After sign-in, the app exchanges the returned code at the token endpoint and must present the original code_verifier. ERP.net Identity verifies that SHA256(code_verifier) matches the original code_challenge. If an attacker steals the code from the redirect, it is useless without the code_verifier. Build the authorize request Minimal parameters for Authorization Code + PKCE: GET /id/connect/authorize? response_type=code& client_id=my.trusted.app& redirect_uri=https://spa.example.com/index.html& scope=DomainApi read offline_access& state=kj82F3& code_challenge=2C5h2Bf2yq9e8q8WRzU7Hc8l4o7l5s2fC3VfLbaN9yM& code_challenge_method=S256 HTTP/1.1 Host: testdb.my.erp.net state is required for CSRF protection. Generate and validate it per request. Include offline_access only if you need a refresh token (interactive apps). Exchange the code with PKCE Token request for a public client (no secret): POST /id/connect/token HTTP/1.1 Host: testdb.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=authorization_code& client_id=my.trusted.app& code=K0dE...short...GZmNjV& redirect_uri=https://spa.example.com/index.html& code_verifier=<the_exact_random_string_used_for_code_challenge> For confidential server apps, you may use either PKCE or a client_secret: POST /id/connect/token HTTP/1.1 Host: testdb.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=authorization_code& client_id=my.trusted.app/server& client_secret=<your_client_secret>& code=K0dE...short...GZmNjV& redirect_uri=https://app.example.com/auth/callback Generating PKCE values Example pseudocode: code_verifier = base64url(random_bytes(32)) # keep in memory/storage for this login code_challenge = base64url(sha256(code_verifier)) # send in authorize request Guidelines: code_verifier should be high-entropy (32 to 64 random bytes before Base64URL). Use Base64URL encoding (no +, /, or padding =). Store code_verifier only long enough to finish the exchange, then discard. Security checklist Register all redirect URIs in the Trusted Application and keep them in sync across environments. Use PKCE for all public clients (SPA, native, mobile). It is recommended for confidential web apps. Validate the state parameter on return to prevent CSRF. Do not allow open redirects. Keep redirect URIs fixed and exact. Never put access tokens in URLs. Tokens belong in the Authorization header only. Learn More Interactive Apps (Authorization Code Flow) Overview of the user-facing flow and when to use it. Step-by-Step Example Full walkthrough of authorize, callback, and token exchange. Refresh Tokens Renew access without forcing the user to sign in again. Common Errors Troubleshooting invalid redirects, PKCE mismatches, and token issues. Trusted Applications and Access Control How app registrations define allowed redirects, users, and scopes."
  },
  "auth/flows/auth-code/interactive-apps-refresh-tokens.html": {
    "href": "auth/flows/auth-code/interactive-apps-refresh-tokens.html",
    "title": "Refresh Tokens in Interactive Apps | ERP.net Developer Docs",
    "summary": "Refresh Tokens in Interactive Apps Interactive applications that use the Authorization Code flow can receive a refresh token together with their access token. A refresh token allows the app to obtain new access tokens without requiring the user to sign in again. This enables a smoother experience for users and helps maintain secure, continuous access to ERP.net APIs. Note Refresh tokens are only available to interactive apps using the Authorization Code flow. They are not issued for the Client Credentials flow or non-interactive service apps. How Refresh Tokens Work The app completes the Authorization Code flow and receives: An access token – short-lived, used for API calls. A refresh token – long-lived, used to request new access tokens. When the access token expires, the app calls the token endpoint again, this time using the refresh token. ERP.net Identity validates the refresh token and issues a new access token (and possibly a new refresh token). The app replaces the expired token and continues calling the API without user interaction. sequenceDiagram participant App participant IDP as ERP.net Identity participant API as ERP.net API App->>IDP: POST /token (grant_type=authorization_code) IDP-->>App: access_token + refresh_token App->>API: Call API with access_token API-->>App: Return data Note over App: Access token expires App->>IDP: POST /token (grant_type=refresh_token) IDP-->>App: New access_token (+ refresh_token) App->>API: Continue API calls Requesting a Refresh Token To receive a refresh token, the app must include the offline_access scope when requesting authorization: GET /id/connect/authorize? client_id=my.trusted.app& redirect_uri=https://localhost/signin-callback& response_type=code& scope=openid profile offline_access DomainApi& state=xyz The offline_access scope signals that the app wants permission to act on behalf of the user even when they are not actively signed in. Exchanging a Refresh Token When your access token expires, send a new request to the token endpoint: POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app& client_secret=<my_secret>& grant_type=refresh_token& refresh_token=<your_refresh_token> Example Response { \"access_token\": \"eyJhbGciOiJSUzI1NiIs...\", \"expires_in\": 3600, \"refresh_token\": \"SvQvQ9cxcYzs0AWg6tsGW1-YK7O5xP...\", \"scope\": \"openid profile DomainApi offline_access\" } Use the new access token for subsequent API calls. Warning Each refresh issues a new refresh token. Always store the latest one, as older tokens will be revoked. Token Lifetime and Renewal Token Type Typical Lifetime Renewable Notes Access Token Short-lived (1 hour) Yes (via refresh token) Short-lived for security Refresh Token Long-lived (1 month) Yes, until revoked Use to obtain new access tokens Best Practices Always request offline_access only when needed. Store refresh tokens securely (encrypted and server-side). Handle token renewal transparently for users. Implement fallback to full login if the refresh token fails. Always update your stored refresh token with the latest one issued. Example: Refresh Token Renewal POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app& client_secret=<my_secret>& grant_type=refresh_token& refresh_token=<old_refresh_token> Response: { \"access_token\": \"new_access_token_value\", \"refresh_token\": \"new_refresh_token_value\", \"expires_in\": 3600 } Replace your existing tokens with these new ones and continue using the API. Learn More Interactive Apps (Authorization Code Flow) How interactive apps sign in and obtain tokens. Redirect URIs and PKCE Securing redirects and preventing code interception. Trusted Applications and Access Control Learn how app configuration affects token issuance. Common Errors Handling invalid or expired refresh tokens."
  },
  "auth/flows/auth-code/interactive-apps-step-by-step.html": {
    "href": "auth/flows/auth-code/interactive-apps-step-by-step.html",
    "title": "Step-by-Step: Authorization Code Flow | ERP.net Developer Docs",
    "summary": "Step-by-Step: Authorization Code Flow This guide walks through the exact HTTP steps an interactive app takes to sign in a user with the ERP.net Identity, exchange the authorization code for tokens, and call the APIs. It covers both confidential web apps (server-side) and public clients (SPAs) using PKCE. Prerequisites Register your app as a Trusted Application in the target ERP.net instance. Minimum required settings for a confidential web app: Attribute Value Notes ApplicationUri my.trusted.app/first Used as client_id ClientType Confidential Server-side app can keep a secret ApplicationSecretHash base64(sha256(your-secret)) Store only the hash ImpersonateAsInternalUserAllowed true Or community users if needed ImpersonateLoginUrl https://your-app.example.com/signin-callback Exact HTTPS redirect URI IsEnabled true App is active Scope read update DomainApi offline_access Request only what you need Warning For a public SPA, set ClientType = Public and omit the secret. PKCE is required. 1) Send the user to authorize Your app redirects the user to the instance ERP.net Identity. Example query: GET /id/connect/authorize? client_id=my.trusted.app/first& redirect_uri=https://your-app.example.com/signin-callback& response_type=code& scope=read offline_access& state=xyz123& code_challenge=Oq8sW...&_pkce_& code_challenge_method=S256 HTTP/1.1 Host: testdb.my.erp.net response_type=code requests an authorization code. scope should include only what you need. offline_access is required if you want a refresh token. For public clients (SPA or native), include code_challenge and code_challenge_method=S256 (PKCE). For confidential server apps, PKCE is recommended; client secret is used later at the token endpoint. If everything is valid, the browser is redirected to the ERP.net login page. 2) Handle the sign-in callback After the user signs in successfully, ERP.net Identity redirects back to your registered redirect_uri with a short-lived authorization code: GET /signin-callback? code=K0dE...short...GZmNjV& state=xyz123 HTTP/1.1 Host: your-app.example.com Validate state to prevent CSRF. Extract the code 3) Exchange the code for tokens Your server sends a POST to the token endpoint to trade the code for tokens. Confidential web app (client secret) POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=authorization_code& client_id=my.trusted.app/first& client_secret=<your_plain_client_secret>& code=K0dE...short...GZmNjV& redirect_uri=https://your-app.example.com/signin-callback Public SPA (PKCE) POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=authorization_code& client_id=my.trusted.app/first& code=K0dE...short...GZmNjV& redirect_uri=https://your-spa.example.com/index.html& code_verifier=<original_random_string_used_to_build_code_challenge> Typical JSON response { \"access_token\": \"<access_token>\", \"expires_in\": 3600, \"refresh_token\": \"<refresh_token_if_offline_access_was_requested>\", \"token_type\": \"Bearer\", \"scope\": \"read offline_access\" } 4) Call ERP.net APIs Use the access token in the Authorization header: GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: testdb.my.erp.net Authorization: Bearer <access_token> Sessions are created when the token is first used, not when it is issued. If you receive HTTP 401 after some time, the access token likely expired. 5) Renew the access token (if applicable) If your app received a refresh token, renew silently: POST /id/connect/token HTTP/1.1 Host: testdb.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=refresh_token& client_id=my.trusted.app/first& client_secret=<your_plain_client_secret>& refresh_token=<previous_refresh_token> Response contains a new access token and, depending on policy, a new refresh token. Note Client Credentials flow does not issue refresh tokens. Request a new access token when needed. Sequence overview sequenceDiagram participant User participant App participant IDP as ERP.net Identity participant API as ERP.net APIs User->>App: Clicks Sign In App->>IDP: /connect/authorize (client_id, scopes, redirect_uri, [PKCE]) IDP->>User: Login + consent User->>IDP: Credentials IDP->>App: Redirect back with code App->>IDP: /connect/token (code [+ secret or PKCE verifier]) IDP-->>App: access_token (+ refresh_token) App->>API: Call with Bearer access_token API-->>App: Authorized response Security best practices Redirect URIs must match exactly what is registered in the Trusted Application. Use PKCE for SPAs and all public clients. Keep secrets on the server only; never ship them to browsers or mobile apps. Request the smallest set of scopes that satisfy your feature needs. Handle and store refresh tokens securely; rotate if compromised. Full samples Access token via authorization code flow in a SPA (Single Page Application) Access token via authorization code flow in a console app Access token via authorization code flow in a web app Basic example of acquiring an access token Basic example- exchange an auth code for an access token Basic example- renew an access token via a refresh token Learn More Redirect URIs and PKCE How to secure redirects and apply PKCE correctly. Refresh Tokens How to renew tokens without requiring the user to sign in again. Trusted Applications and Access Control Learn how app registrations define access modes, users, and permissions. Common Errors Troubleshooting invalid redirects, PKCE mismatches, and token issues."
  },
  "auth/flows/auth-code/overview.html": {
    "href": "auth/flows/auth-code/overview.html",
    "title": "Interactive Apps (Authorization Code Flow) | ERP.net Developer Docs",
    "summary": "Interactive Apps (Authorization Code Flow) Interactive applications connect to ERP.net using the Authorization Code flow - the standard OAuth 2.0 pattern for securely authenticating users and obtaining tokens on their behalf. This flow is used by web, desktop, and mobile apps that have a user interface and require access to data under the signed-in user's permissions. When to Use Use this flow when your application: Has a user interface where people sign in (browser, desktop, or mobile). Needs access to user-specific data or permissions. Should never handle user passwords directly. Can securely handle redirect URIs and (if confidential) a client secret. How It Works The Authorization Code flow separates user authentication from API access. The app redirects the user to the ERP.net instance's Identity, where the user signs in. After successful authentication, ERP.net Identity issues a short-lived authorization code, which the app exchanges for an access token (and optionally a refresh token). The app then uses the access token to call ERP.net APIs on behalf of the user. sequenceDiagram participant User participant App participant IDP as ERP.net Identity participant API as ERP.net APIs User->>App: Open app and click \"Sign In\" App->>IDP: Redirect to /connect/authorize with client_id, scopes, redirect_uri IDP->>User: Prompt for login and consent User->>IDP: Authenticate with credentials IDP->>App: Redirect back with authorization code App->>IDP: POST /connect/token with code, client_id, [secret or PKCE] IDP-->>App: Return access token (and optional refresh token) App->>API: Call ERP.net APIs with the access token API-->>App: Return protected data Note Tokens are issued by ERP.net Identity of the target ERP.net instance. Each instance validates and authorizes the app through its Trusted Application configuration. Trusted Application Relationship Before an interactive app can connect to an ERP.net instance, it must be registered as a Trusted Application. The Trusted Application record defines: The app's identity (ApplicationUri, used as client_id). Whether the app is Public (no secret) or Confidential (uses a client secret). The redirect URIs allowed for login and logout. Which users can authenticate (internal or community). The scopes and permissions the app can request. During the sign-in process, ERP.net Identity checks the app's registration, validates the redirect URI, and ensures the scopes requested match the Trusted Application configuration. Note If the app is not registered or its configuration does not match, ERP.net Identity will reject the authentication request. Security Highlights Redirect URIs must exactly match the ones registered in the Trusted Application. PKCE (Proof Key for Code Exchange) is mandatory for SPAs and public clients. Client secrets must only be used by secure, confidential clients (for example, backend servers). Access tokens are short-lived and can be renewed via refresh tokens if permitted. Example Clients App Type Example Client Type Notes Web App (Server-side) Internal portal, admin dashboard Confidential Uses client secret; refresh tokens allowed SPA (Browser-based) Customer portal, analytics dashboard Public Uses PKCE; no client secret Mobile App Field service or sales app Public Uses PKCE; must secure redirect handling Typical Sequence Summary User opens the app and selects Sign In. App redirects to ERP.net Identity for authentication. ERP.net Identity checks the Trusted Application configuration (redirects, scopes, client type). The user signs in and grants consent. ERP.net Identity redirects back to the app with an authorization code. The app exchanges the code for an access token. The app uses the token to call ERP.net APIs. If allowed, the app silently renews the token using a refresh token. Warning Always request only the scopes your app truly needs. Smaller scopes mean safer tokens and fewer consent prompts. Learn More Step-by-Step Example Walk through the full login and token exchange sequence. Redirect URIs and PKCE How to secure redirects and apply PKCE correctly. Refresh Tokens How to renew tokens without requiring the user to sign in again. Trusted Applications and Access Control Learn how app registrations define access modes, users, and permissions. Common Errors Troubleshooting invalid redirects, PKCE mismatches, and token issues."
  },
  "auth/flows/choosing-flow.html": {
    "href": "auth/flows/choosing-flow.html",
    "title": "Choosing the Right Flow | ERP.net Developer Docs",
    "summary": "Choosing the Right Flow Every app that connects to ERP.net must use one of the supported OAuth 2.0 authentication flows. Choosing the right one depends on how your app interacts with users, how it runs, and what type of access identity it needs - a signed-in user or a configured System User. How to Choose Start by asking these three questions: Does your app have a user interface where people sign in? Does your app run unattended (like a service, integration, or background job)? Does your app need both user access and system-level automation? Your answers map directly to the correct flow. App Type Recommended Flow Who Authenticates Interaction Typical Scenario Interactive App Authorization Code User Interactive Web app, SPA, or mobile client where a user signs in Service or Background App Client Credentials Application (via its configured System User) Non-interactive Integration microservice, background sync, scheduled job Hybrid App Authorization Code + Client Credentials Both user and System User Mixed Web or mobile app with backend services performing elevated or automated operations Note All flows are handled by ERP.net Identity, which authenticates users, validates app identities, and issues tokens. Example Scenarios Interactive App - Authorization Code Flow Your app presents a Sign In button. A user logs in through the ERP.net Identity, and your app receives an access token to act on behalf of that specific user. Use this flow when: Your app has a web or mobile interface. You need access to data tied to the signed-in user. You want to refresh tokens silently without reauthenticating. Warning Use PKCE for all SPAs and public clients. Never embed a client secret in front-end or mobile code. Service or Background App - Client Credentials Flow Your app runs automatically, without direct user interaction. It authenticates directly with the ERP.net Identity using its credentials from the Trusted Application record. When this flow is used, the instance issues tokens that represent the app's configured System User. All API calls are executed under that user's permissions. Use this flow when: The app runs as a background process, scheduler, or integration service. You need continuous access without human login. You require controlled access under a known System User identity. Note The Trusted Application must have SystemUserAllowed = true and a valid SystemUser assigned. Tokens obtained via this flow always execute as that System User. Warning Use a least-privilege System User dedicated to automation. Never assign an administrative user account. Hybrid App - Combining Both Flows Some apps need both: interactive user access and background service capabilities. For example, a web portal where users sign in via Authorization Code flow, combined with a backend service that performs scheduled imports or privileged operations via Client Credentials. Use this pattern when: Your front end requires user-specific access. Your backend performs background or elevated tasks. You want both flows under the same logical Trusted Application. Warning Keep user tokens and service tokens completely separate. Never forward or reuse a user's access token for backend processes. Technical Comparison Category Authorization Code Flow Client Credentials Flow Who authenticates User Application's configured System User User involvement Required (interactive login) None Typical clients Web apps, SPAs, mobile or desktop clients Integrations, background services, daemons Token context Represents the signed-in user Represents the System User assigned in Trusted Application Refresh tokens Supported for confidential clients Not supported Session creation On first API use On first API use Security requirements Redirect URIs, PKCE, secure redirect handling Secure secret storage, restricted System User When to use App acts on behalf of a signed-in user App acts as its configured System User Example Web portal for employees or partners Integration or synchronization service Token Behavior and Renewal Flow Token Lifetime Refresh Tokens Renewal Method Authorization Code Short-lived Yes Use refresh token for silent renewal Client Credentials Short-lived No Request a new token when needed Hybrid Independent per flow Mixed Each flow renews tokens separately Note All tokens are short-lived by default to reduce exposure risk. Refresh tokens are available only to interactive clients. Reference Tokens (API Keys) ERP.net also supports reference access tokens – manually issued API keys that grant long-lived access to the APIs. They are not part of any OAuth 2.0 flow and are created manually by a user or administrator. PAT (Personal Access Token) – represents a specific user identity. SAT (Service Access Token) – represents a service or system user. Use them only when OAuth flows are not practical (for example, automation scripts or CI/CD pipelines). See Reference Tokens for details on how they are issued, secured, and revoked. Security Best Practices Always register your app as a Trusted Application before connecting. Use Confidential clients for server apps; Public for SPAs and device apps. Store secrets securely. Rotate secrets periodically. Assign a least-privilege System User to all background apps. Restrict redirect URIs to exact HTTPS endpoints. Use PKCE for all public OAuth clients. Never expose or share access tokens. Summary Every app must be registered as a Trusted Application in ERP.net. ERP.net Identity validates the app and issues tokens according to its configuration. Authorization Code Flow -> user-driven, interactive access. Client Credentials Flow -> system-driven, using the app's System User. Hybrid Flow -> combines both, with strict separation between contexts. Choose the flow that matches how your app operates - and let the ERP.net Identity handle authentication securely and consistently. Learn More Flows Overview Understand how the main OAuth 2.0 flows fit into ERP.net. Trusted Applications and Access Control Learn how to configure System Users, scopes, and authentication policies. Interactive Apps (Authorization Code Flow) Step-by-step guide for apps with user sign-in. Service and Background Apps (Client Credentials Flow) How to authenticate backend or automated services. Hybrid Apps Combine user and backend flows in one secure architecture."
  },
  "auth/flows/client-credentials/overview.html": {
    "href": "auth/flows/client-credentials/overview.html",
    "title": "Service and Background Apps (Client Credentials Flow) | ERP.net Developer Docs",
    "summary": "Service and Background Apps (Client Credentials Flow) Service applications connect to ERP.net using the Client Credentials grant. They run without user interaction and receive tokens that represent the app's configured System User. Use this flow for integrations, schedulers, imports, exports, and daemon services. When to use No user signs in; the app runs unattended. You need stable access under a known identity. The app can securely store a client secret (Confidential client). Operations should run with permissions of a least-privilege System User. How it works The app authenticates to the ERP.net Identity with its client_id and client_secret. ERP.net Identity validates the app against its Trusted Application record. If allowed, it issues a short-lived access token that represents the app's System User. The app calls ERP.net APIs with the token. When the token expires, the app requests a new one. sequenceDiagram participant App participant IDP as ERP.net Identity participant API as ERP.net APIs App->>IDP: POST /connect/token (grant_type=client_credentials, client_id, client_secret, scope) IDP-->>App: access_token (System User context) App->>API: Call with Authorization: Bearer <token> API-->>App: Authorized response Note Client Credentials flow does not issue refresh tokens. Request a new access token when needed. Trusted Application requirements ClientType = Confidential SystemUserAllowed = true SystemUser = <least-privilege account> Scope lists only the permissions the service needs IsEnabled = true Security highlights Store the client secret securely; never embed in public code. Use a dedicated System User with least privilege. Rotate secrets and the System User password periodically. Log token requests and API calls for auditing. Learn More Step-by-Step Example Minimal sequence to obtain a token and call the APIs. Token Request and Response Exact parameters, examples, and response fields. Common Errors Quick fixes for invalid_client, invalid_scope, and more. Choosing the Right Flow When to use Client Credentials vs interactive or hybrid."
  },
  "auth/flows/client-credentials/service-apps-errors.html": {
    "href": "auth/flows/client-credentials/service-apps-errors.html",
    "title": "Common Errors – Service and Background Apps (Client Credentials Flow) | ERP.net Developer Docs",
    "summary": "Common Errors – Service and Background Apps (Client Credentials Flow) When using the Client Credentials Flow, errors typically relate to application configuration, credentials, or scope permissions. This table summarizes the most common issues and how to resolve them. Error Typical Message Cause Fix invalid_client Invalid client_id or client_secret The Trusted Application is not found, disabled, or the secret is incorrect. Verify the client_id (ApplicationUri) matches the Trusted Application, and the client_secret is correct. Check that the app is enabled (IsEnabled = true) and ClientType = Confidential. unauthorized_client The client is not authorized to use this grant type The Trusted Application is not allowed to use the Client Credentials flow. In the Trusted Application, make sure SystemUserAllowed = true and a valid SystemUser is assigned. invalid_scope Invalid scope: update The app requested a scope that is not allowed by the Trusted Application. Check the Scope field in the Trusted Application record. Only request scopes defined there (for example, read update DomainApi). invalid_grant Client credentials are invalid or missing The request is malformed, missing parameters, or uses an incorrect grant type. Ensure your request uses grant_type=client_credentials and includes both client_id and client_secret as form fields. unsupported_grant_type Unsupported grant type: password The flow is incorrect for this app. Use only grant_type=client_credentials for service apps. Do not use password or authorization code grants. invalid_request Missing client_id or Missing client_secret Required parameters were omitted from the request. Include both client_id and client_secret in the POST body of the token request. Learn More Overview When and why to use the Client Credentials flow. Step-by-Step Example Minimal sequence to obtain a token and call the APIs. Token Request and Response Request parameters and example responses. Trusted Applications and Access Control Configure System User and scopes properly for background apps."
  },
  "auth/flows/client-credentials/service-apps-step-by-step.html": {
    "href": "auth/flows/client-credentials/service-apps-step-by-step.html",
    "title": "Step-by-Step: Client Credentials Flow | ERP.net Developer Docs",
    "summary": "Step-by-Step: Client Credentials Flow This walkthrough shows how a service app authenticates with the ERP.net Identity and calls the APIs using the Client Credentials grant. Prerequisites Register a Trusted Application with: Attribute Value Notes ApplicationUri my.trusted.app/service Used as client_id ClientType Confidential Service app must keep a secret ApplicationSecretHash base64(sha256(your-secret)) Store only the hash SystemUserAllowed true Enables service access SystemUser svc.integration Least-privilege account Scope read DomainApi Request only what you need IsEnabled true App is active 1) Request an access token HTTP form: POST /id/connect/token HTTP/1.1 Host: testdb.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=client_credentials& client_id=my.trusted.app/service& client_secret=<your_plain_client_secret>& scope=read Successful response { \"access_token\": \"<access_token>\", \"expires_in\": 3600, \"token_type\": \"Bearer\", \"scope\": \"read\" } 2) Call ERP.net APIs GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: testdb.my.erp.net Authorization: Bearer <access_token> The call executes under the System User configured in the Trusted Application. A session is created when the token is first used, not when issued. 3) Handle expiry When API returns 401 Unauthorized, the access token likely expired. Request a fresh token with the same client credentials and retry the API call. Note Refresh tokens are not issued for Client Credentials. Always request a new access token. Security best practices Store client_secret only on secure servers. Never ship secrets to browsers or mobile apps. Use a dedicated System User with least privilege. Rotate its password and the client secret periodically. Do not log full tokens. Log hashes or last 6 to 8 characters for traceability. Send requests only to the correct instance: https://{instance}/id. Full samples Access token via authorization code flow in a SPA (Single Page Application) Access token via authorization code flow in a console app Access token via authorization code flow in a web app Basic example of acquiring an access token Basic example- exchange an auth code for an access token Basic example- renew an access token via a refresh token Learn More Overview When and why to use Client Credentials. Token Request and Response Parameters, examples, and response fields. Common Errors Troubleshooting configuration and scope issues. Trusted Applications and Access Control System User, scopes, and policies."
  },
  "auth/flows/client-credentials/service-apps-token.html": {
    "href": "auth/flows/client-credentials/service-apps-token.html",
    "title": "Token Request and Response | ERP.net Developer Docs",
    "summary": "Token Request and Response This page documents the exact request and response for the Client Credentials grant in ERP.net. Service apps use this to obtain short-lived access tokens that represent the app's configured System User. Endpoint Authorization server base: https://{instance}/id Token endpoint: POST /connect/token Content type: application/x-www-form-urlencoded Request parameters Name Required Example Notes grant_type Yes client_credentials Must be exactly client_credentials. client_id Yes my.trusted.app/service Your Trusted Application ApplicationUri. client_secret Yes <your_plain_client_secret> Confidential clients only. Keep secret server-side. scope Recommended DomainApi read Space-delimited scopes your service needs. Request only what you need. HTTP example POST /id/connect/token HTTP/1.1 Host: testdb.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=client_credentials& client_id=my.trusted.app/service& client_secret=<your_plain_client_secret>& scope=read cURL example curl -X POST \"https://testdb.my.erp.net/id/connect/token\" \\ -H \"Content-Type: application/x-www-form-urlencoded\" \\ -d \"grant_type=client_credentials\" \\ -d \"client_id=my.trusted.app/service\" \\ -d \"client_secret=<your_plain_client_secret>\" \\ -d \"scope=read\" Successful response { \"access_token\": \"<access_token>\", \"expires_in\": 3600, \"token_type\": \"Bearer\", \"scope\": \"read\" } Successful response fields access_token: The short-lived bearer token your service must send in the Authorization: Bearer <token> header when calling ERP.net APIs. It executes under the configured System User and within the granted scopes. expires_in: Lifetime of the access token in seconds. After this time elapses, request a new token. token_type: Always Bearer for ERP.net APIs. scope: Space-delimited list of scopes actually granted (for example, read, update). May be a subset of what you requested. Note Client Credentials flow does not return a refresh token. When the token expires, request a new one. Using the token GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: testdb.my.erp.net Authorization: Bearer <access_token> The call runs under the System User configured in your Trusted Application. A session is created when the token is first used, not when it is issued. Scopes Typical scopes for service apps: read for read-only access. update for write operations. Note Follow least-privilege. Start with read; add update only when strictly required. Learn More Overview When and why to use Client Credentials. Step-by-Step Example Minimal sequence to obtain a token and call the APIs. Common Errors Fix common issues like invalid_client and invalid_scope. Trusted Applications and Access Control Configure System User and scopes."
  },
  "auth/flows/combined/hybrid-architecture.html": {
    "href": "auth/flows/combined/hybrid-architecture.html",
    "title": "Typical Architecture – Hybrid Apps | ERP.net Developer Docs",
    "summary": "Typical Architecture – Hybrid Apps Hybrid apps combine interactive frontends and backend services into a single connected solution. Each part authenticates separately using its own flow - yet both operate under the same Trusted Application identity. Layered Architecture A typical hybrid app consists of three main layers: Layer Role Authentication Flow Frontend User interface where people sign in. Handles presentation, lightweight API calls, and UI logic. Authorization Code Backend Service Secure server process performing business logic, ERP.net API calls, background sync, and elevated operations. Client Credentials ERP.net Instance Includes ERP.net Identity for authentication and the ERP.net APIs for data access. Both The separation ensures clean boundaries between user identity and system identity while allowing shared configuration through a single Trusted Application. Communication Flow sequenceDiagram participant User participant WebApp as Frontend App participant Backend as Backend Service participant IDP as ERP.net Identity participant API as ERP.net APIs User->>WebApp: Opens app WebApp->>IDP: Authorization Code flow (user login) IDP-->>WebApp: User access token WebApp->>Backend: Send request (user context) Backend->>IDP: Client Credentials flow (service login) IDP-->>Backend: Service access token Backend->>API: Calls ERP.net APIs using service token API-->>Backend: Data response Backend-->>WebApp: Returns result to user In this setup: The frontend authenticates the user for identity purposes (no direct ERP.net data access). The backend uses its service token to communicate securely with ERP.net APIs. The frontend and backend communicate over a protected internal channel (e.g., HTTPS REST, gRPC, or GraphQL). Deployment Models Hybrid apps can be deployed in different configurations depending on scale and security needs. Model Description Use Case Monolithic Frontend and backend hosted together (same domain, single deployment). Small internal portals or low-traffic partner apps. Distributed (2-tier) Frontend hosted separately (e.g., SPA in CDN) and backend hosted securely behind firewall or cloud function. Common for SaaS portals and external-facing apps. Microservice-based Backend logic split into independent services sharing the same Trusted Application identity. Complex integrations, high scalability, or multiple business domains. Note For external-facing scenarios, the backend should reside in a controlled environment - the frontend never holds secrets and communicates through HTTPS to the backend only. Token Boundaries Hybrid apps maintain strict token separation: Token Type Used By Scope Lifetime Storage User access token Frontend Identity and UI context only Short (1 hour) Browser memory or secure storage Service access token Backend ERP.net API access Short (1 hour) Server memory or cache Refresh token Frontend (optional) Renew user access token Long (30 days) Secure server-side store SystemUser Backend (Trusted Application) ERP.net service identity Static Stored in configuration only Warning Never pass a backend (service) token to the frontend or the client device. Example: External Portal Pattern This pattern is ideal when the app serves external ERP.net users (partners, vendors, or customers): The frontend authenticates external users only for identity (no ERP.net session is created). The backend, using the Client Credentials flow, holds a single ERP.net session tied to its SystemUser. All API operations go through the backend, so ERP.net sees one session - minimal licensing overhead and maximum isolation. flowchart LR U[\uD83C\uDF10 External User] -->|Login| FE[\uD83D\uDCBB Frontend] FE -->|API Request| BE[⚙️ Backend Service] BE -->|Service Token| ERP[\uD83E\uDDE9 ERP.net APIs] ERP --> D[(\uD83D\uDCCA ERP.net Data)] This structure: Keeps ERP.net sessions centralized (only one service session). Maintains external user identity separately for auditing. Scales easily - multiple users share the same backend connection. Best Practices Keep frontend and backend token stores separate. Use short token lifetimes; rely on backend caching for reuse. Ensure the frontend never handles secrets or client credentials. Log all token exchanges and backend operations for auditing. Implement HTTPS end-to-end (browser → backend → ERP.net). Assign a least-privilege System User for backend operations. Learn More Example Scenarios Practical hybrid implementations for common ERP.net patterns. Trusted Applications and Access Control Configure impersonation and SystemUser access for hybrid apps."
  },
  "auth/flows/combined/hybrid-examples.html": {
    "href": "auth/flows/combined/hybrid-examples.html",
    "title": "Example Scenarios | ERP.net Developer Docs",
    "summary": "Example Scenarios Hybrid applications combine user-facing interaction with system-level automation. They are especially useful when the app serves external ERP.net users but also needs to perform privileged background operations - all under a single, controlled app identity. Below are several practical hybrid patterns you can adapt for your integration or portal design. Scenario 1: External Partner Portal with Automated Sync Use case: An external partner portal allows external vendors to review orders, update shipment data, and view invoices. Meanwhile, a backend service synchronizes stock data nightly using elevated permissions. Frontend flow: External users (partners) log in via the Authorization Code flow. Their identity and permissions are validated by the backend, but they do not receive an access token to call ERP.net directly. Backend flow: A backend service (using Client Credentials flow) performs all privileged tasks, like syncing stock or processing orders. The backend uses a SystemUser identity to authenticate and access ERP.net data. No ERP.net data is directly exposed to external users - all access is controlled via the service account. Result: External users interact with their data securely through the portal, while the backend service updates the data automatically, without requiring manual intervention. Scenario 2: Customer Self-Service Portal (External Authentication) Use case: A self-service portal for external customers lets users view invoices, service tickets, and orders. The frontend authenticates the customer, but the backend manages all data access. Frontend flow: External customers authenticate via the Authorization Code flow. They receive a valid id token, but this token can't be used to access ERP.net directly. Backend flow: The backend uses Client Credentials flow to obtain a service token. This token is used for all interactions with ERP.net APIs. The backend is responsible for checking the customer's access rights and fetching the relevant data from ERP.net. External customers never directly interact with ERP.net APIs - all access is managed by the backend. Result: External customers authenticate to the system, but the frontend only passes relevant identity context to the backend. The backend makes all the calls to ERP.net using a service token. Scenario 3: Internal Operations Dashboard Use case: An internal dashboard provides managers with real-time KPIs, while backend services push updates and alerts. Frontend flow: Internal users log in through Authorization Code flow with ImpersonateAsInternalUserAllowed = true. Their roles define access to analytics and reports. Backend flow: Uses Client Credentials to poll ERP.net for new events, update cached reports, or send notifications. Operates with a SystemUser that has limited read access only. Result: User dashboards show data securely in real time while backend services run independently without session issues. Scenario 4: Mobile Field App with Cloud Sync Use case: A mobile app for service technicians allows users to log visits, attach photos, and sync offline data. Frontend flow: Each technician signs in via Authorization Code flow (PKCE). The app works offline and queues updates to send later. Backend flow: The cloud service authenticates with Client Credentials. Applies business validation and commits technician updates to ERP.net APIs. Result: The app handles users securely without exposing secrets, while all writes to ERP.net happen through a secure backend channel. Scenario 5: Hybrid Integration Gateway Use case: A middleware gateway connects external systems. It provides a simple frontend for admin configuration, plus a backend for high-volume data movement. Frontend flow: Administrators log in interactively via Authorization Code flow. Manage configuration, mappings, and monitoring UI. Backend flow: The integration engine runs continuously via Client Credentials flow. Pushes and pulls data to and from ERP.net APIs using the SystemUser. Result: Operations run under service credentials, while the UI reflects real-time sync status with user-specific audit trails. Best Practices Recap Principle Why it matters Separate user and service tokens Prevents privilege escalation or token leakage Use a SystemUser for backend work Keeps API sessions efficient and auditable Do not expose secrets in frontend Public apps must never hold client secrets Limit scopes Only request read or update as needed Enable both impersonation and SystemUser Required for hybrid trusted apps Centralize token handling Backend controls renewal and caching for both flows Learn More Hybrid Apps Overview Understand the concept and advantages of hybrid design. Typical Architecture Visualize frontend and backend interactions with ERP.net Identity. Choosing the Right Flow Decide when hybrid architecture is the right fit."
  },
  "auth/flows/combined/overview.html": {
    "href": "auth/flows/combined/overview.html",
    "title": "Hybrid Apps Overview | ERP.net Developer Docs",
    "summary": "Hybrid Apps Overview Some applications combine interactive user access with background automation or elevated operations. These are known as Hybrid Apps, and they use both OAuth 2.0 flows: Authorization Code Flow for user-facing (interactive) parts. Client Credentials Flow for backend or service components. This pattern is ideal for apps that need to securely connect user sessions with backend logic while maintaining proper isolation between the two. Why Hybrid? Hybrid apps let you safely combine user and system contexts in one solution. Purpose Flow Who Authenticates Example User-facing front end Authorization Code User Web portal, dashboard, mobile app Background or elevated operations Client Credentials Application (System User) Background sync, import/export, scheduled automation Note Even though both flows may belong to the same logical application, they use separate credentials, tokens, and sessions - ensuring the backend cannot impersonate a user and vice versa. Typical Use Cases Web app + background worker A user-facing portal (Authorization Code) triggers backend sync jobs (Client Credentials). Mobile app + cloud API service The mobile app signs in users; a separate server component manages uploads or scheduled tasks. Enterprise integration The web UI uses user tokens for data entry; backend agents run elevated batch updates under a System User. External user portals A perfect fit when your frontend targets external ERP.net users (for example, partners or customers). These users authenticate for identity purposes only - not for creating ERP.net sessions. The backend then operates using the Client Credentials flow, so all API calls share a single, stable session managed by the service identity. This setup minimizes session usage and isolates data access securely. Key Benefits Separation of duties – users act within their own permissions; backend code runs as a service account. Security and compliance – no sharing of user credentials for automation. Consistency – both components authenticate through the same ERP.net Identity and share configuration via their Trusted Application. Efficiency for external users – external logins establish identity only, while all ERP.net interactions occur under one backend session. Relationship to Trusted Applications A Hybrid App is usually represented by a single Trusted Application in ERP.net configured as: Attribute Value Purpose ClientType Confidential Keeps a secret securely on the backend. ImpersonateAsInternalUserAllowed true Enables user sign-in for the front end. ImpersonateAsCommunityUserAllowed true Enables external users (partners/customers) to authenticate for identity. SystemUserAllowed true Enables background or service access. SystemUser <service_user> Defines which user identity the backend uses. Scope read update Specifies permissions available to both flows. Note This design allows one app identity to handle both interactive and background operations while maintaining strict isolation of tokens and permissions. For external-facing apps, it also ensures that ERP.net session consumption happens only once - through the service component using Client Credentials. Token Flows in Action flowchart LR subgraph Frontend[Frontend App] U[User] -->|Signs in| Web[Web App] Web -->|Auth Code Flow| IDP[ERP.net Identity] IDP -->|User Token| Web end subgraph Backend[Backend Service] S[Service Component] -->|Client Credentials Flow| IDP IDP -->|Service Token| S end Web -->|API Calls with User Token| API[ERP.net APIs] S -->|API Calls with Service Token| API API --> Data[(ERP.net Data)] The frontend uses Authorization Code Flow for user sessions. The backend uses Client Credentials Flow for automation. Both call the same APIs, but under different tokens and permissions. Best Practices Always store user and service tokens separately. Never reuse or mix them. Implement token caching per flow to avoid unnecessary re-authentication. Use refresh tokens only for the Authorization Code flow. Configure minimal scopes; typically, the backend requires broader permissions than the user front end. Audit your Trusted Application and System User regularly. Learn More Typical Architecture Explore how hybrid apps structure front-end and backend communication. Example Scenarios See how real hybrid patterns are implemented in practice. Trusted Applications and Access Control Understand how System User and impersonation settings define hybrid access."
  },
  "auth/flows/overview.html": {
    "href": "auth/flows/overview.html",
    "title": "OAuth 2.0 Authentication Flows Overview | ERP.net Developer Docs",
    "summary": "OAuth 2.0 Authentication Flows Overview Some authentication scenarios in ERP.net use OAuth 2.0–based flows - specific sequences of steps for obtaining and using tokens securely. Choosing the appropriate OAuth 2.0 flow depends on how your app interacts with users and how it connects to the APIs. All OAuth 2.0 flows are handled by ERP.net Identity. Why Flows Matter Each app has a different way of connecting: Some apps have users who sign in and work interactively. Others run in the background or on a schedule with no user present. Some do both - a user-facing front end and an automated backend. To support these patterns securely, ERP.net provides two OAuth 2.0 flows that can be used separately or together. Supported Authentication Flows Flow Who Authenticates Interaction Typical Use Case Authorization Code User Interactive (via web browser) Web apps, SPAs, mobile clients Client Credentials Application (service identity) Non-interactive Integrations, background jobs, schedulers Hybrid (combined) Both Mixed Apps that include both an interactive front end and a service backend Note Hybrid apps combine both flows: the front-end uses Authorization Code for user access, while the back-end uses Client Credentials for automation or elevated access. How It Works All flows follow the same secure pattern, handled by ERP.net Identity: flowchart LR subgraph UserSide[Interactive App] U[\uD83D\uDC64 User] -->|Signs in| App[\uD83D\uDCBB App] App -->|Auth Request| IDP[\uD83D\uDEE1️ ERP.net Identity] IDP -->|Access Token| App end subgraph ServiceSide[Service or Backend] S[⚙️ Background Service] -->|Token Request| IDP IDP -->|Access Token| S end App -->|API Calls| API[\uD83C\uDF9B️ ERP.net APIs] S -->|API Calls| API API --> D[(\uD83D\uDCCA ERP.net Data)] Note Every flow leads to the same outcome: a token issued by ERP.net Identity that defines who or what is calling the APIs, and what it's allowed to do. Choosing a Flow When selecting a flow, focus on how your app interacts with ERP.net: If your app has a user interface and acts on behalf of a signed-in user - use Authorization Code. If your app runs without user interaction - use Client Credentials. If your app has both a user-facing and a backend component - use Hybrid (combine both flows). For detailed decision guidance, see Choosing the Right Flow. Key Points to Remember Every app must be registered as a Trusted Application in the target ERP.net instance. Tokens are always issued by the instance's Identity. Sessions start only when a token is first used, not when issued. Refresh tokens are only for interactive clients. Client secrets must never be exposed in browsers or SPAs. One app can safely use both flows - just keep user tokens and service tokens separate. Learn More Interactive Apps (Authorization Code Flow) Learn how user-facing apps authenticate and obtain tokens. Service and Background Apps (Client Credentials Flow) Understand how backend and automated apps connect securely. Hybrid Apps Combine front-end and backend flows in one solution. Choosing the Right Flow Decide which flow best fits your app."
  },
  "auth/getting-started/automation.html": {
    "href": "auth/getting-started/automation.html",
    "title": "Automation with Reference Access Tokens | ERP.net Developer Docs",
    "summary": "Automation with Reference Access Tokens This topic describes how automated and integration scenarios authenticate to ERP.net APIs using reference access tokens (enrt_...), without interacting with the Instance ID or performing OAuth flows. Reference access tokens are manually issued, long-lived, opaque strings. intended for machine-driven access, background jobs, and developer automation where interactive sign-in is not practical or required. They are validated directly by ERP.net. Prerequisites A reference access token (enrt_445659C00F83CCA2D427BF113EFB355319346865C0B4FE5A3C76C16271B06AFF) must be issued in advance The token must include the required scopes for the target APIs The token must be valid and not expired Implementation This section demonstrates how to call ERP.net instance APIs using a reference access token. No OAuth flow is performed. 1. Provide the reference token Store the token securely and load it at runtime: REFERENCE_TOKEN = enrt_445659C00F83CCA2D427BF113EFB355319346865C0B4FE5A3C76C16271B06AFF 2. Call an API with the token Note The following example uses the Domain API to demonstrate how a reference access token is sent with an API request. Send the token in one of the supported headers. Option A: Authorization header GET /api/domain/odata/Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net Authorization: Bearer enrt_445659C00F83CCA2D427BF113EFB355319346865C0B4FE5A3C76C16271B06AFF Option B: API key header GET /api/domain/odata/Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net X-Api-Key: enrt_445659C00F83CCA2D427BF113EFB355319346865C0B4FE5A3C76C16271B06AFF Result If the token is valid and includes the required scopes, the API returns the requested data. Notes Use only one method per request (either Authorization or an API key header). Reference tokens are opaque and validated by ERP.net; they are not exchanged for other tokens."
  },
  "auth/getting-started/erpnet-id-web-apps.html": {
    "href": "auth/getting-started/erpnet-id-web-apps.html",
    "title": "ERP.net ID for Web Applications | ERP.net Developer Docs",
    "summary": "ERP.net ID for Web Applications ERP.net Identity acts as an external identity provider. It enables external applications to identify users and trust the identity information they receive. This topic covers the following scenario: A user signs in through ERP.net Identity The application receives a verified user identity The application uses the received identity to recognize the signed-in user Prerequisites ERP.net Identity must have a defined trusted application with the configuration below. Note The values shown below (such as myapp.myhost.net and the sign-in callback URL) are examples only. They must be replaced with values that match the actual domain and callback endpoint of your external application. Typical values are: ApplicationUri: a DNS name or URI that uniquely identifies your application (for example: myapp.myhost.net) ImpersonateLoginUrl: a publicly reachable callback endpoint handled by your backend (for example: https://myapp.myhost.net/signin-callback) Note The application owner must generate a random client secret, compute its Base64-encoded SHA-256 hash, and submit the hashed value via an internal ticket to erp.net so the Trusted Application can be registered and the configuration activated. Attribute Value Comment Name My trusted app Used only for user-friendly identification. ApplicationUri myapp.myhost.net The unique identifier of the trusted application. This value must be unique and is defined by the external application. IsEnabled true Enables the trusted application. ImpersonateAsInternalUserAllowed true Allows authentication of internal users. ImpersonateAsCommunityUserAllowed true Allows authentication of external (community) users. ImpersonateLoginUrl https://myapp.myhost.net/signin-callback The callback URL of the external application. This must exactly match the URL where the application listens for the sign-in response. ClientType Confidential Indicates that the external application is a confidential client and can securely store a secret. ApplicationSecretHash <base64(sha256(your-client-secret))> The hashed secret of the external application. Scope <empty> No scopes are required to be explicitly configured. All other attributes can keep their default values and are not relevant for this scenario. Implementation This section demonstrates a sign-in flow that uses a hybrid response type (code id_token) for compatibility with existing integrations. The flow also uses PKCE (Proof Key for Code Exchange). 1. Start sign-in (authorize request) The external application redirects the user's browser to the ERP.net Identity authorize endpoint at id.erp.net. Generate the following values per sign-in request: state – <base64url(random(32 bytes))> nonce – <base64url(random(32 bytes))> code_verifier - <random(64 chars)> code_challenge - <base64url(sha256(code_verifier))> Authorize request example: GET /id/connect/authorize? client_id=myapp.myhost.net& redirect_uri=https%3A%2F%2Fmyapp.myhost.net%2Fsignin-callback& response_type=code%20id_token& response_mode=form_post& scope=openid%20profile& state=YzQ5ZDc4M2QxN2Q0NDU3YjlhM2Y5OWE1ZTY4OTc0ZGM& nonce=ZTRjOTM2M2Y0ODFhNGQ0NGE4NmU1N2ExYjY2NjE3ZmQ& code_challenge=VZ9R6l3kPpJ6m2m9kR9cR9n8s3c7J4GmQ9FZp5mX1kQ& code_challenge_method=S256 Host: id.erp.net Note The openid and profile scopes are requested because this is an OpenID Connect authentication flow that issues an ID token with basic user claims; these scopes are not defined in the Trusted Application because they are protocol-level scopes provided automatically based on the authorization flow. 2. Receive the sign-in response (callback) After a successful sign-in, ERP.net Identity redirects the user to the configured callback URL using form_post. Example callback request received by the external application: POST /signin-callback/ HTTP/1.1 Host: myapp.myhost.net Content-Type: application/x-www-form-urlencoded code=SplxlOBeZQQYbYS6WxSbIA&state=YzQ5ZDc4M2QxN2Q0NDU3YjlhM2Y5OWE1ZTY4OTc0ZGM&id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiSldUIn0.eyJuYmYiOjE3NjY0OTM3ODEsImV4cCI6MTc2NjQ5NDA4MSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJQSyIsIm5vbmNlIjoiNjUwMTAwMWU0NGUzNGFlY2FiMTQzMTRiMDI4YzM0YzQiLCJpYXQiOjE3NjY0OTM3ODEsImF0X2hhc2giOiIwYWpYNkhYODNtbmJVNVhxVDUtUUZ3Iiwic19oYXNoIjoib1RRalZZUXdBRDZEMWV2TzlBTVNrUSIsInNpZCI6IkQxRkZFREZFNENCMzIzMDBEMjZDMjY1QjlCRDM3NEZCIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE3NjY0OTM0OTUsImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.hL4SpH9yoMx5j0e2KMmd6Xttw3M5ktRNbs39m2cJ0-8MvCIoeTkkNtasXS7burHX9mh1vxAow1kYYdcedOQNRWERyGsNQM3jy1yal5jCixBRTPkC86bkAeS_h9Q7gWWLFSrSeaHvi_xJGoRFBLymS44dM20kZxFI9o1qZfOX79hnNnIoF_j7BEV0u77lj7Bb7OE3Xh2cyBcn0-yQB9SmGhesvt5B2IqZ0odn6il_qMabnAK_sm80b-4HtA4w8uLCCpD4JBg6g4O2zmhm_jVUQtYsqS9VjPMA4F1-pTB3ayrP40Dvq_cGP5dPspenR2GCxJqAg0bQu8AcBqLJkVcD-w The external application must: Validate that the returned state equals the value sent in the authorize request Extract the authorization code 3. Exchange the authorization code (token request) The external application exchanges the authorization code at the token endpoint. The token request must include the original code_verifier. POST /id/connect/token HTTP/1.1 Host: id.erp.net Content-Type: application/x-www-form-urlencoded client_id=myapp.myhost.net& client_secret=<PLAIN_CLIENT_SECRET>& grant_type=authorization_code& code=SplxlOBeZQQYbYS6WxSbIA& redirect_uri=https%3A%2F%2Fmyapp.myhost.net%2Fsignin-callback& code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk Example token response: HTTP/1.1 200 OK Content-Type: application/json { \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiSldUIn0.eyJuYmYiOjE3NjY0OTM3ODEsImV4cCI6MTc2NjQ5NDA4MSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJQSyIsIm5vbmNlIjoiNjUwMTAwMWU0NGUzNGFlY2FiMTQzMTRiMDI4YzM0YzQiLCJpYXQiOjE3NjY0OTM3ODEsImF0X2hhc2giOiIwYWpYNkhYODNtbmJVNVhxVDUtUUZ3Iiwic19oYXNoIjoib1RRalZZUXdBRDZEMWV2TzlBTVNrUSIsInNpZCI6IkQxRkZFREZFNENCMzIzMDBEMjZDMjY1QjlCRDM3NEZCIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE3NjY0OTM0OTUsImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.hL4SpH9yoMx5j0e2KMmd6Xttw3M5ktRNbs39m2cJ0-8MvCIoeTkkNtasXS7burHX9mh1vxAow1kYYdcedOQNRWERyGsNQM3jy1yal5jCixBRTPkC86bkAeS_h9Q7gWWLFSrSeaHvi_xJGoRFBLymS44dM20kZxFI9o1qZfOX79hnNnIoF_j7BEV0u77lj7Bb7OE3Xh2cyBcn0-yQB9SmGhesvt5B2IqZ0odn6il_qMabnAK_sm80b-4HtA4w8uLCCpD4JBg6g4O2zmhm_jVUQtYsqS9VjPMA4F1-pTB3ayrP40Dvq_cGP5dPspenR2GCxJqAg0bQu8AcBqLJkVcD-w\", \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjY0OTM3ODEsImV4cCI6MTc2NjQ5NzM4MSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJodHRwczovL2UxLWRldi5sb2NhbC9pZC9yZXNvdXJjZXMiLCJjbGllbnRfaWQiOiJQSyIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNzY2NDkzNDk1LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IkpvaG4gRG9lIiwiZW1haWwiOiJhZG1pbkBtYWlsLmNvbSIsInVzZXJfdHlwZSI6IkludGVybmFsVXNlciIsImlzX2FkbWluIjoidHJ1ZSIsImVtYWlsX3ZlcmlmaWVkIjoiZmFsc2UiLCJkYiI6IkUxX0RFVi0xIFRlc3QiLCJsb2NhbGUiOiJiZyIsImp0aSI6IkM4MTcxRjlFQ0FEN0U2OThEMjBFN0Q2Qjc5ODQyMjYwIiwic2lkIjoiRDFGRkVERkU0Q0IzMjMwMEQyNkMyNjVCOUJEMzc0RkIiLCJpYXQiOjE3NjY0OTM3ODEsInNjb3BlIjpbIm9wZW5pZCIsInByb2ZpbGUiXSwiYW1yIjpbInB3ZCJdfQ.TWePn6yinGcAaItZzfmNM9en3ESfGFhcLulTR7U7wfVK86RW9s8LlsgqoAc2SkigH2cXrovnADCe8uwp7BFSKbQBsN18vH5GmidFpILEr-M_WnOWfFZt941SA04vXpBzDJaiunzRl4FAEMd4RKXJ2L_wCZW8DNaKmsZfS9SH8N6QAYABrNoHZbrRV83pUh7suUnsBF_Ps-jdFNTnuxoj4UooRghAp7dn6LYw3MBcTb3GNdrJosb63DXpQY-Kq58gbYrov0Of4H_RD6lEaKcFbRVmIpg5S1UoM2DFaS-PWxKN_DF9_4A8zazBHM8BgGN4hA7JPOv6W7waODLvNqhnzQ\", \"expires_in\": 3600, \"scope\": \"openid profile\" } The application can use the returned ID token to identify and recognize the signed-in user. Implementation considerations Because the application is a confidential client, the sign-in callback must be handled by a backend component. Handling the callback in frontend code would expose sensitive data. For the same reason, the token request must be performed by the backend. The client secret is stored and used there and must never be sent to or stored in the frontend. The client secret must never be exposed in browser code, mobile apps, or any other client-side environment. The state value must be generated per sign-in request and validated on callback. Skipping this opens the door to CSRF attacks. The code_verifier must be generated per request and stored securely until the token exchange is performed. The nonce value must be unique per sign-in request and validated against the ID token. Reusing a static nonce defeats its purpose. ERP.net Identity at id.erp.net does not allow embedding in iframes. If authentication is initiated from within an iframe, the sign-in flow must be opened in a popup window or a top-level browser navigation."
  },
  "auth/getting-started/instance-id-spa-apps.html": {
    "href": "auth/getting-started/instance-id-spa-apps.html",
    "title": "Instance ID for SPA Applications | ERP.net Developer Docs",
    "summary": "Instance ID for SPA Applications This topic describes how a Single Page Application (SPA) with no backend component, running entirely in the user's browser, integrates with an ERP.net Instance ID in order to authenticate users and access protected APIs. The following scenario is covered: The external application is a Single Page Application (SPA) running entirely in the user's browser The application is a public client and cannot keep a secret The application uses the Authorization Code flow with PKCE The application authenticates users and obtains tokens from a specific ERP.net instance The application uses the obtained access token to call APIs on behalf of the signed-in user The Instance ID is the identity provider of a specific ERP.net instance. It's used by external applications to authenticate and authorize users against a concrete ERP.net instance. For example, if your ERP.net instance is located at: https://mycompany.my.erp.net then the corresponding Instance ID endpoints are located at: https://mycompany.my.erp.net/id Prerequisites Your ERP.net instance must have a trusted application defined with the configuration below. Note The values shown below are examples only and must be replaced with values that match your SPA. Typical values: ApplicationUri: spa.example.com ImpersonateLoginUrl: https://spa.example.com/signin-callback Attribute Value Comment Name My SPA app Used only for user-friendly identification. ApplicationUri spa.example.com The unique identifier of the SPA. IsEnabled true Enables the trusted application. ImpersonateAsInternalUserAllowed true Allows authentication by internal users. ImpersonateAsCommunityUserAllowed false Disallows authentication by external (community) users. ImpersonateLoginUrl https://spa.example.com/signin-callback The callback URL handled by the SPA after sign-in. ClientType Public Indicates that the application is a public client and cannot keep a secret. Scope read or read update Use read for read-only access; include update only if the application must create, modify, or delete data All other attributes can keep their default values and are not relevant for this scenario. Implementation This section demonstrates the Authorization Code flow with PKCE against the Instance ID. 1. Start sign-in (authorize request) Before starting the sign-in flow, the SPA generates: state – <base64url(random(32 bytes))> nonce – <base64url(random(32 bytes))> code_verifier - <random(64 chars)> code_challenge - <base64url(sha256(code_verifier))> The SPA then redirects the browser to the ERP.net Instance ID authorize endpoint: GET /id/connect/authorize? client_id=spa.example.com& redirect_uri=https%3A%2F%2Fspa.example.com%2Fsignin-callback& response_type=code& scope=openid%20profile%20read%20update& state=YzQ5ZDc4M2QxN2Q0NDU3YjlhM2Y5OWE1ZTY4OTc0ZGM& nonce=ZTRjOTM2M2Y0ODFhNGQ0NGE4NmU1N2ExYjY2NjE3ZmQ& code_challenge=VZ9R6l3kPpJ6m2m9kR9cR9n8s3c7J4GmQ9FZp5mX1kQ& code_challenge_method=S256 Host: mycompany.my.erp.net Note The openid and profile scopes are requested because this is an OpenID Connect authentication flow that issues an ID token with basic user claims; these scopes are not defined in the Trusted Application because they are protocol-level scopes provided automatically based on the authorization flow. The requested scopes define the level of access the SPA will have to the instance APIs. Common resource scopes: read – allows read-only access to instance resources update – allows update access to instance resources Request only the scopes required by the application. Granting broader scopes than necessary increases the impact of a compromised token. Result: The user is redirected to the ERP.net login page and signs in. 2. Receive the sign-in response (callback) After a successful sign-in, ERP.net Instance ID redirects the browser back to the configured callback URL. Example redirect received by the SPA: GET /signin-callback? code=SplxlOBeZQQYbYS6WxSbIA& state=YzQ5ZDc4M2QxN2Q0NDU3YjlhM2Y5OWE1ZTY4OTc0ZGM Host: spa.example.com The SPA must: Validate that the returned state equals the original value Extract the authorization code Preserve the original code_verifier for the token request 3. Exchange the authorization code (token request) The SPA exchanges the authorization code at the ERP.net Instance ID token endpoint. Because the application is a public client, no client secret is sent. The request must include the original code_verifier. POST /id/connect/token HTTP/1.1 Host: mycompany.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=authorization_code& client_id=spa.example.com& code=SplxlOBeZQQYbYS6WxSbIA& redirect_uri=https%3A%2F%2Fspa.example.com%2Fsignin-callback& code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk Example token response: HTTP/1.1 200 OK Content-Type: application/json { \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjY0OTQzOTQsImV4cCI6MTc2NjQ5Nzk5NCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOlsiRG9tYWluQVBJIiwiVGFibGVBUEkiLCJPTEFQIiwiQXBwU2VydmVyIiwiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQvcmVzb3VyY2VzIl0sImNsaWVudF9pZCI6IlBLIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE3NjY0OTM0OTUsImlkcCI6ImxvY2FsIiwiaWQiOiI5ZGE2NDgzOS1hOGQwLTQ5MWQtYWViYi00ZDE4ZmE0MmIwMTQiLCJuYW1lIjoiSm9obiBEb2UiLCJlbWFpbCI6ImFkbWluQG1haWwuY29tIiwidXNlcl90eXBlIjoiSW50ZXJuYWxVc2VyIiwiaXNfYWRtaW4iOiJ0cnVlIiwiZW1haWxfdmVyaWZpZWQiOiJmYWxzZSIsImRiIjoiRTFfREVWLTEgVGVzdCIsImxvY2FsZSI6ImJnIiwianRpIjoiNUIyNzBBRDU2RDA5OTU1QzQ0Qzg0NjdFODI0NkM4ODEiLCJzaWQiOiJEMUZGRURGRTRDQjMyMzAwRDI2QzI2NUI5QkQzNzRGQiIsImlhdCI6MTc2NjQ5NDM5NCwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsInJlYWQiLCJ1cGRhdGUiXSwiYW1yIjpbInB3ZCJdfQ.VeTP6xc1tKxqybNxficqpNz2zvpgJ-zn0evArsYd7oJYTmEqWOiCa4cfM5w4NSpUr_TuSqcrs4o3TO0-aJYvhJ2l3-NhjSDtQTeevHLGw78V_xh5EDVS0JEhhCqNrl0tABXEa5Sn-bNNEc2UDIDlsEy0LPAKIbL9p2iCgZu1jPJcvZoVR_P3l9K0SjDm-DE_OHNEqju_hX7uV70J7O7ZiSoleaJVWK2l26YcwoII0VxtP-rOpUOIQx1RBCGMSFg4W5sUGvfj0MLnt1aMztQ2iI2Ai8pqyxq09te_UQOTSUxcpwHbsBcROCFc1Lb8s-uKwpPf8WkoZpOMtJg18gLe8Q\", \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiSldUIn0.eyJuYmYiOjE3NjY0OTQzOTQsImV4cCI6MTc2NjQ5NDY5NCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJQSyIsIm5vbmNlIjoiYjdjMTY3ZWU4NDVjNGFjMWJhYTZjNWFjMTA5Y2RlYTIiLCJpYXQiOjE3NjY0OTQzOTQsImF0X2hhc2giOiJIUU9RQVFnb3ZVbVE4U2ZCZFQteW9RIiwic19oYXNoIjoiV1hjUTc3aHlKb2o5M3YwT1o1UlpQZyIsInNpZCI6IkQxRkZFREZFNENCMzIzMDBEMjZDMjY1QjlCRDM3NEZCIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE3NjY0OTM0OTUsImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.dgYjJV9KrEZ39RgXv7O-Fxux5Rk6vXGJN4MW6IkRzHQIP1hr_CivtOWKx8dMVWb1LTLLBh-Lxkuylu48C2i6lBv_gU8mp-NATHer-d5r2TZkYWeO-Ml7EoLStkHxND34mZG3u0fCjhhUAdBsCAr8yidct32G0YPRS6LBxL_EtiXAncabE0WzulhcbwXo0NzohQowFKL9V3yz3DaK0oKkfkmmvkuAJkAO0rSJYtai-q7G8eiTwCk0TwDTX6_TawMy29gMYuYnHMZ00-FjnG2kA9JBqpbcSSCw4PfFiWCOEPcPsBRn28Hdv46OWaxZ2nBbk2pjkaNjva0olTyItcAcdQ\", \"expires_in\": 3600, \"scope\": \"openid profile read update\" } The SPA can now: Validate the ID token to identify the user Use the access token to call APIs on behalf of the signed-in user Security and implementation considerations SPAs are public clients. A client secret must never be used or expected. PKCE is mandatory and must not be omitted. The state value must be generated per request and validated on callback. The nonce value must be validated against the ID token. Tokens must be stored carefully (for example, in memory). Persistent browser storage increases exposure. The Instance ID does not allow embedding. If authentication is initiated from within an iframe, the sign-in flow must be opened in a popup window or top-level navigation. Redirect URIs must exactly match the configured value."
  },
  "auth/getting-started/instance-id-web-apps.html": {
    "href": "auth/getting-started/instance-id-web-apps.html",
    "title": "Instance ID for Web (Confidential) Applications | ERP.net Developer Docs",
    "summary": "Instance ID for Web (Confidential) Applications This topic describes how a confidential external application with a backend component capable of securely storing a secret integrates with an ERP.net Instance ID in order to authenticate users and access protected APIs. The following scenario is covered: The external application is a confidential application The application has a backend component capable of securely storing a secret The application authenticates users against a specific ERP.net instance The application uses the Authorization Code flow The application obtains tokens to call instance APIs on behalf of the signed-in user The Instance ID is the identity provider of a specific ERP.net instance. Confidential applications use it to authenticate users and obtain tokens against a concrete ERP.net instance. For example, if your ERP.net instance is located at: https://mycompany.my.erp.net then the corresponding Instance ID endpoints are located at: https://mycompany.my.erp.net/id Prerequisites Your ERP.net instance must have a trusted application defined with the configuration below. Note The values shown below are examples only and must be replaced with values that match your application. Typical values: ApplicationUri: backend.example.com ImpersonateLoginUrl: https://backend.example.com/signin-callback Note The application owner must generate a random client secret, compute its Base64-encoded SHA-256 hash, and submit the hashed value via an internal ticket to erp.net so the Trusted Application can be registered and the configuration activated. Attribute Value Comment Name My confidential app Used only for user-friendly identification. ApplicationUri backend.example.com The unique identifier of the application. IsEnabled true Enables the trusted application. ImpersonateAsInternalUserAllowed true Allows authentication by internal users. ImpersonateAsCommunityUserAllowed false Disallow authentication by external (community) users. ImpersonateLoginUrl https://backend.example.com/signin-callback The callback URL handled by the backend after sign-in. ClientType Confidential Indicates that the application can securely store a secret. ApplicationSecretHash <base64(sha256(your-client-secret))> The hashed client secret used during the token request. Scope read or read update Use read for read-only access; include update only if the application must create, modify, or delete data All other attributes can keep their default values and are not relevant for this scenario. Implementation This section demonstrates the Authorization Code flow against the Instance ID for a confidential application. 1. Start sign-in (authorize request) The application redirects the user's browser to the Instance ID authorize endpoint. For each sign-in request, generate: state – <base64url(random(32 bytes))> nonce – <base64url(random(32 bytes))> code_verifier - <random(64 chars)> code_challenge - <base64url(sha256(code_verifier))> Authorize request example: GET /id/connect/authorize? client_id=backend.example.com& redirect_uri=https%3A%2F%2Fbackend.example.com%2Fsignin-callback& response_type=code%20id_token& response_mode=form_post& scope=openid%20profile%20offline_access%20read%20update& state=YzQ5ZDc4M2QxN2Q0NDU3YjlhM2Y5OWE1ZTY4OTc0ZGM& nonce=ZTRjOTM2M2Y0ODFhNGQ0NGE4NmU1N2ExYjY2NjE3ZmQ& code_challenge=VZ9R6l3kPpJ6m2m9kR9cR9n8s3c7J4GmQ9FZp5mX1kQ& code_challenge_method=S256 Host: mycompany.my.erp.net The requested scopes define the level of access the application will have to the instance APIs. Common resource scopes: read – allows read-only access to instance resources update – allows update access to instance resources Request only the scopes required by the application. Granting broader scopes than necessary increases the impact of a compromised token. Note The openid and profile scopes are requested because this is an OpenID Connect authentication flow that issues an ID token with basic user claims; these scopes are not defined in the Trusted Application because they are protocol-level scopes provided automatically based on the authorization flow. Result: The user is redirected to the ERP.net login page and signs in. 2. Receive the sign-in response (callback) After a successful sign-in, the ERP.net Instance ID redirects the user back to the configured callback URL. Example callback request received by the backend: GET /signin-callback? code=SplxlOBeZQQYbYS6WxSbIA& state=YzQ5ZDc4M2QxN2Q0NDU3YjlhM2Y5OWE1ZTY4OTc0ZGM Host: backend.example.com The backend must: Validate that the returned state equals the original value Extract the authorization code Preserve the original code_verifier for the token request 3. Exchange the authorization code (token request) The backend exchanges the authorization code at the Instance ID token endpoint. Because the application is confidential, the request includes the client secret. The request must include the original code_verifier. POST /id/connect/token HTTP/1.1 Host: mycompany.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=authorization_code& client_id=backend.example.com& client_secret=<PLAIN_CLIENT_SECRET>& code=SplxlOBeZQQYbYS6WxSbIA& redirect_uri=https%3A%2F%2Fbackend.example.com%2Fsignin-callback& code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk Example token response: HTTP/1.1 200 OK Content-Type: application/json { \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjY0OTQzNDYsImV4cCI6MTc2NjQ5Nzk0NiwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOlsiRG9tYWluQVBJIiwiVGFibGVBUEkiLCJPTEFQIiwiQXBwU2VydmVyIiwiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQvcmVzb3VyY2VzIl0sImNsaWVudF9pZCI6IlBLIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE3NjY0OTM0OTUsImlkcCI6ImxvY2FsIiwiaWQiOiI5ZGE2NDgzOS1hOGQwLTQ5MWQtYWViYi00ZDE4ZmE0MmIwMTQiLCJuYW1lIjoiSm9obiBEb2UiLCJlbWFpbCI6ImFkbWluQG1haWwuY29tIiwidXNlcl90eXBlIjoiSW50ZXJuYWxVc2VyIiwiaXNfYWRtaW4iOiJ0cnVlIiwiZW1haWxfdmVyaWZpZWQiOiJmYWxzZSIsImRiIjoiRTFfREVWLTEgVGVzdCIsImxvY2FsZSI6ImJnIiwianRpIjoiQTUwODY2NDY2NjU3QjM0QjAxNjlGNTRCMTZEODdGN0QiLCJzaWQiOiJEMUZGRURGRTRDQjMyMzAwRDI2QzI2NUI5QkQzNzRGQiIsImlhdCI6MTc2NjQ5NDM0Niwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsInJlYWQiLCJ1cGRhdGUiLCJvZmZsaW5lX2FjY2VzcyJdLCJhbXIiOlsicHdkIl19.c9hwe4Jq9V3EoNWugPAcbGbgV_YTLf5MM2HaeUCCvsHdinE5G-g9ZPlVNR8HtQwkz_pzZd192U2_WkrhqweWWsOsAnSihfLlmOQIY0ak2z50_CTpatyHzVkgXGhTieBrCa8myaiBNO57trs9f8kGSbEsx6y3GxCiOd4TDLtfAtDRHyvUmI5PKZLle4dzmVph_srZOS4a4JmOrJGFFJ3hNB5y-dytDV0UNuzrl3QzbyEbU9HJPwCAObXNJf-LqqSnK_CEY54NnUx9IY4UGsUskOg7g131FvDF9Bx_jz7JYEruNfMeq6UTUVjiNJUWaOF7G_twOR5r9w9wbawTt8uV6Q\", \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiSldUIn0.eyJuYmYiOjE3NjY0OTQzNDYsImV4cCI6MTc2NjQ5NDY0NiwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJQSyIsIm5vbmNlIjoiNzdlN2JjOGQ1NjI4NDI3Njk2NjdiNDM0MjliZWFmODUiLCJpYXQiOjE3NjY0OTQzNDYsImF0X2hhc2giOiJXRGtwcms1UWZScm9YTVJhMlEwckhBIiwic19oYXNoIjoiV044dE14Y2VFVFJkNkVaUmxNeWYwQSIsInNpZCI6IkQxRkZFREZFNENCMzIzMDBEMjZDMjY1QjlCRDM3NEZCIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE3NjY0OTM0OTUsImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.Hle13-x4R5INI9VAOqjn_i7frwmf3_jIrDYh_Kg9tyRpg5EExzPSu-Lr0cyulE_hTXG7aFf-a4XYq_fu37mi2XtiXtiqasuOiPzF5PETuxSgn8F8wBfqIxm6EFW-H4cIfxLeY6ODVEEzax4iWAUvKwQkYPRUWMe8GXJLoEIz8JjBaW0kQUFy-djOVNoJcdytqeEAG3oG6vtvAP51sBijWrWPe4JCz_ly7fVa34BTICfH1MigWicUJcFmXx1CwPC9CoSWOqcEleHV3W-R9YesnOUFRgEOiNeSpeUhhXE7HtRZgxWqCjQAQ_AElsSO-pahQ8mWRgpIrn7x_nUXyzRXZQ\", \"refresh_token\": \"CEA03BDB9ADF650B43215BD114962DEFFBF99B75957F5DFDC781E7315A1CE9E4\", \"expires_in\": 3600, \"scope\": \"openid profile offline_access read update\" } The application can now: Validate the ID token to identify the user Use the access token to call instance APIs on behalf of the signed-in user Security and implementation considerations Confidential applications must handle callbacks and token requests on the backend. The client secret must never be exposed to frontend code. PKCE is recommended even for confidential clients to reduce authorization code interception risks. The state and nonce values must be generated per request and validated. Redirect URIs must exactly match the configured value. The Instance ID does not allow embedding. If authentication is initiated from within an iframe, the sign-in flow must be opened in a popup window or top-level navigation."
  },
  "auth/getting-started/instance-id-web-portals.html": {
    "href": "auth/getting-started/instance-id-web-portals.html",
    "title": "Instance ID for Web Portals | ERP.net Developer Docs",
    "summary": "Instance ID for Web Portals This topic describes how a web portal integrates with an ERP.net Instance ID using both the Authorization Code flow and the Client Credentials flow within a single confidential application. A typical example of such a web portal is an online store, where users sign in to manage their profile or place orders, while all backend operations and API calls are performed by the application itself. Scenario Overview The following scenario is covered: The external application is a confidential web application (portal) The application has a backend component capable of securely storing a secret Users sign in interactively (internal and/or external) The application uses: Authorization Code flow to authenticate users Client Credentials flow to access instance APIs API calls are executed using a service identity A single Trusted Application is used for both flows The Instance ID is the identity provider of a specific ERP.net instance. Confidential applications use it to authenticate users and obtain tokens against a concrete ERP.net instance. For example, if your ERP.net instance is located at: https://mycompany.my.erp.net then the corresponding Instance ID endpoints are located at: https://mycompany.my.erp.net/id Design Goal The goal of this approach is to clearly separate user authentication from API access. Users are authenticated to establish identity and session context API access is performed using a service identity, not the user External (community) users can sign in without receiving API permissions Backend integrations remain stable and centrally controlled Flow Separation Purpose Flow Used Token Used Identity User sign-in Authorization Code ID token Signed-in user API access Client Credentials Access token Application system user In this model, the Authorization Code flow is used only to identify the user, while the Client Credentials flow is used to authorize all API calls. Prerequisites Your ERP.net instance must have a trusted application defined with the configuration below. Note The values shown below are examples only and must be replaced with values that match your application. Typical values: ApplicationUri: portal.example.com ImpersonateLoginUrl: https://portal.example.com/signin-callback SystemUser: <an-internal-erp-user> Note The application owner must generate a random client secret, compute its Base64-encoded SHA-256 hash, and submit the hashed value via an internal ticket to erp.net so the Trusted Application can be registered and the configuration activated. Attribute Value Comment Name My web portal Used only for user-friendly identification. ApplicationUri portal.example.com The unique identifier of the application. IsEnabled true Enables the trusted application. SystemUserAllowed true Allows the application to authenticate as a service. SystemUser <an-internal-erp-user> The internal user used for service authentication. ImpersonateAsInternalUserAllowed true Allows authentication by internal users. ImpersonateAsCommunityUserAllowed true Allows authentication by external (community) users. ImpersonateLoginUrl https://portal.example.com/signin-callback The callback URL handled by the backend after sign-in. ClientType Confidential Indicates that the application can securely store a secret. ApplicationSecretHash <base64(sha256(your-client-secret))> The hashed client secret used during token requests. Scope read or read update Use read for read-only access; include update only if the application must create, modify, or delete data All other attributes can keep their default values and are not relevant for this scenario. Implementation This section demonstrates how a web portal uses: Authorization Code flow to authenticate users Client Credential flow to obtain access tokens for calling instance APIs 1. Start user sign-in (Authorization Code) The portal redirects the user's browser to the Instance ID authorize endpoint. For each sign-in request, generate: state – <base64url(random(32 bytes))> nonce – <base64url(random(32 bytes))> code_verifier – <random(64 chars)> code_challenge – <base64url(sha256(code_verifier))> Authorize request example: GET /id/connect/authorize? client_id=portal.example.com& redirect_uri=https%3A%2F%2Fportal.example.com%2Fsignin-callback& response_type=code%20id_token& response_mode=form_post& scope=openid%20profile& state=YzQ5ZDc4M2QxN2Q0NDU3YjlhM2Y5OWE1ZTY4OTc0ZGM& nonce=ZTRjOTM2M2Y0ODFhNGQ0NGE4NmU1N2ExYjY2NjE3ZmQ& code_challenge=VZ9R6l3kPpJ6m2m9kR9cR9n8s3c7J4GmQ9FZp5mX1kQ& code_challenge_method=S256 Host: mycompany.my.erp.net Result: The user is redirected to the ERP.net login page and signs in. Note The openid and profile scopes are requested because this is an OpenID Connect authentication flow that issues an ID token with basic user claims; these scopes are not defined in the Trusted Application because they are protocol-level scopes provided automatically based on the authorization flow. 2. Receive the sign-in response (callback) After a successful sign-in, the ERP.net Instance ID redirects the user back to the configured callback URL. Example callback request received by the backend: GET /signin-callback? code=SplxlOBeZQQYbYS6WxSbIA& state=YzQ5ZDc4M2QxN2Q0NDU3YjlhM2Y5OWE1ZTY4OTc0ZGM Host: portal.example.com The backend must: Validate that the returned state equals the original value Extract the authorization code Preserve the original code_verifier for the token request 3. Exchange the authorization code (user tokens) The backend exchanges the authorization code at the Instance ID token endpoint. Because the application is confidential, the request includes the client secret. The request must include the original code_verifier. Note In this portal model, tokens from this step are used for user identification (ID token validation), not for calling instance APIs. POST /id/connect/token HTTP/1.1 Host: mycompany.my.erp.net Content-Type: application/x-www-form-urlencoded grant_type=authorization_code& client_id=portal.example.com& client_secret=<PLAIN_CLIENT_SECRET>& code=SplxlOBeZQQYbYS6WxSbIA& redirect_uri=https%3A%2F%2Fportal.example.com%2Fsignin-callback& code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk Example token response: HTTP/1.1 200 OK Content-Type: application/json { \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiSldUIn0.eyJuYmYiOjE3NjY0OTM3ODEsImV4cCI6MTc2NjQ5NDA4MSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJQSyIsIm5vbmNlIjoiNjUwMTAwMWU0NGUzNGFlY2FiMTQzMTRiMDI4YzM0YzQiLCJpYXQiOjE3NjY0OTM3ODEsImF0X2hhc2giOiIwYWpYNkhYODNtbmJVNVhxVDUtUUZ3Iiwic19oYXNoIjoib1RRalZZUXdBRDZEMWV2TzlBTVNrUSIsInNpZCI6IkQxRkZFREZFNENCMzIzMDBEMjZDMjY1QjlCRDM3NEZCIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE3NjY0OTM0OTUsImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.hL4SpH9yoMx5j0e2KMmd6Xttw3M5ktRNbs39m2cJ0-8MvCIoeTkkNtasXS7burHX9mh1vxAow1kYYdcedOQNRWERyGsNQM3jy1yal5jCixBRTPkC86bkAeS_h9Q7gWWLFSrSeaHvi_xJGoRFBLymS44dM20kZxFI9o1qZfOX79hnNnIoF_j7BEV0u77lj7Bb7OE3Xh2cyBcn0-yQB9SmGhesvt5B2IqZ0odn6il_qMabnAK_sm80b-4HtA4w8uLCCpD4JBg6g4O2zmhm_jVUQtYsqS9VjPMA4F1-pTB3ayrP40Dvq_cGP5dPspenR2GCxJqAg0bQu8AcBqLJkVcD-w\", \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjY0OTM3ODEsImV4cCI6MTc2NjQ5NzM4MSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJodHRwczovL2UxLWRldi5sb2NhbC9pZC9yZXNvdXJjZXMiLCJjbGllbnRfaWQiOiJQSyIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNzY2NDkzNDk1LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IkpvaG4gRG9lIiwiZW1haWwiOiJhZG1pbkBtYWlsLmNvbSIsInVzZXJfdHlwZSI6IkludGVybmFsVXNlciIsImlzX2FkbWluIjoidHJ1ZSIsImVtYWlsX3ZlcmlmaWVkIjoiZmFsc2UiLCJkYiI6IkUxX0RFVi0xIFRlc3QiLCJsb2NhbGUiOiJiZyIsImp0aSI6IkM4MTcxRjlFQ0FEN0U2OThEMjBFN0Q2Qjc5ODQyMjYwIiwic2lkIjoiRDFGRkVERkU0Q0IzMjMwMEQyNkMyNjVCOUJEMzc0RkIiLCJpYXQiOjE3NjY0OTM3ODEsInNjb3BlIjpbIm9wZW5pZCIsInByb2ZpbGUiXSwiYW1yIjpbInB3ZCJdfQ.TWePn6yinGcAaItZzfmNM9en3ESfGFhcLulTR7U7wfVK86RW9s8LlsgqoAc2SkigH2cXrovnADCe8uwp7BFSKbQBsN18vH5GmidFpILEr-M_WnOWfFZt941SA04vXpBzDJaiunzRl4FAEMd4RKXJ2L_wCZW8DNaKmsZfS9SH8N6QAYABrNoHZbrRV83pUh7suUnsBF_Ps-jdFNTnuxoj4UooRghAp7dn6LYw3MBcTb3GNdrJosb63DXpQY-Kq58gbYrov0Of4H_RD6lEaKcFbRVmIpg5S1UoM2DFaS-PWxKN_DF9_4A8zazBHM8BgGN4hA7JPOv6W7waODLvNqhnzQ\", \"expires_in\": 3600, \"scope\": \"openid profile\" } The application can now validate the ID token to identify the user. 4. Request an access token for API calls (Client Credentials) The portal backend requests an access token using the Client Credentials flow. POST /id/connect/token HTTP/1.1 Host: mycompany.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=portal.example.com& client_secret=<PLAIN_CLIENT_SECRET>& grant_type=client_credentials& scope=read%20update Note The client_secret is sent as a plain (unhashed) value and must exactly match the secret configured for the trusted application. Result: If the request is successful, the Instance ID returns an access token. { \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjY1MDUxNDcsImV4cCI6MTc2NjUwODc0NywiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOlsiRG9tYWluQVBJIiwiVGFibGVBUEkiLCJPTEFQIiwiQXBwU2VydmVyIiwiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQvcmVzb3VyY2VzIl0sImNsaWVudF9pZCI6IlBLIiwiY2xpZW50X3N5c3RlbV91c2VyIjoiYWRtaW4iLCJjbGllbnRfc3lzdGVtX3VzZXJfdHlwZSI6IkludGVybmFsVXNlciIsImNsaWVudF9kYiI6IkUxX0RFVi0xIFRlc3QiLCJqdGkiOiI4RDBCNzA1NTczQTFBOThGREJBREZGMENEN0Y3RUVCNCIsImlhdCI6MTc2NjUwNTE0Nywic2NvcGUiOlsicmVhZCIsInVwZGF0ZSJdfQ.MRvH-EtWu-PWDhjDDn73OVQwH29DZ_RRu6XheFsoRxImyjLQRIU7-S1GuyTnnqPyXEEkGkKTu_s3IEwxGORgY48jLH3l1juJDt8_JvcyJlIdhVZSZNC1Bpft_K1NJswJ6QmJ6bWgev7cqHaxM3p7AEEPjkSmnAjdBCz7ItMV93Yio5kCRBmP9DQUoxtL0webG7zV_f5uOkt8xhbUVHpdU9FQY-XLf_heLJv_81vvpf39kPxD4WTZRly8X_mNdlqi0DxiFXK3TFOnbdoLKxeljke8jV0t-agaHWcZ4B-SMQ77falwtFaxrEzXDY4g-iUg2kl_tABOUxzoqyFkGZm3DA\", \"expires_in\": 3600, \"token_type\": \"Bearer\", \"scope\": \"read update\" } 5. Call instance APIs using the service access token The following example uses the Domain API. GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: mycompany.my.erp.net Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjY1MDUxNDcsImV4cCI6MTc2NjUwODc0NywiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOlsiRG9tYWluQVBJIiwiVGFibGVBUEkiLCJPTEFQIiwiQXBwU2VydmVyIiwiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQvcmVzb3VyY2VzIl0sImNsaWVudF9pZCI6IlBLIiwiY2xpZW50X3N5c3RlbV91c2VyIjoiYWRtaW4iLCJjbGllbnRfc3lzdGVtX3VzZXJfdHlwZSI6IkludGVybmFsVXNlciIsImNsaWVudF9kYiI6IkUxX0RFVi0xIFRlc3QiLCJqdGkiOiI4RDBCNzA1NTczQTFBOThGREJBREZGMENEN0Y3RUVCNCIsImlhdCI6MTc2NjUwNTE0Nywic2NvcGUiOlsicmVhZCIsInVwZGF0ZSJdfQ.MRvH-EtWu-PWDhjDDn73OVQwH29DZ_RRu6XheFsoRxImyjLQRIU7-S1GuyTnnqPyXEEkGkKTu_s3IEwxGORgY48jLH3l1juJDt8_JvcyJlIdhVZSZNC1Bpft_K1NJswJ6QmJ6bWgev7cqHaxM3p7AEEPjkSmnAjdBCz7ItMV93Yio5kCRBmP9DQUoxtL0webG7zV_f5uOkt8xhbUVHpdU9FQY-XLf_heLJv_81vvpf39kPxD4WTZRly8X_mNdlqi0DxiFXK3TFOnbdoLKxeljke8jV0t-agaHWcZ4B-SMQ77falwtFaxrEzXDY4g-iUg2kl_tABOUxzoqyFkGZm3DA Security and implementation considerations The client secret must never be exposed to frontend code. Use Authorization Code flow tokens for identity and session context only. Use Client Credentials flow tokens for all API calls. Restrict scopes to the minimum required by the portal backend. The state and nonce values must be generated per request and validated. Redirect URIs must exactly match the configured value. The Instance ID does not allow embedding. If authentication is initiated from within an iframe, the sign-in flow must be opened in a popup window or top-level navigation."
  },
  "auth/getting-started/overview.html": {
    "href": "auth/getting-started/overview.html",
    "title": "Overview | ERP.net Developer Docs",
    "summary": "Overview This section contains standalone, step-by-step quickstarts for implementing authentication in common ERP.net application scenarios. Each quickstart focuses on one application type and uses the recommended identity authority and integration approach for that scenario. Choose the quickstart that matches your application type-you don't need to follow them in order. If you're looking for the underlying concepts (identity authorities, flows, tokens, scopes), see: Concepts. Choose your scenario Interactive applications (user sign-in) ERP.net ID for Web Applications Use ERP.net as an external Identity Provider for user sign-in in your web application. Instance ID for SPA Applications Authenticate users in a Single Page Application against a specific ERP.net instance. Instance ID for Web Applications Authenticate users in a web application against a specific ERP.net instance. Instance ID for Web Portals Implement authentication for portal-style applications that access a specific ERP.net instance. Non-interactive applications (no user sign-in) Service Applications Authenticate service-to-service integrations (background sync, integrations) against an ERP.net instance. Automations Authenticate automated processes that run without direct user interaction and need controlled API access. What you'll get from each guide Each scenario guide provides: which identity authority to use the recommended flow and token type for the scenario required configuration (e.g., trusted application, scopes) implementation notes and common pitfalls Next steps Start with the guide that matches your app type. If you are unsure which authority applies, read Identity authorities (instance vs global) first."
  },
  "auth/getting-started/service-apps.html": {
    "href": "auth/getting-started/service-apps.html",
    "title": "Service Applications (Service Access for Confidential Applications) | ERP.net Developer Docs",
    "summary": "Service Applications (Service Access for Confidential Applications) This topic describes how a confidential external application with no user interaction integrates with an ERP.net Instance ID to obtain an access token for calling instance APIs using the Client Credentials flow. The following scenario is covered: The external application is a confidential application The application has a backend component capable of securely storing a secret The application does not present a user interface The application authenticates as a service identity The application uses the Client Credentials authorization flow The application obtains an access token to call instance APIs directly The Instance ID is the identity provider of a specific ERP.net instance. Service applications use it to authenticate and obtain access tokens without user involvement, scoped to the permissions configured for the trusted application. For example, if your ERP.net instance is located at: https://demodb.my.erp.net then the corresponding Instance ID endpoints are located at: https://demodb.my.erp.net/id Prerequisites Your ERP.net instance must have a trusted application defined with the configuration below. Note The values shown below are examples only and must be replaced with values that match your application. Typical values: ApplicationUri: my-service-app-id SystemUser: <an-internal-erp-user> Note The application owner must generate a random client secret, compute its Base64-encoded SHA-256 hash, and submit the hashed value via an internal ticket to erp.net so the Trusted Application can be registered and the configuration activated. Attribute Value Comment Name My Service Application Used only for user-friendly identification. ApplicationUri my-service-app-id The unique identifier of the application. IsEnabled true Enables the trusted application. SystemUserAllowed true Allows the application to authenticate as a service. SystemUser <an-internal-erp-user> The internal user used for service authentication. ImpersonateAsInternalUserAllowed true Allows authentication using an internal user. ClientType Confidential Indicates that the application can securely store a secret. ApplicationSecretHash <base64(sha256(your-client-secret))> The hashed client secret used during authentication. Scope read or read update Use read for read-only access; include update only if the application must create, modify, or delete data All other attributes can keep their default values and are not relevant for this scenario. Implementation This section demonstrates acquiring an access token using the Client Credentials flow. 1. Request an access token The application sends a direct request to the Instance ID token endpoint. POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my-service-app-id& client_secret=<PLAIN_CLIENT_SECRET>& grant_type=client_credentials& scope=read%20update Note The client_secret is sent as a plain (unhashed) value and must exactly match the secret configured for the trusted application. 2. Receive the token response If the request is successful, the Instance ID returns an access token. { \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjY1MDUxNDcsImV4cCI6MTc2NjUwODc0NywiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOlsiRG9tYWluQVBJIiwiVGFibGVBUEkiLCJPTEFQIiwiQXBwU2VydmVyIiwiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQvcmVzb3VyY2VzIl0sImNsaWVudF9pZCI6IlBLIiwiY2xpZW50X3N5c3RlbV91c2VyIjoiYWRtaW4iLCJjbGllbnRfc3lzdGVtX3VzZXJfdHlwZSI6IkludGVybmFsVXNlciIsImNsaWVudF9kYiI6IkUxX0RFVi0xIFRlc3QiLCJqdGkiOiI4RDBCNzA1NTczQTFBOThGREJBREZGMENEN0Y3RUVCNCIsImlhdCI6MTc2NjUwNTE0Nywic2NvcGUiOlsicmVhZCIsInVwZGF0ZSJdfQ.MRvH-EtWu-PWDhjDDn73OVQwH29DZ_RRu6XheFsoRxImyjLQRIU7-S1GuyTnnqPyXEEkGkKTu_s3IEwxGORgY48jLH3l1juJDt8_JvcyJlIdhVZSZNC1Bpft_K1NJswJ6QmJ6bWgev7cqHaxM3p7AEEPjkSmnAjdBCz7ItMV93Yio5kCRBmP9DQUoxtL0webG7zV_f5uOkt8xhbUVHpdU9FQY-XLf_heLJv_81vvpf39kPxD4WTZRly8X_mNdlqi0DxiFXK3TFOnbdoLKxeljke8jV0t-agaHWcZ4B-SMQ77falwtFaxrEzXDY4g-iUg2kl_tABOUxzoqyFkGZm3DA\", \"expires_in\": 3600, \"token_type\": \"Bearer\", \"scope\": \"read update\" } The application can now use the access token to call instance APIs. Example (Domain) API request: GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjY1MDUxNDcsImV4cCI6MTc2NjUwODc0NywiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOlsiRG9tYWluQVBJIiwiVGFibGVBUEkiLCJPTEFQIiwiQXBwU2VydmVyIiwiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQvcmVzb3VyY2VzIl0sImNsaWVudF9pZCI6IlBLIiwiY2xpZW50X3N5c3RlbV91c2VyIjoiYWRtaW4iLCJjbGllbnRfc3lzdGVtX3VzZXJfdHlwZSI6IkludGVybmFsVXNlciIsImNsaWVudF9kYiI6IkUxX0RFVi0xIFRlc3QiLCJqdGkiOiI4RDBCNzA1NTczQTFBOThGREJBREZGMENEN0Y3RUVCNCIsImlhdCI6MTc2NjUwNTE0Nywic2NvcGUiOlsicmVhZCIsInVwZGF0ZSJdfQ.MRvH-EtWu-PWDhjDDn73OVQwH29DZ_RRu6XheFsoRxImyjLQRIU7-S1GuyTnnqPyXEEkGkKTu_s3IEwxGORgY48jLH3l1juJDt8_JvcyJlIdhVZSZNC1Bpft_K1NJswJ6QmJ6bWgev7cqHaxM3p7AEEPjkSmnAjdBCz7ItMV93Yio5kCRBmP9DQUoxtL0webG7zV_f5uOkt8xhbUVHpdU9FQY-XLf_heLJv_81vvpf39kPxD4WTZRly8X_mNdlqi0DxiFXK3TFOnbdoLKxeljke8jV0t-agaHWcZ4B-SMQ77falwtFaxrEzXDY4g-iUg2kl_tABOUxzoqyFkGZm3DA Security and implementation considerations This flow is intended for machine-to-machine communication. No user authentication or interaction occurs. The client secret must never be exposed outside the backend. Tokens are scoped and limited to the permissions configured for the application."
  },
  "auth/overview.html": {
    "href": "auth/overview.html",
    "title": "Authentication and Authorization Overview | ERP.net Developer Docs",
    "summary": "Authentication and Authorization Overview Apps that connect to ERP.net must authenticate securely and operate only within the permissions granted to them. The authentication and authorization model in ERP.net ensures that every app and user is properly verified, identified, and restricted according to system policies. This process is built on the OAuth 2.0 standard and implemented through the ERP.net Identity and the Trusted Applications model. Why Authentication and Authorization Matter Whenever an app interacts with an ERP.net instance, two questions must always be answered: Who is making the request - authentication What that entity is allowed to do - authorization ERP.net enforces these principles through token-based access. Each app receives a secure, time-limited token that defines its identity and permissions. This ensures that integrations remain safe, isolated, and fully auditable. The Building Blocks Authentication in ERP.net is organized around three core components: ERP.net Identity Each ERP.net instance includes a built-in Identity that manages all authentication and token issuance. It validates credentials, issues tokens, and applies the access rules configured in the instance. OAuth 2.0 ERP.net follows the OAuth 2.0 framework for secure, standardized communication between applications and APIs. OAuth 2.0 defines how apps request, use, and renew tokens without ever exposing user credentials. Trusted Applications Before an app can connect, it must be registered as a Trusted Application within the target ERP.net instance. This registration defines the app's identity, allowed flows, and permissions, forming a trusted relationship between the app and the instance. How It Works At a high level, authentication in ERP.net follows this process: The app is registered as a Trusted Application in the target instance. The app requests access through the ERP.net Identity, either on behalf of a user or as a background service. ERP.net Identity validates the request and issues an access token. The app uses that token to call the APIs within the scope of its granted permissions. sequenceDiagram participant App participant IdentityServer as ERP.net Identity participant API as ERP.net APIs App->>IdentityServer: 1. Request authorization (user or service) IdentityServer-->>App: 2. Issue access token App->>API: 3. Call API with access token API-->>App: 4. Return authorized data Types of Access ERP.net supports two main types of access depending on how the app operates: Interactive access The app represents a user and requires sign-in through a browser or web view. Used by web or mobile applications. Implements the Authorization Code Flow defined by OAuth 2.0. Service access The app acts as a background service without user interaction. Used by automations, integrations, or scheduled tasks. Implements the Client Credentials Flow defined by OAuth 2.0. Both types rely on the same ERP.net Identity and token-based authorization model. The Result of Successful Authentication Once authentication and authorization complete successfully: The app or user gains a secure session within the ERP.net instance An access token is issued to represent that session Access is limited to the scopes and permissions granted All activity can be traced back to the app and its associated user or service identity Learn More Concepts Overview Understand how the ERP.net Identity Service, OAuth 2.0, and Trusted Applications work together. Auth Flows Learn about the available OAuth 2.0 flows for different app types. Tokens Understand access tokens, scopes, and permissions. Sessions Learn how tokens map to sessions and license slots within ERP.net."
  },
  "auth/samples/basic-acquire-access-token.html": {
    "href": "auth/samples/basic-acquire-access-token.html",
    "title": "Basic example of acquiring an access token | ERP.net Developer Docs",
    "summary": "Basic example of acquiring an access token Objective Your external application just wants to acquire an access token so can access the Domain API. As short as possible. Or, Your external app is a service application. It will be authenticated and authorized via an internal user. Your external app won't provide UI and/or interaction with external users, so it's also a condfidential application. There will be no interaction, so your external app will use client credentials authorization flow. Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app Frankly, this value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app/first This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true SystemUserAllowed true You need this, because your external app will be logged as a service. SystemUser <an-internal-erp-user> The user, which will be used when the application logins as a service. ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ClientType Confidential Your external app is a service. I.e., it can keep a secret securely. ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. It's used in the process of authentication. All other attributes can have their default values. They are not covered by this example. Steps You just need to call a pretty simple HTTP request. POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app/first& client_secret=<my_plain_app_secret>& grant_type=client_credentials& scope=read Yes, it's that simple. Here are some clarifications: The POST request is sent to the ERP.net Identity token endpoint directly. The body of the request: client_id - your trusted app's application uri. client_secret - the plain secret phrase of the trusted app. grant_type - the way your app will get an access token. scope - what's needed to access. Note With the client_credentials flow (i.e., ERP.net service application), the scope argument can be omitted. Then your access token will contain all scopes, defined in the trusted application. If everything is correct, you'll receive a similar response: { \"access_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTQwNzU1MjksImV4cCI6MTY1NDA3OTEyOSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsImNsaWVudF9zeXN0ZW1fdXNlciI6InAua29zdG92QGVycC5iZyIsImNsaWVudF9kYiI6IkUxX0RFViIsImp0aSI6IlNob3JjNVJ2MTM2ak5POHRCMF9yRHciLCJzY29wZSI6WyJEb21haW5BcGkiLCJzZWMiLCJ1cGRhdGUiXX0.RPzYKl9xPvFcLa0O8yqzJCJtmZUS88iDeWBFa9pyvYdzfQ18E4W8w6CLJPf9whFFiJWhgAsOASVuz98-MIgj9VwTjNtXMdMAPvZC0HYPnMusYUxxYRNejjqtPG7n4V0LVzyWYHu99-YUipFBmzXxCywR8TtaBv374CKfLdS4M1vaMMYShzD22L_R3kKc3uZhQ5Ygpci1tuNC8gC6CoXIv0a9gjthwgshCzmbEmiNhjvJ7WDZ98gnzkvl5_wLANRrDYUcLPvq04OfVRn2uS-dF-NLIeO5dr7Mn905YodY4Mngr4S5WbBvrWAt0hRLO6Oy_X2KCcQdmh0Nq73ELruoBw\", \"expires_in\": 3600, \"token_type\": \"Bearer\", \"scope\": \"read\" } As you can see, you now have an access token (access_token), expiring in an hour (expires_in). Now this token could be used for your Domain API requests. E.g, GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTQwNzU1MjksImV4cCI6MTY1NDA3OTEyOSwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsImNsaWVudF9zeXN0ZW1fdXNlciI6InAua29zdG92QGVycC5iZyIsImNsaWVudF9kYiI6IkUxX0RFViIsImp0aSI6IlNob3JjNVJ2MTM2ak5POHRCMF9yRHciLCJzY29wZSI6WyJEb21haW5BcGkiLCJzZWMiLCJ1cGRhdGUiXX0.RPzYKl9xPvFcLa0O8yqzJCJtmZUS88iDeWBFa9pyvYdzfQ18E4W8w6CLJPf9whFFiJWhgAsOASVuz98-MIgj9VwTjNtXMdMAPvZC0HYPnMusYUxxYRNejjqtPG7n4V0LVzyWYHu99-YUipFBmzXxCywR8TtaBv374CKfLdS4M1vaMMYShzD22L_R3kKc3uZhQ5Ygpci1tuNC8gC6CoXIv0a9gjthwgshCzmbEmiNhjvJ7WDZ98gnzkvl5_wLANRrDYUcLPvq04OfVRn2uS-dF-NLIeO5dr7Mn905YodY4Mngr4S5WbBvrWAt0hRLO6Oy_X2KCcQdmh0Nq73ELruoBw"
  },
  "auth/samples/basic-exchange-auth-code-access-token.html": {
    "href": "auth/samples/basic-exchange-auth-code-access-token.html",
    "title": "Basic example- exchange an auth code for an access token | ERP.net Developer Docs",
    "summary": "Basic example- exchange an auth code for an access token Objective You have an external application that requires user login. You want to acquire an access token on behalf of the logged user. As short as possible. Or, Your external app is an interactive application (at least for the user to log in). It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal user). Your external application will access the ERP.net instance on behalf of the logged user. Will work with ERP.net internal users and it's able to keep a secret, so it's also a condfidential application. There'll be user interaction (because of the login), so your external app will use authorization code flow. Remarks This example doesn't show a specific implementiation, but the required steps you need to perform. You can find more information about specific implementations in the Resources section. The main difference with the Basic example of acquiring an access token is that there's an additional step, which is a subject of a specific technical implementation. I.e., Your external app performs an HTTP GET request to the authorize endpoint. Wait for ERP.net Identity to: Redirect to the ERP.net login page. \"Make\" an HTTP request to your external app, after the user logs in successfully. Now your external app can make an HTTP POST request to the token endpoint. ERP.net Identity creates an access token and and returns it to you. As you can see, the extra steps, compared to the other example, are (1) and (2). I.e., You have to provide a way to visualize the ERP.net login page (the usual way is via a web browser). Also a mechanism to handle a HTTP request. Actually, this is the essential difference between client_credentials flow and the authorization code flow. The first is bound to a specific, so-called service user while the other- to the user who will log in via the login form of the Identity Provider (i.e., the ERP.net Identity). Note It's important to clarify the following quote above, (2.2) \"Make\" an HTTP request to your external app, after the user logs in successfully., referring the ERP.net Identity. The HTTP request to your external app (i.e. the redirect) is made locally, as a result from your request to the authorize endpoint. In general, this means that your external app doesn't need to be accessible outside of the network where it's avaialble. So said, if your app is a \"pure\" local one, external callbacks such as localhost/signin-callback, 192.168.10.55/signin-callback are completely fine. Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app/first This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateLoginUrl http://localhost/signin-callback The url where your external app is listening. Redirection to this uri will be performed after the user logs in successfully. ClientType Confidential Your external app \"will work\" with internal users only, so there'll be no \"public\" acccess. We can assume that it can keep a secret securely (in fact, it's a must). ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. All other attributes can have their default values. They are not covered by this example. Steps Authorize endpoint You just need to call a simple GET request. GET /id/connect/authorize? client_id=my.trusted.app/first& redirect_uri=http://localhost/signin-callback& response_type=code id_token& scope=openid profile offline_access read& nonce=abc& state=dkZmYxMzE2 HTTP/1.1 Host: demodb.my.erp.net If everything is OK, the following will happen: A redirect to the ERP.net login page will be made. After the user logs in successfully, a redirect back to your external app will be performed. Sign in callback The previous step leads here. You'll receive a GET request such as: GET /signin-callback? code=g0ZGZmNjVmOWI& state=dkZmYxMzE2 HTTP/1.1 Host: localhost Where the code in the uri query is your authorization code. Now you're ready to exchange this authorization code for an access token. Token endpoint Once you have the authorization code, obtaining the access token is pretty easy. Just make the following POST request. POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app/first& client_secret=<my_plain_app_secret>& grant_type=authorization_code& code=g0ZGZmNjVmOWI& redirect_uri=http://localhost/signin-callback That's all. You'll receive something like this: { \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA1ODAyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJwayIsIm5vbmNlIjoiYWJjIiwiaWF0IjoxNjU1MDU3NzI0LCJhdF9oYXNoIjoibUhfSUZEUVppRHdZb2h5a0FZR2NJZyIsInNfaGFzaCI6IlRjMWtiNVB1U2lheEN2NXVJZHZ6ZlEiLCJzaWQiOiJ1Q3FiZkI4OHpYMXUzOW40NERwVjFRIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE2NTUwMjc3MTksImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.CzTk7SXiqcgpjVXCvdgDKJ92bt2a93R76l5WmCIZ6hMG6VDYHXlkBlqmG15l8Zsc1SpLn949f-OQn4nK1LaLkOA1rrMfT6lhMdrdBkQED7mYrjTyRqUJHnkriYpLsbL4Ze5gOP1M0HlDi6ZWjhZyzJgEyqi_T44lmlyZc0ujQ0Zba-_afXV7VpmgL9dIPwSmhuP14x2UJIGziBE8m23DL4GqTMQYgX0HNGLa2Tgiztp4h9ABBWWhj_iEKJ3ZoZ3CfMVMn53fqDaf9fuIrgYrOOTKqE7UrxH2bhdLUlaqka7KeGIsRd7f6wV2XqFDfY3vtW85CzQnjuGhj-qAJoZjCw\", \"access_token\": \"eycccGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA2MTMyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNjU1MDI3NzE5LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IlNQUyIsImVtYWlsIjoiYWRtaW5AbWFpbC5jb20iLCJ1c2VyX3R5cGUiOiJJbnRlcm5hbFVzZXIiLCJpc19hZG1pbi1ee6InRydWUiLCJlbWFpbF92ZXJpZmllZCI6ImZhb2NlIiwiZGIiOiJFMV9ERVYiLCJsb2NhbGUiOiJieyIsImp0aSI6Il9sdEJMS3djSlNLbUFhM25mbFpwNFEiLCJzaWQiOiJ1Q3FiZds2898pYMXUzOW40NqRwVjFRIiwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsIww1kRvbWFpbkFwaSIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AzHxj_iBM3bfcOtdaSNHNbPUHGCf0JAo7fV1fo9JT-rqCHjc0t8VEa1qO5R2jemvs7vDBf6GARxgul3pAy7YQpmqzzruswoLDkDdUMX1LXzHLgp0ppYoNa1A_M_O4UTXCe7xGBRHSyRRQLGsTTGMkv1pK0E3Xn3rAfOPvo4wfrQ8QabVcdA7mupY4qF01tIHPv_7NGS2SyPfCVdAYcxUy8HpQ-RdoXMaVWVz_JhXgMNZ9_nFTxedPGakZJMDjnvYss_GKjucbeYdZM9jSrqEmXDw6s8A3o1jKOyurzIBzug55Dxee8UBWepcO5S08GPguBFotamUvStMdDY0KkmZYvw\", \"expires_in\": 3600, \"refresh_token\": \"6-Cv7vQ5ouhYzs0AWg6tsG-YK7O5xP_kb5Qb8wEJMnw\", \"scope\": \"openid profile read offline_access\" } Authorized Domain API call Now you're authorized and we can make a legitimate call to the ERP.net Domain Api. E.g., GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net Authorization: Bearer eycccGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA2MTMyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNjU1MDI3NzE5LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IlNQUyIsImVtYWlsIjoiYWRtaW5AbWFpbC5jb20iLCJ1c2VyX3R5cGUiOiJJbnRlcm5hbFVzZXIiLCJpc19hZG1pbi1ee6InRydWUiLCJlbWFpbF92ZXJpZmllZCI6ImZhb2NlIiwiZGIiOiJFMV9ERVYiLCJsb2NhbGUiOiJieyIsImp0aSI6Il9sdEJMS3djSlNLbUFhM25mbFpwNFEiLCJzaWQiOiJ1Q3FiZds2898pYMXUzOW40NqRwVjFRIiwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsIww1kRvbWFpbkFwaSIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AzHxj_iBM3bfcOtdaSNHNbPUHGCf0JAo7fV1fo9JT-rqCHjc0t8VEa1qO5R2jemvs7vDBf6GARxgul3pAy7YQpmqzzruswoLDkDdUMX1LXzHLgp0ppYoNa1A_M_O4UTXCe7xGBRHSyRRQLGsTTGMkv1pK0E3Xn3rAfOPvo4wfrQ8QabVcdA7mupY4qF01tIHPv_7NGS2SyPfCVdAYcxUy8HpQ-RdoXMaVWVz_JhXgMNZ9_nFTxedPGakZJMDjnvYss_GKjucbeYdZM9jSrqEmXDw6s8A3o1jKOyurzIBzug55Dxee8UBWepcO5S08GPguBFotamUvStMdDY0KkmZYvw Resources Authorization code flow with a web based external application Authorization code flow with a console based external application -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "auth/samples/basic-renew-access-token.html": {
    "href": "auth/samples/basic-renew-access-token.html",
    "title": "Basic example- renew an access token via a refresh token | ERP.net Developer Docs",
    "summary": "Basic example- renew an access token via a refresh token Objective You have an external application that requires user login. You want to acquire an access token on behalf of the logged user. Because the access token has a validity of 1 hour, you want to renew it, instead of forcing the user to log in again. Or, Your external app is an interactive application (at least for the user to log in). It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal user). Your external application will access the ERP.net instance on behalf of the logged user. Will work with ERP.net internal users and it's able to keep a secret, so it's also a condfidential application. There'll be user interaction (because of the login), so your external app will use authorization code flow. Aditionally, you want to renew the access token when it expires, instead of forcing the user to login in. Remarks This example uses as a basis the following one: Basic example- exchange an auth code for an access token. The reason for this is simple. The referened example already shows how an access token is obtained, along with a refresh token. In fact, it's more accurate to say- your first access token with its corresponding refresh token. Your \"first\" access token, because it will change when you renew it (i.e., you'll obtain a new one). Note Refreshing the access token only makes sense in the authorization code flow. This will help the user by not having to enter their credentials each time their access token expires. In flows such as client_credentials refreshing an access token is pointless, because you can always obtain a new one with a single request, directly to the token endpoint. Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app/first This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateLoginUrl http://localhost/signin-callback The url where your external app is listening. Redirection to this uri will be performed after the user logs in successfully. ClientType Confidential Your external app \"will work\" with internal users only, so there'll be no \"public\" acccess. We can assume that it can keep a secret securely (in fact, it's a must). ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. All other attributes can have their default values. They are not covered by this example. Steps Authorize endpoint You just need to call a simple GET request. GET /id/connect/authorize? client_id=my.trusted.app/first& redirect_uri=http://localhost/signin-callback& response_type=code id_token& scope=openid profile offline_access read& nonce=abc& state=xyz HTTP/1.1 Host: demodb.my.erp.net If everything is OK, the following will happen: A redirect to the ERP.net login page will be made. After the user logs in successfully, a redirect back to your external app will be performed. Sign in callback The previous step leads here. You'll receive a GET request such as: GET /signin-callback? code=g0ZGZmNjVmOWI& state=dkZmYxMzE2 HTTP/1.1 Host: localhost Where the code in the uri query is your authorization code. Now you're ready to exchange this authorization code for an access token. Token endpoint Once you have the authorization code, obtaining the access token is pretty easy. Just make the following POST request. POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app/first& client_secret=<my_plain_app_secret>& grant_type=authorization_code& code=g0ZGZmNjVmOWI& redirect_uri=http://localhost/signin-callback That's all. You'll receive something like this: { \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA1ODAyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJwayIsIm5vbmNlIjoiYWJjIiwiaWF0IjoxNjU1MDU3NzI0LCJhdF9oYXNoIjoibUhfSUZEUVppRHdZb2h5a0FZR2NJZyIsInNfaGFzaCI6IlRjMWtiNVB1U2lheEN2NXVJZHZ6ZlEiLCJzaWQiOiJ1Q3FiZkI4OHpYMXUzOW40NERwVjFRIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE2NTUwMjc3MTksImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.CzTk7SXiqcgpjVXCvdgDKJ92bt2a93R76l5WmCIZ6hMG6VDYHXlkBlqmG15l8Zsc1SpLn949f-OQn4nK1LaLkOA1rrMfT6lhMdrdBkQED7mYrjTyRqUJHnkriYpLsbL4Ze5gOP1M0HlDi6ZWjhZyzJgEyqi_T44lmlyZc0ujQ0Zba-_afXV7VpmgL9dIPwSmhuP14x2UJIGziBE8m23DL4GqTMQYgX0HNGLa2Tgiztp4h9ABBWWhj_iEKJ3ZoZ3CfMVMn53fqDaf9fuIrgYrOOTKqE7UrxH2bhdLUlaqka7KeGIsRd7f6wV2XqFDfY3vtW85CzQnjuGhj-qAJoZjCw\", \"access_token\": \"eycccGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA2MTMyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNjU1MDI3NzE5LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IlNQUyIsImVtYWlsIjoiYWRtaW5AbWFpbC5jb20iLCJ1c2VyX3R5cGUiOiJJbnRlcm5hbFVzZXIiLCJpc19hZG1pbi1ee6InRydWUiLCJlbWFpbF92ZXJpZmllZCI6ImZhb2NlIiwiZGIiOiJFMV9ERVYiLCJsb2NhbGUiOiJieyIsImp0aSI6Il9sdEJMS3djSlNLbUFhM25mbFpwNFEiLCJzaWQiOiJ1Q3FiZds2898pYMXUzOW40NqRwVjFRIiwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsIww1kRvbWFpbkFwaSIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AzHxj_iBM3bfcOtdaSNHNbPUHGCf0JAo7fV1fo9JT-rqCHjc0t8VEa1qO5R2jemvs7vDBf6GARxgul3pAy7YQpmqzzruswoLDkDdUMX1LXzHLgp0ppYoNa1A_M_O4UTXCe7xGBRHSyRRQLGsTTGMkv1pK0E3Xn3rAfOPvo4wfrQ8QabVcdA7mupY4qF01tIHPv_7NGS2SyPfCVdAYcxUy8HpQ-RdoXMaVWVz_JhXgMNZ9_nFTxedPGakZJMDjnvYss_GKjucbeYdZM9jSrqEmXDw6s8A3o1jKOyurzIBzug55Dxee8UBWepcO5S08GPguBFotamUvStMdDY0KkmZYvw\", \"expires_in\": 3600, \"refresh_token\": \"6-Cv7vQ5ouhYzs0AWg6tsG-YK7O5xP_kb5Qb8wEJMnw\", \"scope\": \"openid profile read offline_access\" } As you see, the result contains the following: Your first access token. When it will expire (in seconds). The corresponding refresh token. Authorized Domain API call Now you're authorized and we can make a legitimate call to the ERP.net Domain Api. E.g., GET /api/domain/odata/Crm_Customers?$top=10 HTTP/1.1 Host: demodb.my.erp.net Authorization: Bearer eycccGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA2MTMyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJEb21haW5BcGkiLCJjbGllbnRfaWQiOiJwayIsInN1YiI6ImFkbWluIiwiYXV0aF90aW1lIjoxNjU1MDI3NzE5LCJpZHAiOiJsb2NhbCIsImlkIjoiOWRhNjQ4MzktYThkMC00OTFkLWFlYmItNGQxOGZhNDJiMDE0IiwibmFtZSI6IlNQUyIsImVtYWlsIjoiYWRtaW5AbWFpbC5jb20iLCJ1c2VyX3R5cGUiOiJJbnRlcm5hbFVzZXIiLCJpc19hZG1pbi1ee6InRydWUiLCJlbWFpbF92ZXJpZmllZCI6ImZhb2NlIiwiZGIiOiJFMV9ERVYiLCJsb2NhbGUiOiJieyIsImp0aSI6Il9sdEJMS3djSlNLbUFhM25mbFpwNFEiLCJzaWQiOiJ1Q3FiZds2898pYMXUzOW40NqRwVjFRIiwic2NvcGUiOlsib3BlbmlkIiwicHJvZmlsZSIsIww1kRvbWFpbkFwaSIsIm9mZmxpbmVfYWNjZXNzIl0sImFtciI6WyJwd2QiXX0.AzHxj_iBM3bfcOtdaSNHNbPUHGCf0JAo7fV1fo9JT-rqCHjc0t8VEa1qO5R2jemvs7vDBf6GARxgul3pAy7YQpmqzzruswoLDkDdUMX1LXzHLgp0ppYoNa1A_M_O4UTXCe7xGBRHSyRRQLGsTTGMkv1pK0E3Xn3rAfOPvo4wfrQ8QabVcdA7mupY4qF01tIHPv_7NGS2SyPfCVdAYcxUy8HpQ-RdoXMaVWVz_JhXgMNZ9_nFTxedPGakZJMDjnvYss_GKjucbeYdZM9jSrqEmXDw6s8A3o1jKOyurzIBzug55Dxee8UBWepcO5S08GPguBFotamUvStMdDY0KkmZYvw Access token renewal When your access token expires, all requests will begin to return HTTP 401 - Unauthorized. So, now's the time to renew your access token. You can do it via the token endpoint, this way: POST /id/connect/token HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app/first& client_secret=<my_plain_app_secret>& grant_type=refresh_token& refresh_token=6-Cv7vQ5ouhYzs0AWg6tsG-YK7O5xP_kb5Qb8wEJMnw Done. If everything is correct, you'll get a response like this: { \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IkJEbGhqYjhzOEUySm1tcWg2UDlxZEEiLCJ0eXAiOiJKV1QifQ.eyJuYmYiOjE2NTUwNTc3MjQsImV4cCI6MTY1NTA1ODAyNCwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOiJwayIsIm5vbmNlIjoiYWJjIiwiaWF0IjoxNjU1MDU3NzI0LCJhdF9oYXNoIjoibUhfSUZEUVppRHdZb2h5a0FZR2NJZyIsInNfaGFzaCI6IlRjMWtiNVB1U2lheEN2NXVJZHZ6ZlEiLCJzaWQiOiJ1Q3FiZkI4OHpYMXUzOW40NERwVjFRIiwic3ViIjoiYWRtaW4iLCJhdXRoX3RpbWUiOjE2NTUwMjc3MTksImlkcCI6ImxvY2FsIiwiYW1yIjpbInB3ZCJdfQ.CzTk7SXiqcgpjVXCvdgDKJ92bt2a93R76l5WmCIZ6hMG6VDYHXlkBlqmG15l8Zsc1SpLn949f-OQn4nK1LaLkOA1rrMfT6lhMdrdBkQED7mYrjTyRqUJHnkriYpLsbL4Ze5gOP1M0HlDi6ZWjhZyzJgEyqi_T44lmlyZc0ujQ0Zba-_afXV7VpmgL9dIPwSmhuP14x2UJIGziBE8m23DL4GqTMQYgX0HNGLa2Tgiztp4h9ABBWWhj_iEKJ3ZoZ3CfMVMn53fqDaf9fuIrgYrOOTKqE7UrxH2bhdLUlaqka7KeGIsRd7f6wV2XqFDfY3vtW85CzQnjuGhj-qAJoZjCw\", \"access_token\": \"eyJhbGciOiJIUzI1NiJ9.eyJuYmYiOjE2NTU2NTM3MTYsImV4cCI6MTY1NTY1NzMxNiwiaXNzIjoiaHR0cHM6Ly9lMS1kZXYubG9jYWwvaWQiLCJhdWQiOlsiRG9tYWluQXBpIiwidXBkYXRlIl0sImNsaWVudF9pZCI6InBrIiwiY2xpZW50X2RiIjoiRTFfREVWIiwianRpIjoiT0pycTFjX1owNzBUbHZJVTVoUlhFZyIsInNjb3BlIjpbIkRvbWFpbkFwaSIsInVwZGF0ZSJdfQ.syDIwziTNy1m2XNSSKD_E8wScuuuS2ZENzaxdd9ClOU\", \"expires_in\": 3600, \"refresh_token\": \"SvQvQ9cxcYzs0AWg6tsGW1-YK7O5xP_k98868wEEMjr\", \"scope\": \"openid profile read offline_access\" } A new pair of access and refresh tokens. You should use them now. If you've noticed, refreshing the access token is the same as getting it the first time. The only difference is, grant_type=authorization_code&code=xxx to initially obtain the access token. grant_type=refresh_token&refresh_token=xxx when you want to acquire a new one - i.e., to refresh it. Resources Basic example- exchange an auth code for an access token Authorization code flow with a web based external application Authorization code flow with a console based external application -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "auth/samples/console-app-access-token-auth-code.html": {
    "href": "auth/samples/console-app-access-token-auth-code.html",
    "title": "Access token via authorization code flow in a console app | ERP.net Developer Docs",
    "summary": "Access token via authorization code flow in a console app Objective You have an external application that will be authorized via the ERP.net login form on behalf of an internal user. The application MAY or MAY NOT provide an UI, but there'll be user interaction at least for the initial login. Or, Your external app is an interactive application. It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal user). Your external application will access the ERP.net instance on behalf of the logged user. Your external app MAY provide UI. It's able to keep a secret, so it's also a condfidential application. There'll be user interaction (at least for the internal user to log in), so your external app will use authorization code flow. The whole process in a nutshell Note This example uses Windows console application, which is why some points further require a deeper understanding. It's highly recommended, if you haven't done so, that you read the following topic first, Access token via authorization code flow in a web app After all, your final goal is to acquire an access token. The process is very similar to this example Basic example of acquiring an access token, but here is added another intermediate step - the process of impersonating a user. Here's a summary of how the whole process goes: Your external app will open the so called authorize endpoint with your trusted app details (the trusted app, corresponding to your external app). Note An important detail is that the authorize endpoint must be opened in a browser (see next point and its note). If all's OK, the browser will be redirected to the ERP.net login page, where the user will enter their credentials. Note Because of the redirect, initially the step (1) have to be performed in a browser. If your external app is web-based, you don't have to do anything (because it will work in a browser anyway). If your external app is NOT web-based, you have to handle this process by yourself (the example below is just like that). If the user logs in successfully, the ERP.net login page (i.e. ERP.net Identity) will be redirect to a uri where your external app is listening. There you'll receive an authorization code. Finally you'll exchange the auth code for an access token at the token endpoint. You'll obtain an access token on behalf of the logged user (2). Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app/first This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateLoginUrl http://localhost/signin-callback/ The url where your external app is listening. Redirection to this uri will be performed after the user logs in successfully (see step 3 in the section above). ClientType Confidential Your external app \"will work\" with internal users only, so there'll be no \"public\" acccess. We can assume that it can keep a secret securely (in fact, it's a must). ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. All other attributes can have their default values. They are not covered by this example. Steps Unlike the Basic example of acquiring an access token, where everything is clear enough to describe with simple HTTP requests, here the examples are shown in the context of a simple C# console application (i.e. an external app). Initialization First we'll declare and initialize some constants and variables which we'll use later. const string AuthorizeUri = \"https://demodb.my.erp.net/id/connect/authorize\"; const string TokenUri = \"https://demodb.my.erp.net/id/connect/token\"; const string CallbackUri = \"http://localhost/signin-callback/\"; const string TrustedAppUri = \"my.trusted.app/first\"; const string TrustedAppSecret = \"<my_plain_app_secret>\"; const string DomainApiTestUri = \"https://demodb.my.erp.net/api/domain/odata/Crm_Customers?$top=10\"; We won't waste time, explaining about the constants, their names are self-explanatory. The next two variables are a little more interesting, string authCode = string.Empty; string authState = Guid.NewGuid().ToString(); ClientAuthData clientData; The authCode keeps the authorization code you'll receive after the internal user logs in successfully. So, initially will be an empty string. The authState is a random string, used for security purpose. You'll pass it to the authorize endpoint and ERP.net Identity will return it back to your CallbackUri uri (as you can guess, you need to compare them- if they differ, it's most likely a malicious attempt). The last variable clientData will help us, holding the client (i.e. internal user) auth data such as access token, scopes, access token expiration, etc. Here's what the ClientAuthData type looks like: public struct ClientAuthData { [JsonPropertyName(\"id_token\")] public string IdToken { get; set; } [JsonPropertyName(\"access_token\")] public string AccessToken { get; set; } [JsonPropertyName(\"expires_in\")] public int ExpiresIn { get; set; } [JsonPropertyName(\"refresh_token\")] public string RefreshToken { get; set; } [JsonPropertyName(\"scope\")] public string Scope { get; set; } } Because we'll receive this data as a raw json string, the JsonPropertyName attribute will help us deserialize it with a \"one-liner\". HTTP server (a.k.a. the callback listener) This is also part of the initialization, but it's an essential part of the whole process. That's why we condider it separately. Note If your external application is web-based, you don't need this step, because you already \"have\" a web server. You just have to handle the CallbackUri as an additional page, route, etc. var httpListener = new HttpListener(); httpListener.Prefixes.Add(CallbackUri); httpListener.Start(); We're creating an object of type HttpListener (that's the HttpListener Class, based on HTTP.sys). After, we are adding our CallbackUri (as a place where we'll \"listen\") and we just start the server. The server is started, but we have to handle when the CallbackUri is requested. Because we're listening on just one uri, the following code is enough: var signCallbackTask = httpListener .GetContextAsync() .ContinueWith(HandleSignInCallback); GetContextAsync() waits for an incoming request, but as an asynchronous operation. After, ContinueWith() will proceed when the task is completed (i.e. an incoming request is made). There our delegate HandleSignInCallback will be passed the completed task. The HandleSignInCallback implementation is below. Note It doesn't matter what the http server is. Here we're using the HTTP.sys implementation only because it's super simple to initialize. Warning HTTP.sys is Windows based web server. This code won't work on non-win OS. Also the process of \"adding a prefix\", requires elevated permissions to work, so you have to start this example as an administrator. Authorize endpoint Now this is the first step towards the essentials- you'll request an authorize code. This is done by submitting a GET request to the authorize endpoint. Here're the needed request parameters: var authorizeUriArgs = $\"client_id={TrustedAppUri}&\" + $\"redirect_uri={CallbackUri}&\" + \"response_type=code id_token&\" + \"response_mode=form_post&\" + \"scope=openid profile offline_access read&\" + \"nonce=abc&\" + $\"state={authState}\"; As you see, you're passing the following: The uri of your trusted app TrustedAppUri. The CallbackUri - the uri where you're waiting for the callback, when the user signs in. The scopes your external app needs. The authState, described at the beginning. In addition, there are two other important arguments: response_type=code id_token. This \"instructs\" ERP.net Identity to send you a code (i.e. authorization code) and an identity token (not discussed in this topic). response_mode=form_post. This \"tells\" ERP.net Identity that you are expecting the callback request as an HTTP POST request. Our request args are prepared, so we just have to execute the GET request (i.e. the authorize endpoint). // Start the authorize endpoint with your default browser. // This way you'll be able to enter your credentials. var processStartInfo = new ProcessStartInfo(\"cmd\", $\"/c start {AuthorizeUri}?{authorizeUriArgs.Replace(\"&\", \"^&\").Replace(\" \", \"%20\")}\") { CreateNoWindow = true }; Process.Start(processStartInfo); This is Windows based code that will open the GET request via the windows command shell. This is necessary, because as described above, if the request is successful, a redirect to the ERP.net login page will be made. Because our example external app is console application (i.e. we can't easily handle such a redirect, nor can we visualize the login page itself), so we'll just make the request with our default browser. In the meantime we'll wait the signin callback to trigger. // Wait until the redirect is made. signCallbackTask.Wait(); In other words, we're blocking our external app here, until the sign in callback is called. More precisely our HandleSignInCallback function completes after the the callback is called. Sign in callback And here's how we handle the callback: void HandleSignInCallback(Task<HttpListenerContext> httpListenerContextTask) { var body = new Dictionary<string, string>(); using (var streamReader = new StreamReader(httpContext.Request.InputStream)) { body = streamReader.ReadToEnd() .Split('&') .Select(v => v.Split('=')) .ToDictionary(pair => pair[0], pair => pair[1]); } if (!body.Any()) throw new Exception(\"empty body :(\"); if (body[\"state\"] != authState) throw new Exception(\"The returned state differs from the one we've passed.\"); authCode = body[\"code\"]; if (string.IsNullOrEmpty(authCode)) throw new Exception(\"No or invalid authorization code.\"); } Only the essential part of the function's body is shown (the full code is available below) In short, you process a simple POST request, in which you're interested in only two parameters, part of its body. The state - it must be equal to our authState, passed to the authorize endpoint. The code - this is our authorization code. Token endpoint Now when you have an authorization code, you can easily acquire an access token. For this to happen, you need to make a POST request to the token endpoint (i.e. TokenUri). But first you need to prepare the body of the POST request. Here's how: var tokenUriBody = $\"client_id={TrustedAppUri}&\" + $\"client_secret={TrustedAppSecret}&\" + \"grant_type=authorization_code&\" + $\"code={authCode}&\" + $\"redirect_uri={CallbackUri}\"; As you can see, it's quite simple. You're passing the following: Your trusted app uri and its secret TrustedAppUri, TrustedAppSecret. The authorization code you received in the previous step authCode. The CallbackUri. And the very important one grant_type=authroization_code - this is the moment when you \"tell\" ERP.net Identity that you'll use the authorization code flow. Then just send it and make sure that the returned http status code is a successful one: httpRequest = new HttpRequestMessage() { Method = HttpMethod.Post, RequestUri = new Uri(TokenUri), Content = new StringContent( tokenUriBody, Encoding.UTF8, \"application/x-www-form-urlencoded\") }; httpResponse = httpClient.Send(httpRequest); // This will throw if the returned status code is not 2xx. httpResponse.EnsureSuccessStatusCode(); Finally, you have our access token. It's in the response: // Deserialize the JSON response as a ClientAuthData struct. clientData = JsonSerializer.Deserialize<ClientAuthData>(httpResponse.Content.ReadAsStream()); Console.WriteLine($\"Access token: {clientData.AccessToken}\"); Console.WriteLine($\"Refresh token: {clientData.RefreshToken}\"); Authorized Domain API call Now you're authorized and you can make a legitimate call to the ERP.net Domain Api. E.g. httpRequest = new HttpRequestMessage() { Method = HttpMethod.Get, RequestUri = new Uri(DomainApiTestUri) }; httpRequest.Headers.Add(\"Authorization\", $\"Bearer {clientData.AccessToken}\"); httpResponse = httpClient.Send(httpRequest); The response will contain the result of the query. Everything together using System.Diagnostics; using System.Net; using System.Text; using System.Text.Json; using System.Text.Json.Serialization; const string AuthorizeUri = \"https://demodb.my.erp.net/id/connect/authorize\"; const string TokenUri = \"https://demodb.my.erp.net/id/connect/token\"; const string CallbackUri = \"http://localhost/signin-callback/\"; const string DomainApiTestUri = \"https://demodb.my.erp.net/api/domain/odata/Crm_Customers?$top=10\"; const string TrustedAppUri = \"my.trusted.app/first\"; const string TrustedAppSecret = \"<my_plain_app_secret>\"; string authCode = string.Empty; string authState = Guid.NewGuid().ToString(); ClientAuthData clientData; var httpListener = new HttpListener(); httpListener.Prefixes.Add(CallbackUri); httpListener.Start(); var signCallbackTask = httpListener.GetContextAsync().ContinueWith(HandleSignInCallback); var authorizeUriArgs = $\"client_id={TrustedAppUri}&\" + $\"redirect_uri={CallbackUri}&\" + \"response_type=code%20id_token&\" + \"response_mode=form_post&\" + \"scope=openid%20profile%20offline_access%20read&\" + \"nonce=abc&\" + $\"state={authState}\"; // Start the authorize endpoint with your default browser. // This way you'll be able to enter your credentials. var processStartInfo = new ProcessStartInfo(\"cmd\", $\"/c start {AuthorizeUri}?{authorizeUriArgs.Replace(\"&\", \"^&\").Replace(\" \", \"%20\")}\") { CreateNoWindow = true }; Process.Start(processStartInfo); // Wait until the redirect is made. signCallbackTask.Wait(); try { #region Create an http client and request/response message objects. var handler = new HttpClientHandler { ClientCertificateOptions = ClientCertificateOption.Manual, ServerCertificateCustomValidationCallback = (httpRequestMessage, cert, cetChain, policyErrors) => { return true; } }; var httpClient = new HttpClient(handler); HttpRequestMessage? httpRequest = null; HttpResponseMessage? httpResponse = null; #endregion #region Acquire an access token. var tokenUriBody = $\"client_id={TrustedAppUri}&\" + $\"client_secret={TrustedAppSecret}&\" + \"grant_type=authorization_code&\" + $\"code={authCode}&\" + $\"redirect_uri={CallbackUri}\"; httpRequest = new HttpRequestMessage() { Method = HttpMethod.Post, RequestUri = new Uri(TokenUri), Content = new StringContent( tokenUriBody, Encoding.UTF8, \"application/x-www-form-urlencoded\") }; httpResponse = httpClient.Send(httpRequest); // This will throw if the returned status code is not 2xx. httpResponse.EnsureSuccessStatusCode(); // Deserialize the JSON response as a ClientAuthData struct. clientData = JsonSerializer.Deserialize<ClientAuthData>(httpResponse.Content.ReadAsStream()); Console.WriteLine($\"Access token: {clientData.AccessToken}\"); Console.WriteLine($\"Refresh token: {clientData.RefreshToken}\"); #endregion #region Domain Api call - select top 10 Crm_Customers httpRequest = new HttpRequestMessage() { Method = HttpMethod.Get, RequestUri = new Uri(DomainApiTestUri) }; httpRequest.Headers.Add(\"Authorization\", $\"Bearer {clientData.AccessToken}\"); httpResponse = httpClient.Send(httpRequest); httpResponse.EnsureSuccessStatusCode(); Console.WriteLine(\"=================\"); var domainApiResponse = await httpResponse.Content.ReadAsStringAsync(); Console.WriteLine(domainApiResponse); #endregion } catch (Exception ex) { Console.WriteLine(ex.Message); } void HandleSignInCallback(Task<HttpListenerContext> httpListenerContextTask) { var httpContext = httpListenerContextTask.Result; var logMessage = \"Well done, everything is OK.\\r\\nNow you have an authorization code.\"; try { #region Request an authorization code. var body = new Dictionary<string, string>(); using (var streamReader = new StreamReader(httpContext.Request.InputStream)) { body = streamReader.ReadToEnd() .Split('&') .Select(v => v.Split('=')) .ToDictionary(pair => pair[0], pair => pair[1]); } if (!body.Any()) throw new Exception(\"empty body :(\"); if (body[\"state\"] != authState) throw new Exception(\"The returned state differs from the one we've passed.\"); authCode = body[\"code\"]; if (string.IsNullOrEmpty(authCode)) throw new Exception(\"No or invalid authorization code.\"); #endregion } catch (Exception ex) { logMessage = ex.Message; } byte[] buffer = Encoding.UTF8.GetBytes(logMessage); httpContext.Response.ContentLength64 = buffer.Length; using var output = httpContext.Response.OutputStream; output.Write(buffer, 0, buffer.Length); } public struct ClientAuthData { [JsonPropertyName(\"id_token\")] public string IdToken { get; set; } [JsonPropertyName(\"access_token\")] public string AccessToken { get; set; } [JsonPropertyName(\"expires_in\")] public int ExpiresIn { get; set; } [JsonPropertyName(\"refresh_token\")] public string RefreshToken { get; set; } [JsonPropertyName(\"scope\")] public string Scope { get; set; } } Resources The sample project in this example can be found here: https://github.com/ErpNetDocs/dev/tree/master/domain-api/samples/src/step-by-step/AccessTokenCodeConsole -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "auth/samples/erpnet-external-idp-samples.html": {
    "href": "auth/samples/erpnet-external-idp-samples.html",
    "title": "Sign in with ERP.net Identity (Multi-Platform Samples) | ERP.net Developer Docs",
    "summary": "Sign in with ERP.net Identity (Multi-Platform Samples) This page shows how to use ERP.net Identity as an OpenID Connect provider from different platforms. All samples use the same key parameters: Authority: https://id.erp.net/id Client ID: <your-client-id> Client Secret: <your-client-secret> (confidential clients only) Redirect URI: <your-redirect-uri> Scopes: openid profile (plus offline_access if you need refresh tokens) Warning The Client ID and Client Secret must be created in ERP.net Identity for your application. They are not public and cannot be reused from another app. Public vs. Confidential Clients ERP.net supports both confidential and public OAuth/OIDC clients: Confidential Clients Confidential clients run on a server you control (e.g., backend web apps). They can safely store a Client Secret. Characteristics: Use Client ID + Client Secret Typically use the Authorization Code or Hybrid flow Applicable to: server-side web apps, backend services, integrations Public Clients Public clients run in environments where secrets cannot be kept secure: Browsers (SPA apps) Mobile applications Desktop applications Public clients do not use a client secret. Characteristics: No Client Secret Must use Authorization Code Flow with PKCE Applicable to: Angular/React/Vue SPAs, mobile apps, desktop apps ERP.net Configuration Requirement Whether your application is public or confidential is determined by its Trusted Application configuration inside the ERP.net Identity. When you request client registration from ERP.net, specify: If your app is public (no secret) -> SPA/mobile/desktop Or confidential (with secret) -> backend/server app Effect on the Code Samples In the multi-platform samples on this page: Backend/server examples include client_secret Public-client examples should: Omit client_secret Use PKCE (code_verifier / code_challenge) Ensure the ERP.net application is configured as public The rest of the OIDC parameters (Authority, Redirect URI, Scopes, etc.) are identical for both types. SPA (JavaScript, oidc-client-ts) This is a front-end-only app running in the browser, using Authorization Code Flow with PKCE and no client secret. npm install oidc-client-ts // auth.ts import { UserManager, WebStorageStateStore } from 'oidc-client-ts'; const settings = { authority: 'https://id.erp.net/id', client_id: '<your-public-client-id>', // no secret redirect_uri: 'https://your-spa.com/auth/callback', post_logout_redirect_uri: 'https://your-spa.com/', response_type: 'code id_token', scope: 'openid profile', automaticSilentRenew: true, userStore: new WebStorageStateStore({ store: window.localStorage }) }; export const userManager = new UserManager(settings); // Trigger login export function login() { return userManager.signinRedirect(); } // Callback handler (on /auth/callback) export async function handleCallback() { const user = await userManager.signinRedirectCallback(); console.log('Logged in user:', user.profile); } // Trigger logout export function logout() { return userManager.signoutRedirect(); } SPA (Angular, angular-auth-oidc-client) Angular SPA using angular-auth-oidc-client with code + PKCE and no secret. npm install angular-auth-oidc-client app.module.ts: import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { AuthModule, LogLevel } from 'angular-auth-oidc-client'; import { AppComponent } from './app.component'; @NgModule({ declarations: [AppComponent], imports: [ BrowserModule, AuthModule.forRoot({ config: { authority: 'https://id.erp.net/id', clientId: '<your-public-client-id>', // no secret redirectUrl: 'https://your-angular-app.com', postLogoutRedirectUri: 'https://your-angular-app.com', scope: 'openid profile', responseType: 'code id_token', silentRenew: true, useRefreshToken: true, logLevel: LogLevel.Warn } }) ], bootstrap: [AppComponent] }) export class AppModule {} app.component.ts: import { Component, OnInit } from '@angular/core'; import { AuthService } from 'angular-auth-oidc-client'; @Component({ selector: 'app-root', template: ` <button *ngIf=\"!isAuthenticated\" (click)=\"login()\">Login with ERP.net</button> <div *ngIf=\"isAuthenticated\"> <p>Hello, {{ userName }}</p> <button (click)=\"logout()\">Logout</button> </div> ` }) export class AppComponent implements OnInit { isAuthenticated = false; userName: string | undefined; constructor(private authService: AuthService) {} ngOnInit() { this.authService.checkAuth().subscribe(({ isAuthenticated, userData }) => { this.isAuthenticated = isAuthenticated; this.userName = userData?.name || userData?.preferred_username; }); } login() { this.authService.authorize(); } logout() { this.authService.logoff(); } } Mobile (React Native, react-native-app-auth) Example using react-native-app-auth, which handles code + PKCE as a public client (no secret stored on device). npm install react-native-app-auth // auth.ts (React Native) import { authorize, refresh, revoke, AuthConfiguration } from 'react-native-app-auth'; const config: AuthConfiguration = { issuer: 'https://id.erp.net/id', clientId: '<your-public-client-id>', // no secret redirectUrl: 'myapp://auth/callback', // custom scheme scopes: ['openid', 'profile'], additionalParameters: {}, dangerouslyAllowInsecureHttpRequests: false }; export async function login() { const result = await authorize(config); // result includes accessToken, idToken, refreshToken (if allowed) return result; } JavaScript (Node.js + Express, using openid-client) Minimal example showing a login endpoint and callback using the openid-client library. npm install openid-client express express-session // app.js const express = require('express'); const session = require('express-session'); const { Issuer, generators } = require('openid-client'); const app = express(); app.use(session({ secret: 'replace-with-strong-secret', resave: false, saveUninitialized: false })); let client; // will hold the ERP.net OIDC client async function initClient() { const erpnetIssuer = await Issuer.discover('https://id.erp.net/id'); client = new erpnetIssuer.Client({ client_id: '<your-client-id>', client_secret: '<your-client-secret>', redirect_uris: ['https://your-app.com/auth/callback'], response_types: ['code id_token'], }); } initClient().catch(console.error); // Login endpoint app.get('/login', (req, res) => { const codeVerifier = generators.codeVerifier(); const codeChallenge = generators.codeChallenge(codeVerifier); req.session.codeVerifier = codeVerifier; const authUrl = client.authorizationUrl({ scope: 'openid profile', code_challenge: codeChallenge, code_challenge_method: 'S256' }); res.redirect(authUrl); }); // Callback endpoint app.get('/auth/callback', async (req, res, next) => { try { const params = client.callbackParams(req); const tokenSet = await client.callback( 'https://your-app.com/auth/callback', params, { code_verifier: req.session.codeVerifier } ); req.session.user = tokenSet.claims(); res.send(`Hello, ${req.session.user.name || req.session.user.sub}`); } catch (err) { next(err); } }); app.listen(3000, () => console.log('Listening on http://localhost:3000')); Java (Spring Boot, Spring Security OAuth2 Client) Using Spring Boot's built-in OAuth2 client support. application.yml: spring: security: oauth2: client: registration: erpnet: client-id: <your-client-id> client-secret: <your-client-secret> scope: openid,profile,offline_access redirect-uri: \"{baseUrl}/login/oauth2/code/erpnet\" client-name: ERP.net authorization-grant-type: authorization_code provider: erpnet: issuer-uri: https://id.erp.net/id Security configuration (Spring Security 5+ lambda style): import org.springframework.context.annotation.Bean; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.web.SecurityFilterChain; import org.springframework.context.annotation.Configuration; @Configuration public class SecurityConfig { @Bean SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .authorizeHttpRequests(auth -> auth .requestMatchers(\"/\", \"/public/**\").permitAll() .anyRequest().authenticated() ) .oauth2Login(oauth2 -> oauth2 .loginPage(\"/oauth2/authorization/erpnet\") // optional ) .logout(logout -> logout .logoutSuccessUrl(\"/\") ); return http.build(); } } Once configured, accessing any protected URL will redirect to ERP.net for login. PHP (using jumbojett/openid-connect-php) Install the library: composer require jumbojett/openid-connect-php Minimal example: <?php require 'vendor/autoload.php'; use Jumbojett\\OpenIDConnectClient; $oidc = new OpenIDConnectClient( 'https://id.erp.net/id', '<your-client-id>', '<your-client-secret>' ); $oidc->setRedirectURL('https://your-app.com/callback'); $oidc->addScope(['openid', 'profile']); // Trigger login (redirect to @@name if not authenticated) $oidc->authenticate(); // Get user info $userInfo = $oidc->requestUserInfo(); echo 'Hello, ' . htmlspecialchars($userInfo->name ?? $userInfo->sub); Configure your web server so /callback points to the same script, or handle it in a dedicated callback file that calls $oidc->authenticate(). Go (using coreos/go-oidc + golang.org/x/oauth2) Minimal example with an auth endpoint and callback: go get github.com/coreos/go-oidc/v3/oidc go get golang.org/x/oauth2 package main import ( \"context\" \"fmt\" \"log\" \"net/http\" \"github.com/coreos/go-oidc/v3/oidc\" \"golang.org/x/oauth2\" ) var ( oauth2Config *oauth2.Config verifier *oidc.IDTokenVerifier ) func main() { ctx := context.Background() provider, err := oidc.NewProvider(ctx, \"https://id.erp.net/id\") if err != nil { log.Fatal(err) } oauth2Config = &oauth2.Config{ ClientID: \"<your-client-id>\", ClientSecret: \"<your-client-secret>\", RedirectURL: \"https://your-app.com/callback\", Endpoint: provider.Endpoint(), Scopes: []string{oidc.ScopeOpenID, \"profile\"}, } verifier = provider.Verifier(&oidc.Config{ClientID: \"<your-client-id>\"}) http.HandleFunc(\"/login\", handleLogin) http.HandleFunc(\"/callback\", handleCallback) log.Println(\"Listening on :8080\") log.Fatal(http.ListenAndServe(\":8080\", nil)) } func handleLogin(w http.ResponseWriter, r *http.Request) { state := \"random-state\" // generate real random value in production url := oauth2Config.AuthCodeURL(state) http.Redirect(w, r, url, http.StatusFound) } func handleCallback(w http.ResponseWriter, r *http.Request) { ctx := r.Context() code := r.URL.Query().Get(\"code\") if code == \"\" { http.Error(w, \"missing code\", http.StatusBadRequest) return } token, err := oauth2Config.Exchange(ctx, code) if err != nil { http.Error(w, \"failed to exchange token: \"+err.Error(), http.StatusInternalServerError) return } rawIDToken, ok := token.Extra(\"id_token\").(string) if !ok { http.Error(w, \"no id_token\", http.StatusInternalServerError) return } idToken, err := verifier.Verify(ctx, rawIDToken) if err != nil { http.Error(w, \"failed to verify id_token: \"+err.Error(), http.StatusInternalServerError) return } var claims struct { Sub string `json:\"sub\"` Name string `json:\"name\"` } if err := idToken.Claims(&claims); err != nil { http.Error(w, \"failed to parse claims: \"+err.Error(), http.StatusInternalServerError) return } fmt.Fprintf(w, \"Hello, %s (%s)\", claims.Name, claims.Sub) } Python (Flask + Authlib) Using Authlib for OIDC. pip install flask authlib from flask import Flask, redirect, url_for, session, request from authlib.integrations.flask_client import OAuth app = Flask(__name__) app.secret_key = 'replace-with-strong-secret' oauth = OAuth(app) erpnet = oauth.register( name='erpnet', client_id='<your-client-id>', client_secret='<your-client-secret>', server_metadata_url='https://id.erp.net/id/.well-known/openid-configuration', client_kwargs={ 'scope': 'openid profile', }, ) @app.route('/') def index(): user = session.get('user') if user: return f\"Hello, {user.get('name') or user.get('sub')}\" return '<a href=\"/login\">Login with ERP.net</a>' @app.route('/login') def login(): redirect_uri = url_for('auth', _external=True) return erpnet.authorize_redirect(redirect_uri) @app.route('/auth/callback') def auth(): token = erpnet.authorize_access_token() userinfo = erpnet.parse_id_token(token) session['user'] = userinfo return redirect(url_for('index')) if __name__ == '__main__': app.run(debug=True) .NET / Blazor WebAssembly Program.cs (Blazor WebAssembly): using Microsoft.AspNetCore.Components.Web; using Microsoft.AspNetCore.Components.WebAssembly.Hosting; using Microsoft.AspNetCore.Components.WebAssembly.Authentication; using YourApp; var builder = WebAssemblyHostBuilder.CreateDefault(args); builder.RootComponents.Add<App>(\"#app\"); builder.RootComponents.Add<HeadOutlet>(\"head::after\"); builder.Services.AddHttpClient(\"ServerAPI\", client => client.BaseAddress = new Uri(\"https://your-api/\")) .AddHttpMessageHandler<BaseAddressAuthorizationMessageHandler>(); builder.Services.AddScoped(sp => sp.GetRequiredService<IHttpClientFactory>() .CreateClient(\"ServerAPI\")); builder.Services.AddOidcAuthentication(options => { // ERP.net ID configuration options.ProviderOptions.Authority = \"https://id.erp.net/id\"; options.ProviderOptions.ClientId = \"<your-public-client-id>\"; // no secret options.ProviderOptions.ResponseType = \"code id_token\"; // code + PKCE options.ProviderOptions.DefaultScopes.Add(\"openid\"); options.ProviderOptions.DefaultScopes.Add(\"profile\"); // options.ProviderOptions.DefaultScopes.Add(\"offline_access\"); // if allowed // Redirect URI is usually auto-derived as: // https://your-blazor-app.com/authentication/login-callback }); await builder.Build().RunAsync(); App.razor: <CascadingAuthenticationState> <Router AppAssembly=\"@typeof(App).Assembly\"> <Found Context=\"routeData\"> <AuthorizeRouteView RouteData=\"@routeData\" DefaultLayout=\"@typeof(MainLayout)\"> <NotAuthorized> <RedirectToLogin /> </NotAuthorized> </AuthorizeRouteView> </Found> <NotFound> <LayoutView Layout=\"@typeof(MainLayout)\"> <p>Sorry, there's nothing at this address.</p> </LayoutView> </NotFound> </Router> </CascadingAuthenticationState> ASP.NET Core (Confidential Web App) ASP.NET Core MVC / Razor Pages applications run on the server, so they are confidential clients. The app can safely store a Client Secret and use the standard Authorization Code or Hybrid flow. using Microsoft.AspNetCore.Authentication.Cookies; using Microsoft.AspNetCore.Authentication.OpenIdConnect; using Microsoft.IdentityModel.Protocols.OpenIdConnect; var builder = WebApplication.CreateBuilder(args); builder.Services .AddAuthentication(options => { options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme; options.DefaultChallengeScheme = \"ErpNet\"; }) .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme) .AddOpenIdConnect(\"ErpNet\", options => { options.Authority = \"https://id.erp.net/id\"; // Must match the confidential client registered in ERP.net ID options.ClientId = \"<your-client-id>\"; options.ClientSecret = \"<your-client-secret>\"; options.ResponseType = OpenIdConnectResponseType.CodeIdToken; options.CallbackPath = \"/signin-erpnet\"; options.SignedOutCallbackPath = \"/signout-erpnet\"; options.SaveTokens = true; options.GetClaimsFromUserInfoEndpoint = true; options.Scope.Add(\"openid\"); options.Scope.Add(\"profile\"); // options.Scope.Add(\"offline_access\"); // if you need refresh tokens }); builder.Services.AddControllersWithViews(); var app = builder.Build(); app.UseStaticFiles(); app.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.MapDefaultControllerRoute(); app.Run(); Summary All platforms use the same core OIDC parameters: Authority: https://id.erp.net/id Client ID / Client Secret: from ERP.net Redirect URI: your app's callback Scopes: openid profile (and others as needed) Choose a library for your platform, plug in these values, and you can sign users in with ERP.net Identity."
  },
  "auth/samples/index.html": {
    "href": "auth/samples/index.html",
    "title": "Step by step guides | ERP.net Developer Docs",
    "summary": "Step by step guides Below you can find step by step examples, grouped by topic. Security Access token via authorization code flow in a SPA (Single Page Application) Access token via authorization code flow in a console app Access token via authorization code flow in a web app Basic example of acquiring an access token Basic example- exchange an auth code for an access token Basic example- renew an access token via a refresh token"
  },
  "auth/samples/spa-access-token-auth-code.html": {
    "href": "auth/samples/spa-access-token-auth-code.html",
    "title": "Access token via authorization code flow in a SPA (Single Page Application) | ERP.net Developer Docs",
    "summary": "Access token via authorization code flow in a SPA (Single Page Application) Objective You have an external SPA that will be authorized via the ERP.net login form on behalf of an internal or external user. The application WILL provide an UI, so there'll be user interaction. Your application will be a \"pure\" front-end and will run entirely in the client's browser. Or, Your external app is an interactive application. Your external app is a web application. It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal or external user). Your external application will access the ERP.net instance on behalf of the logged user. Your external app WILL provide UI. Will work entirely in a client environment, so it won't be able to keep a secret. I.e., it's a public application (without a secret). There'll be user interaction, so your external app will use authorization code flow. The whole process in a nutshell After all, your final goal is to acquire an access token. The process is very similar to this example Basic example of acquiring an access token, but here is added another intermediate step - the process of impersonating a user. Here's a summary of how the whole process goes: Your external app will navigate to the authorize endpoint, passing your trusted app details (the trusted app, corresponding to your external app). If all's OK, the browser where your app is opened will be redirected to the ERP.net login page, where the user will enter their credentials. If the user logs in successfully, the ERP.net login page (i.e. ERP.net Identity) will be redirect to an uri, back to your external SPA. There you'll receive an authorization code. Finally you'll exchange the auth code for an access and refresh tokens at the token endpoint. You'll obtain an access and refresh tokens on behalf of the logged user (2). Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateAsCommunityUserAllowed true If your application allows external users. ImpersonateLoginUrl https://my.trusted.app/index.html The url where your external app will receive the authorization code when the user logs in successfully (see step 3 in the section above). ClientType Public Your external app will run entirely in a client-side uncontrolled environment, meaning it cannot keep a secret. Meaning it must be a public applicaiton. All other attributes can have their default values. They are not covered by this example. Steps The application below presents a single user page using html and pure javascript. Warning Don't use this code in production. Its purpose is only demonstrative. It lacks input validations, error handling and so. Initialization First we'll define some constants which we'll use later. var config = { client_id: \"my.trusted.app\", redirect_uri: \"https://my.trusted.app/app.html\", authorization_endpoint: \"https://demodb.my.erp.net/id/connect/authorize\", token_endpoint: \"https://demodb.my.erp.net/id/connect/token\", requested_scopes: \"offline_access read update\" }; We won't waste time, explaining about the constants, their names are self-explanatory. But there's one important detail- the offline_access in the requested_scopes. Its presence means that together with the access token you want also to receive a refresh token. It can be omitted, but then you'll only receive an access token and when it expires the user has to repeat the auth steps - i.e. to reenter its credentials. Body <a href=\"#\" id=\"start\">Click to Sign In</a> <div id=\"token\" class=\"hidden\"> <h2>Access Token</h2> <div id=\"access_token\" class=\"code\">no access token :(</div> </div> <div id=\"token\" class=\"hidden\"> <h2>Refresh Token</h2> <div id=\"refresh_token\" class=\"code\">no refresh token :(</div> </div> That's all the UI. A button that initiates the auth process. Two \"boxes\" visualizing the acquired access and refresh tokens. Authorization request (Authorize endpoint) The snippet below adds an event listener to the \"Click to Sign In\" button. When you press it, you'll trigger the authorization request - i.e. the defined function. document.getElementById(\"start\").addEventListener(\"click\", async function(e) { e.preventDefault(); // Create and store a random \"state\" value var state = generateRandomString(); localStorage.setItem(\"pkce_state\", state); var url = config.authorization_endpoint + \"?response_type=code\" + \"&client_id=\" + config.client_id + \"&state=\" + state + \"&scope=\" + config.requested_scopes + \"&redirect_uri=\" + config.redirect_uri; window.location = url; }); Just set-up the necessary arguments for the authroize endpoint and initiate a redirect. ERP.net Identity will take care of everything else, i.e., Will navigate to the ERP.net login page. After successful user login, will redirect to your config.redirect_uri. As you see, you're passing the following: The uri (i.e. the client id) of your trusted app config.client_id. The config.redirect_uri - the uri where you're waiting for the callback, when the user signs in. The scopes your external app needs. response_type=code. This \"instructs\" ERP.net Identity to send you a code (i.e. authorization code). Access token request (Token endpoint) The process of acquiring an access token is very simple also. When you already have the authorization code, you just have to send (i.e. make a POST request) it to the token endpoint. After, you will receive your access and refresh tokens as a response to your callback uri. First, we'll define a helper function, that will send a POST request. function sendPostRequest(url, params, success, error) { var request = new XMLHttpRequest(); request.open('POST', url, true); request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); request.onload = function() { var body = JSON.parse(request.response); if(request.status == 200) { success(request, body); } else { error(request, body); } } var body = Object.keys(params).map(key => key + '=' + params[key]).join('&'); request.send(body); } Now, the following is the actual request to the token endpoint: var args = window.location.search.substring(1); if (args != \"\") { // OAUTH REDIRECT HANDLING var idServerResponse = JSON.parse( '{\"' + args.replace(/&/g, '\",\"').replace(/=/g,'\":\"') + '\"}', function(key, value) { return key===\"\"?value:decodeURIComponent(value) }); if (idServerResponse.code) { // Exchange the authorization code for an access token sendPostRequest(config.token_endpoint, { grant_type: \"authorization_code\", code: idServerResponse.code, client_id: config.client_id, redirect_uri: config.redirect_uri }, function(request, body) { // Here you have your access and refresh tokens. document.getElementById(\"access_token\").innerText = body.access_token; document.getElementById(\"refresh_token\").innerText = body.refresh_token; }); }; } Or here's what it does broken into steps: Get the arguments from the current URI. That's because we're expecting the redirect_uri callback. I.e. ERP.net Identity sends our authorization code. If there're arguments (i.e. we are in the redirect scenario)- proceed. Parse the arguments and extract the authorization code - idServerResponse.code. Send a POST request, including the authorization code, client id and the redirect uri. The redirect uri is passed again, just as a security measure. Response is received- parse the access and refresh tokens and update the corresponding UI elements. Everything together <html> <title>ERP.net - Pure JS access token acquisition</title> <script> var config = { client_id: \"my.trusted.app\", redirect_uri: \"https://my.trusted.app/app.html\", authorization_endpoint: \"https:///demodb.my.erp.net/id/connect/authorize\", token_endpoint: \"https:///demodb.my.erp.net/id/connect/token\", requested_scopes: \"offline_access read update\" }; </script> <a href=\"#\" id=\"start\">Click to Sign In</a> <div id=\"token\" class=\"hidden\"> <h2>Access Token</h2> <div id=\"access_token\" class=\"code\">:(</div> </div> <div id=\"token\" class=\"hidden\"> <h2>Refresh Token</h2> <div id=\"refresh_token\" class=\"code\">:(</div> </div> <script> document.getElementById(\"start\").addEventListener(\"click\", async function(e) { e.preventDefault(); // Create and store a random \"state\" value var state = generateRandomString(); var url = config.authorization_endpoint + \"?response_type=code\" + \"&client_id=\" + config.client_id + \"&state=\" + state + \"&scope=\" + config.requested_scopes + \"&redirect_uri=\" + config.redirect_uri; window.location = url; }); var args = window.location.search.substring(1); if (args != \"\") { // OAUTH REDIRECT HANDLING var idServerResponse = JSON.parse( '{\"' + args.replace(/&/g, '\",\"').replace(/=/g,'\":\"') + '\"}', function(key, value) { return key===\"\"?value:decodeURIComponent(value) }); if (idServerResponse.code) { // Exchange the authorization code for an access token sendPostRequest(config.token_endpoint, { grant_type: \"authorization_code\", code: idServerResponse.code, client_id: config.client_id, redirect_uri: config.redirect_uri, code_verifier: localStorage.getItem(\"pkce_code_verifier\") }, function(request, body) { // Here you have your access token. document.getElementById(\"access_token\").innerText = body.access_token; }); }; } function sendPostRequest(url, params, success, error) { var request = new XMLHttpRequest(); request.open('POST', url, true); request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); request.onload = function() { var body = JSON.parse(request.response); if(request.status == 200) { success(request, body); } else { error(request, body); } } var body = Object.keys(params).map(key => key + '=' + params[key]).join('&'); request.send(body); } </script> </html> Resources The sample project in this example can be found here: https://github.com/ErpNetDocs/dev/blob/master/domain-api/samples/src/step-by-step/AccessTokenCodeSPA -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "auth/samples/web-app-access-token-auth-code.html": {
    "href": "auth/samples/web-app-access-token-auth-code.html",
    "title": "Access token via authorization code flow in a web app | ERP.net Developer Docs",
    "summary": "Access token via authorization code flow in a web app Objective You have an external web application that will be authorized via the ERP.net login form on behalf of an internal user. The application MAY or MAY NOT provide an UI, but there'll be user interaction at least for the initial login. Or, Your external app is an interactive application. Your external app is a web application. It will be authenticated and authorized via the ERP.net login form (on behalf of an ERP.net internal user). Your external application will access the ERP.net instance on behalf of the logged user. Your external app MAY provide UI. It's able to keep a secret, so it's also a condfidential application. There'll be user interaction (at least for the internal user to log in), so your external app will use authorization code flow. The whole process in a nutshell After all, your final goal is to acquire an access token. The process is very similar to this example Basic example of acquiring an access token, but here is added another intermediate step - the process of impersonating a user. Here's a summary of how the whole process goes: Your external app will navigate to the so called authorize endpoint, passing your trusted app details (the trusted app, corresponding to your external app). If all's OK, the browser where your app is opened will be redirected to the ERP.net login page, where the user will enter their credentials. If the user logs in successfully, the ERP.net login page (i.e. ERP.net Identity) will be redirect to a uri, back to your external web app. There you'll receive an authorization code. Finally you'll exchange the auth code for an access token at the token endpoint. You'll obtain an access token on behalf of the logged user (2). Prerequisites You have a trusted application, defined as follows: Attribute Value Comment Name My first trusted app This value doesn't matter much. It's used for user-friendly identification. ApplicationUri my.trusted.app This is your trusted app's unique identifier. It's used in the authentication process. IsEnabled true ImpersonateAsInternalUserAllowed true The trusted application will allow authentication from internal users. ImpersonateLoginUrl https://my.trusted.app/app.php The url where your external app will receive the authorization code when the user logs in successfully (see step 3 in the section above). ClientType Confidential Your external app \"will work\" with internal users only, so there'll be no \"public\" acccess. We can assume that it can keep a secret securely (in fact, it's a must). ApplicationSecretHash <base64(sha256(your-secret))> The external app's secret. All other attributes can have their default values. They are not covered by this example. Steps Unlike the Basic example of acquiring an access token, where everything is clear enough to describe with simple HTTP requests, here the examples are shown in the context of a simple PHP application (i.e. an external app). Warning Don't use this code in production. Its purpose is only demonstrative. It lacks input validations, error handling and so. Initialization First we'll define some constants which we'll use later. const AUTHORIZE_URI = \"https://demodb.my.erp.net/id/connect/authorize\"; const TOKEN_URI = \"https://demodb.my.erp.net/id/connect/token\"; const CALLBACK_URI = \"https://my.trusted.app/app.php\"; const TRUSTED_APP_URI = \"my.trusted.app\"; const TRUSTED_APP_SECRET = \"<my_plain_app_secret>\"; const DOMAIN_API_TEST_URI = \"https://demodb.my.erp.net/api/domain/odata/Crm_Customers?\\$top=10\"; We won't waste time, explaining about the constants, their names are self-explanatory. Main code Take a look at this snippet: if (isset($_POST) && isset($_POST[\"code\"])) { $authCode = $_POST[\"code\"]; $accessToken = acquireAccessToken($authCode); domainApiCall($accessToken); exit(); } sendAuthorizationRequest(); This is the main \"algorithm\" of our example external app. What does it do? Easy, If a POST request is made and its array contains code: Assume that this code is the authorization code, sent back from ERP.net Identity. Pass this code to acquireAccessToken, so an access code will be acquired. Make a call to the DomainApi via domainApiCall, passing the access token. Else send a new authorization request. Authorization request (Authorize endpoint) It's quite simple: function sendAuthorizationRequest() { $authorizeRequest = AUTHORIZE_URI . \"?\" . \"client_id=\" . TRUSTED_APP_URI . \"&\" . \"redirect_uri=\" . CALLBACK_URI . \"&\" . \"response_type=code%20id_token&\" . \"response_mode=form_post&\" . \"scope=openid%20profile%20offline_access%20read&\" . \"nonce=abc&\" . \"state=xyz\"; header(\"Location: $authorizeRequest\"); } Just set-up the necessary arguments for the authroize endpoint and initiate a redirect. ERP.net Identity will take care of everything else, i.e., Will navigate to the ERP.net login page. After successful user login, will redirect to your CALLBACK_URI. As you see, you're passing the following: The uri of your trusted app TRUSTED_APP_URI. The CALLBACK_URI - the uri where you're waiting for the callback, when the user signs in. The scopes your external app needs. In addition, there're two other important arguments: response_type=code id_token. This \"instructs\" ERP.net Identity to send you a code (i.e. authorization code) and an identity token (not discussed in this topic). response_mode=form_post. This \"tells\" ERP.net Identity that you're expecting the callback request as an HTTP POST request. Access token request (Token endpoint) The process of acquiring an access token is very simple also. When you already have the authorization code, you just have to send (i.e. make a POST request) it to the token endpoint. After, you will receive your access token as a response. function acquireAccessToken($authCode) { $tokenRequestBody = array( \"client_id\" => TRUSTED_APP_URI, \"client_secret\" => TRUSTED_APP_SECRET, \"grant_type\" => \"authorization_code\", \"code\" => $authCode, \"redirect_uri\" => CALLBACK_URI ); $opt = array( 'http' => array( 'header' => \"Content-type: application/x-www-form-urlencoded\\r\\n\", 'method' => 'POST', 'content' => http_build_query($tokenRequestBody) ) ); $context = stream_context_create($opt); $result = file_get_contents(TOKEN_URI, false, $context); if ($result == FALSE) { return false; } $clientAuthData = json_decode($result, true); return $clientAuthData[\"access_token\"]; } Authorized Domain API call Now we're authorized and we can make a legitimate call to the ERP.net Domain Api. E.g., function domainApiCall($accessToken) { $opt = array( 'http' => array( 'header' => 'Authorization: Bearer ' . $accessToken) ); $context = stream_context_create($opt); $response = file_get_contents(DOMAIN_API_TEST_URI, false, $context); print_r($response); } The response will contain the result of the query. Everything together <?php const AUTHORIZE_URI = 'https://demodb.my.erp.net/id/connect/authorize'; const TOKEN_URI = 'https://demodb.my.erp.net/id/connect/token'; const CALLBACK_URI = 'https://my.trusted.app/app.php'; const TRUSTED_APP_URI = 'my.trusted.app'; const TRUSTED_APP_SECRET = '<my_plain_app_secret>'; const DOMAIN_API_TEST_URI = 'https://demodb.my.erp.net/api/domain/odata/Crm_Customers?$top=10'; if (isset($_POST) && isset($_POST['code'])) { $authCode = $_POST['code']; $accessToken = acquireAccessToken($authCode); domainApiCall($accessToken); exit(); } sendAuthorizationRequest(); function sendAuthorizationRequest() { $authorizeRequest = AUTHORIZE_URI . '?' . 'client_id=' . TRUSTED_APP_URI . '&' . 'redirect_uri=' . CALLBACK_URI . '&' . 'response_type=code%20id_token&' . 'response_mode=form_post&' . 'scope=openid%20profile%20offline_access%20read&' . 'nonce=abc&' . 'state=xyz'; header(\"Location: $authorizeRequest\"); } function acquireAccessToken($authCode) { $tokenRequestBody = array( 'client_id' => TRUSTED_APP_URI, 'client_secret' => TRUSTED_APP_SECRET, 'grant_type' => 'authorization_code', 'code' => $authCode, 'redirect_uri' => CALLBACK_URI ); $opt = array( 'http' => array( 'header' => 'Content-type: application/x-www-form-urlencoded', 'method' => 'POST', 'content' => http_build_query($tokenRequestBody) ) ); $context = stream_context_create($opt); $result = file_get_contents(TOKEN_URI, false, $context); if ($result == FALSE) { return false; } $clientAuthData = json_decode($result, true); return $clientAuthData['access_token']; } function domainApiCall($accessToken) { $opt = array( 'http' => array( 'header' => 'Authorization: Bearer ' . $accessToken ) ); $context = stream_context_create($opt); $response = file_get_contents(DOMAIN_API_TEST_URI, false, $context); print_r($response); } ?> Resources The sample project in this example can be found here: https://github.com/ErpNetDocs/dev/blob/master/domain-api/samples/src/step-by-step/AccessTokenCodeWeb -- https://docs.erp.net/dev/topics/authentication/authentication-flows.html https://docs.erp.net/dev/topics/authentication/trusted-applications.html https://docs.erp.net/dev/domain-api/authentication.html https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow"
  },
  "auth/security-best-practices.html": {
    "href": "auth/security-best-practices.html",
    "title": "Security and Best Practices | ERP.net Developer Docs",
    "summary": "Security and Best Practices Strong authentication and authorization practices are essential for keeping ERP.net integrations secure. This page summarizes best practices when working with OAuth 2.0, ERP.net Identity, and trusted applications. Always Use HTTPS All authentication and token exchange endpoints require HTTPS. Never use http:// except in local development with valid self-signed certificates. Redirect URIs must also use HTTPS for production deployments. Protect Client Secrets Only Confidential clients can have secrets. Do not include secrets in public apps (SPAs, mobile, or native clients). Store secrets securely on the server using environment variables or secret vaults. Rotate secrets periodically and immediately after exposure. Use the Correct Flow Use Authorization Code flow (with PKCE) for interactive apps. Use Client Credentials flow for backend or service integrations. Use Hybrid flow only when both front-end and back-end components need separate tokens. Avoid workarounds such as embedding service credentials in front-end apps. Apply Least Privilege Request only the scopes your app needs (read, update, etc.). Avoid unnecessary permissions or broad access. Configure Trusted Applications with minimal scopes and access modes. Use separate apps for different integrations when possible. Handle Tokens Securely Treat all tokens as confidential credentials. Never log, email, or store tokens in plain text. Always send tokens in the Authorization: Bearer header. Do not include tokens in URLs or query parameters. Validate token signatures and expiration if implementing custom middleware. Refresh and Reference Tokens Use refresh tokens only in confidential clients. Public clients (SPAs, mobile) must re-authenticate when access tokens expire. Use Reference Access Tokens (PAT or SAT) only when long-lived access is required. Always restrict their scopes and lifetime. Secure Redirect URIs Register all redirect URIs exactly in the Trusted Application definition. Reject unknown redirect URIs to prevent redirection attacks. Use HTTPS and avoid wildcards. Always implement PKCE in public clients. Validate Trusted Applications Regularly Audit all registered Trusted Applications for correctness and minimal access. Disable or delete unused apps (IsEnabled = false). Review who can issue reference tokens via the AccessTokens policy (None, AuthenticatedUsers, AdministratorsOnly). Confirm each service user is least-privilege and properly licensed. Avoid Token Reuse Do not share access tokens between users, services, or environments. Each user or service identity should obtain its own token. Never reuse a service token across multiple integrations. Learn More OAuth 2.0 Overview Learn how ERP.net implements standard OAuth flows. Trusted Applications and Access Control How trusted app definitions control access and security modes. Access Tokens Token contents, signatures, and validation. Reference Access Tokens (PAT, SAT) Managing long-lived automation credentials securely."
  },
  "auth/sessions/license-compliance.html": {
    "href": "auth/sessions/license-compliance.html",
    "title": "License Compliance and Violations | ERP.net Developer Docs",
    "summary": "License Compliance and Violations ERP.net uses a strict one session = one license model. Each active session consumes a concurrent license slot, and every session must represent a single user or service identity. Improper token or session usage can lead to license violations. Common Violations Token sharing Using the same access token for multiple users, machines, or processes. Access tokens are tied to a single identity and session context - sharing them spreads one license across multiple users. Session multiplexing Sending parallel or concurrent API requests with the same token to perform actions for different users or clients. This effectively uses one licensed session for many users and violates ERP.net licensing terms. Shared system users It is acceptable for multiple service applications to use the same system user, as long as each establishes its own token and session. What is not allowed is reusing the same access token or session across multiple running instances or processes. Each concurrent service instance must authenticate separately and maintain its own session. License violations can lead to denied connections, data integrity issues, or noncompliance with ERP.net license agreements. Learn More Tokens and Sessions Relationship How sessions start, expire, and reconnect. License Slot Usage How licenses are consumed, released, and reserved. Session Revocation and Logout How to explicitly close sessions and release their licenses."
  },
  "auth/sessions/license-slot.html": {
    "href": "auth/sessions/license-slot.html",
    "title": "License Slot Usage | ERP.net Developer Docs",
    "summary": "License Slot Usage Each active session in ERP.net occupies one license slot. Licenses are consumed and released automatically based on session activity - not on token lifetime. How Licensing Works A license is used only when a session is opened. A license is freed when that session closes (due to inactivity, timeout, or logout). Tokens do not consume licenses on their own - they are only credentials used to start a session. The number of concurrent sessions determines the total license usage in the system. Note A valid token does not guarantee license availability. If all licenses are in use, opening a new session will fail. License Duration Each session maintains its license as long as it remains active: Interactive sessions: renewed automatically with user activity. Service sessions (Client Credentials): last up to 1 hour absolute, even if active. Inactive sessions: automatically released after 20 minutes of inactivity. Hybrid App Licensing In a hybrid setup: The frontend uses user licenses for interactive sessions. The backend uses a single system user license for automated operations. External users never consume ERP.net licenses directly - they operate through the backend's system user. This architecture allows thousands of external users to interact through one licensed backend identity. Licensing Compliance One ERP.net session = one license slot. Each internal user must have their own license. Background services must use dedicated system users. Multiplexing (sharing one license among multiple users) is not allowed. Close inactive or redundant sessions to free licenses faster. Reserved License Seats Reserved license seats guarantee that specific users can always connect, even when all other licenses are in use. These reservations are defined by administrators. How It Works A list of usernames can be assigned as reserved accounts. Each reserved account is guaranteed at least one available license slot. Other users share the remaining unreserved licenses on a first-come, first-served basis. If all unreserved licenses are in use, additional users will be denied access until a slot is freed. Example If a company has 10 total licenses and 2 reserved for specific users: Those 2 users can always log in. The remaining 8 licenses are available to everyone else. If all 8 are in use, new sessions from non-reserved users will fail until a license becomes free. Best Practices Reserve licenses for critical accounts (administrators, automation users, integrations). Keep the reserved list small to avoid starving general users. Monitor active sessions to ensure reserved users are actually utilizing their slots efficiently. Note Reserved licenses do not bypass inactivity or expiration rules - they simply guarantee availability when starting a session. Learn More Tokens and Sessions Relationship How sessions start, expire, and reconnect. License Compliance and Violations Understand correct license usage, avoid token sharing, and ensure compliance with ERP.net licensing terms. Session Revocation and Logout How to explicitly close sessions and release their licenses. Trusted Applications and Access Control Learn how system users and app modes determine license usage."
  },
  "auth/sessions/overview.html": {
    "href": "auth/sessions/overview.html",
    "title": "Sessions overview | ERP.net Developer Docs",
    "summary": "Sessions overview Tokens, sessions, and licenses in ERP.net are related but not the same thing. An access token only represents authorization - proof that a user or application has the right to call an API. A session, on the other hand, represents an active connection between ERP.net and that user or app. Each session consumes a license slot while active. Understanding how these three elements interact helps ensure your integrations are efficient, compliant, and predictable. Key Concepts Concept Description Access Token A signed credential proving that the caller (user or app) is authorized. Obtaining a token does not reserve a license. Session Created automatically on the first API request using a valid token. Each session represents an active logical connection to the ERP.net server. License Slot A limited resource consumed by an open session. Each session occupies exactly one license slot. When the session closes, the slot is released. Typical Lifecycle App obtains an access token from ERP.net Identity. No license or session is created yet. First API call using the token. ERP.net opens a session and reserves a license slot. Subsequent API calls reuse the same session. Session lifetime is extended automatically. Inactivity or explicit logout closes the session. License slot is released. Note You can hold multiple valid access tokens without consuming any licenses, until one of them is actually used to access ERP.net data. Session Expiration Basics A session has two independent expiration timers: Sliding Expiration: 20 minutes of inactivity. Each API request refreshes this timer. If no requests occur within 20 minutes, the session is closed. Absolute Expiration: Applies only to background or service sessions (Client Credentials flow). The session ends automatically after 1 hour, even if continuously active. These timers control session lifetime, not token validity. Note A valid token does not guarantee an active session. If the session has expired, the next API request will attempt to open a new one. Summary Access tokens authorize - sessions consume licenses. A token can be used only within the same ERP.net instance where it was issued. Sessions automatically close after inactivity or absolute expiration. Revoking a token does not immediately free a license - only closing the session does. Learn More Tokens and Sessions Relationship Understand how ERP.net links API calls, tokens, and sessions. License Slot Usage Learn how sessions consume and release license slots. Session Revocation and Logout See how sessions are closed automatically or by user action. License Compliance and Violations Understand correct license usage, avoid token sharing, and ensure compliance with ERP.net licensing terms. Token Lifetime and Renewal Learn how access and refresh tokens expire and renew independently from sessions."
  },
  "auth/sessions/session-revocation.html": {
    "href": "auth/sessions/session-revocation.html",
    "title": "Session Revocation and Logout | ERP.net Developer Docs",
    "summary": "Session Revocation and Logout Sessions in ERP.net represent active, licensed connections between an authenticated user or app and the ERP.net instance. When a session ends, its license slot is immediately released and can be used by another user or integration. How Sessions End A session can end in several ways: User logout – The user explicitly signs out via ERP.net Identity. Inactivity timeout – After 20 minutes of inactivity, the session closes automatically. Absolute timeout – Service sessions (Client Credentials Flow) expire after 1 hour, even if active. Server restart – All sessions are cleared when the application server restarts. Note Session lifetime and license usage are completely independent of token validity. A token may still be valid even after its session is closed - a new session will be created automatically when it's used again. Logging Out (Interactive Apps) Interactive applications using the Authorization Code Flow can explicitly end the user session via ERP.net Identity logout endpoint. GET https://<instance>.my.erp.net/id/connect/endsession When this endpoint is called: The user is redirected to a logout confirmation page. After confirmation, ERP.net Identity terminates the session. The session license is released immediately. The user can safely close the browser or sign in again. Warning This logout flow only applies to interactive sessions where a user is present. Service applications (using Client Credentials) do not use this mechanism. Service Sessions Service (non-interactive) applications cannot log out interactively. Their sessions end automatically when: The 1-hour absolute expiration time passes, or The application becomes inactive for 20 minutes. Once the session ends, the license slot is released automatically. After Revocation When a session closes - either due to logout, timeout, or inactivity: The license slot becomes available for other users or services. If the token is still valid, the next API call with the same token will reopen (reactivate) the same session, and a license will be allocated again if one is available. A 401 Unauthorized occurs only if the token itself is expired or invalid (not simply because the previous session ended). Learn More Tokens and Sessions Relationship How tokens start sessions and how both lifetimes interact. License Slot Usage How licenses are consumed, released, and reserved. License Compliance and Violations Understand correct license usage, avoid token sharing, and ensure compliance with ERP.net licensing terms."
  },
  "auth/sessions/token-session-relationship.html": {
    "href": "auth/sessions/token-session-relationship.html",
    "title": "Tokens and Sessions Relationship | ERP.net Developer Docs",
    "summary": "Tokens and Sessions Relationship In ERP.net, an access token is only a proof of authorization - it does not open a session or consume a license. A session is created only when the token is actually used to call an ERP.net API. This distinction is important for understanding why a user may still hold a valid token but no active session. How It Works Step Action What Happens 1 The app obtains an access token from ERP.net Identity. No session yet. The token only proves identity and permissions. 2 The app makes its first API call using that token. ERP.net opens a new session, assigns it to the token's user or system identity, and consumes one license slot. 3 The app continues making API calls. The same session is reused and its sliding expiration timer (20 minutes) is refreshed after each request. 4 The app becomes inactive. After 20 minutes without requests, the session closes automatically and releases the license slot. 5 The app makes a new API call with the same still-valid token. ERP.net opens a new session (if a license is available) and continues execution. If all licenses are in use, an error is returned. Note Tokens and sessions are independent: a token may still be valid even if its session has expired. Token Expiration vs Session Expiration Event What It Affects Description Token expires Authorization The app must renew or refresh the token. Existing sessions are unaffected but cannot be reused once expired. Session expires Connection and licensing The session is destroyed after inactivity or reaching absolute lifetime. A new session will be created on the next request. In short: Token = proof of access Session = active connection consuming a license Refreshing Tokens When a refresh token is used to obtain a new access token: The session remains the same, if still active. The new token continues using the same session identity. No additional license is consumed. Note Refreshing a token does not open a new session - it simply extends authorization for the existing one. Example Timeline Time Event Token State Session State License 10:00 User logs in and obtains access token Valid No session Not used 10:01 First API call Valid Session created 1 license used 10:15 Active usage Valid Session alive License held 10:35 Inactive for 20+ min Valid Session closed License released 10:40 New API call with same token Valid New session opened New license used 11:00 Token expires Expired Session may still exist License may still be held until inactivity timeout Warning A valid token does not guarantee that a license is available. If all licenses are used, a new session cannot be opened even with a valid token. Summary Sessions are created on demand, not when tokens are issued. Token validity and session lifetime are separate mechanisms. Refreshing a token keeps the same session identity. If a session expires, the next API call will attempt to create a new one. Each session consumes one license while active. Learn More License Slot Usage Understand how sessions consume and release license slots. License Compliance and Violations Understand correct license usage, avoid token sharing, and ensure compliance with ERP.net licensing terms. Session Revocation and Logout Learn how users and apps can close sessions explicitly. Token Lifetime and Renewal See how tokens expire and refresh independently from sessions."
  },
  "auth/tokens/access-tokens.html": {
    "href": "auth/tokens/access-tokens.html",
    "title": "Access Tokens | ERP.net Developer Docs",
    "summary": "Access Tokens An access token is the credential that allows your application to call ERP.net APIs on behalf of a user or a service. It defines who is calling, what can be accessed, and for how long. All ERP.net access tokens are issued by ERP.net Identity using the OAuth 2.0 standard and are formatted as JWTs (JSON Web Tokens). Access Token Basics When an application successfully authenticates (using Authorization Code or Client Credentials flow), ERP.net Identity returns an access token. This token is then passed in the Authorization HTTP header with each API request: GET /api/domain/odata/Crm_Customers?$top=5 HTTP/1.1 Host: testdb.my.erp.net Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0... If the token is valid, the ERP.net API processes the request according to the scopes and permissions defined in the token. Note Access tokens are short-lived and must be renewed periodically. Their lifetime is typically around one hour, but can vary depending on configuration. JWT Structure ERP.net access tokens are JWTs - digitally signed, URL-safe strings that contain encoded claims. A JWT consists of three parts, separated by dots: header.payload.signature Example Token eyJhbGciOiJSUzI1NiIsImtpZCI6IjVCMjc5MjBFNjUzREQ3QUM2N0QyRjY0QjMyQTE3OTkyIiwidHlwIjoiYXQrand0In0.eyJuYmYiOjE3NjIxODU3NjAsImV4cCI6MTc2MjE4OTM2MCwiaXNzIjoiaHR0cHM6Ly9wa29zdG92Lm15LmVycC5uZXQvaWQiLCJhdWQiOlsiRG9tYWluQVBJIiwiVGFibGVBUEkiLCJPTEFQIiwiQXBwU2VydmVyIiwiaHR0cHM6Ly9wa29zdG92Lm15LmVycC5uZXQvaWQvcmVzb3VyY2VzIl0sImNsaWVudF9pZCI6IlBLIiwiY2xpZW50X3N5c3RlbV91c2VyIjoiYWRtaW4iLCJjbGllbnRfc3lzdGVtX3VzZXJfdHlwZSI6IkludGVybmFsVXNlciIsImNsaWVudF9kYiI6IkUxX0RFVi0xIFRlc3QiLCJqdGkiOiIxQjc5QzI0QUIyNUUwRjY3NURGMjIzM0NERTM3MTI0NCIsImlhdCI6MTc2MjE4NTc2MCwic2NvcGUiOlsiRG9tYWluQXBpIiwicmVhZCIsInNlYyIsInVwZGF0ZSJdfQ.QjdrJ_jvbUXIGBgwajwg0dEZO8Y7VjxNW7lUi_9fdh3hliVTh-0WgOEIsClWSROsTvlzUR4Poz0kG0lKKFex9wmQ54X0M5epdeH-p3EJR018SVROp9AJNB7RiKf-dGzOFRXwjB4ueX84j8L-uIubrQL3iwmI1kI8KRGFscaVxEx7sXZFn1FVMIsaZhY8mDEEOhyicvmN9zQQOdNlSjTtP2qL6tpkS-k1kJKAE9oeKdidXbQ1yJbBHX2qUhJM8plzd-RC297m-UFqfzFgZ_Lf04cZN0xdiV8OXiuyrIC9zvfmUSex9n0ROSoIZ4BzwcZ9VM2p1FOx7RFNLdlT0Q8arQ 1. Header Specifies the algorithm and type of the token. { \"alg\": \"RS256\", \"kid\": \"5B27920E653DD7AC67D2F64B32A17992\", \"typ\": \"at+jwt\" } alg - Signing algorithm (always RS256 for ERP.net). kid - Key ID of the signing certificate. typ - Indicates the token type (access token in JWT format). 2. Payload Contains the actual claims - information about the client, permissions, and validity. { \"nbf\": 1762185760, \"exp\": 1762189360, \"iss\": \"https://pkostov.my.erp.net/id\", \"aud\": [\"DomainAPI\", \"TableAPI\", \"OLAP\", \"AppServer\"], \"client_id\": \"PK\", \"client_system_user\": \"admin\", \"client_system_user_type\": \"InternalUser\", \"client_db\": \"E1_DEV-1 Test\", \"scope\": [\"DomainApi\", \"read\", \"sec\", \"update\"] } Claim Description nbf \"Not before\" - token is invalid before this time (in Unix timestamp). exp Expiration time - when the token becomes invalid. iss Issuer - ERP.net Identity that issued the token. aud Audience - the ERP.net APIs or resources this token is valid for. client_id The application that obtained the token (Trusted Application). client_system_user The system user identity associated with the application. client_system_user_type Indicates whether it's an internal or service user. client_db The database (tenant) to which the token applies. scope The granted permissions and API access levels. 3. Signature The final part of the token is the digital signature. It verifies that the token was issued by ERP.net and has not been tampered with. The signature is created using the ERP.net Identity private key, and validated using the public key, available at: https://<instance>/id/.well-known/openid-configuration/jwks Validating Access Tokens You can decode and inspect tokens using standard JWT libraries or tools such as jwt.io. To validate a token: Verify the signature matches ERP.net Identity public key. Check the expiration time (exp) and issuer (iss). Ensure the audience (aud) includes the API you are calling. Confirm the scopes grant the needed access. Important ERP.net APIs automatically perform all these checks on every request. Manual validation is only needed when implementing middleware or custom API gateways. Security Notes Always transmit tokens using HTTPS. Never log or store access tokens in plain text. Treat them as confidential credentials. Access tokens are short-lived - design your apps to handle renewal automatically. Use refresh tokens only in trusted, confidential applications. Learn More Reference Access Tokens (PAT, SAT) Learn how long-lived reference tokens provide persistent automation access. Scopes Understand how scopes define the APIs and actions available to your app. Token Lifetime and Renewal See how token expiration works and how refresh tokens extend access."
  },
  "auth/tokens/issuing-reference-tokens.html": {
    "href": "auth/tokens/issuing-reference-tokens.html",
    "title": "Issuing Reference Tokens (PAT and SAT) | ERP.net Developer Docs",
    "summary": "Issuing Reference Tokens (PAT and SAT) Reference tokens are long-lived, opaque API keys that start with enrt_. They are issued manually and must be handled like passwords. ERP.net never stores them in plain text; you will only see the token value once, at creation time. Warning Issuing PATs or SATs is allowed only if the target Trusted Application has its AccessTokens policy set appropriately: None - reference tokens cannot be issued AuthenticatedUsers - any signed-in user may issue PATs for this app AdministratorsOnly - only admins may issue PATs or SATs for this app Personal Access Tokens (PAT) A PAT represents an individual user. Calls made with a PAT run with that user's identity and permissions. Where to issue a PAT Profile Site -> Security -> Tokens On this page the user can: See all of their existing PATs for all Trusted Applications Review description, scopes, kind, expiration, and last-used time Revoke any listed PAT immediately Create a PAT Click Create user access token. In the dialog, provide: Description (optional but recommended) Trusted Application The list shows only apps where AccessTokens = AuthenticatedUsers If the signed-in user is an admin, apps with AdministratorsOnly are also listed Expiration Time (UTC) Scopes (for example, read, update) Click Generate token. Copy the shown token value (starts with enrt_...) and store it securely. ERP.net cannot show it again. PAT Notes PATs are on behalf of the current user. Treat PATs as passwords. Never share, email, or commit them to source control. Revoke PATs immediately if leaked or no longer needed. Service Access Tokens (SAT) A SAT represents the application identity defined by a Trusted Application. Calls run using the System User configured on that Trusted Application. Where to issue a SAT Instance Manager Site -> Security -> Trusted Apps -> open a specific app Only administrators can access the Instance Manager. The AccessTokens policy of the app still applies: If AccessTokens = None, the Create application token button is disabled. If AccessTokens = AuthenticatedUsers, any signed-in user can issue PATs for that app (via Profile Site), but SATs still require admin access to Instance Manager. If AccessTokens = AdministratorsOnly, only admins can issue PATs or SATs. On this page an admin can: See all tokens for the selected Trusted Application (both PATs issued by users and SATs issued by admins) Revoke any listed token immediately Create a SAT Click Create application token. In the dialog, provide: Description (optional, but recommended) Expiration Time (UTC) Scopes (for example, read, update) The Trusted Application is fixed by the page you opened. Click Generate token. Copy and store the token securely. It will not be shown again. SAT Notes SATs always use the Trusted Application's System User. Perfect for unattended integrations, schedulers, and middleware. Admins can review and revoke any token for the app from this page. Troubleshooting I cannot select my app in the PAT dialog Make sure the Trusted Application's AccessTokens policy is not set to None. If it is set to AdministratorsOnly, you'll need an administrator to issue the token, or use another app configured with AuthenticatedUsers. The \"Create application token\" button is disabled The selected Trusted Application likely has AccessTokens = None. Ask an administrator to enable token creation or issue a PAT instead, if appropriate. My SAT calls run as the wrong identity Service Access Tokens (SATs) always act as the Trusted Application's System User, not the person who created the token. Verify the System User configuration for that Trusted Application. I lost my token value Once a token is generated, ERP.net does not store or display it again. If you lose it, generate a new token and revoke the old one to stay secure. Learn More Reference Access Tokens (PAT, SAT) Full documentation on how reference tokens work - their behavior, usage, security model, and integration with sessions. Scopes and Permissions How to choose the right scopes for your token. Token Lifetime and Renewal Understand how expirations work for access and reference tokens."
  },
  "auth/tokens/reference-access-tokens.html": {
    "href": "auth/tokens/reference-access-tokens.html",
    "title": "Reference Access Tokens (PAT, SAT) | ERP.net Developer Docs",
    "summary": "Reference Access Tokens (PAT, SAT) A reference access token is a long-lived, manually issued token that provides programmatic access to ERP.net APIs. Unlike short-lived OAuth access tokens, reference tokens are designed for automation, integration, and developer access scenarios where user interaction is not practical. All reference tokens in ERP.net begin with the enrt_ prefix, for example: enrt_1D41D4694B4F02D3D6A31FFA07E20B73F48248B26C75A0CCCB5F9DBEE41F7960 Overview Reference tokens are opaque strings (not JWTs) that reference an internal record stored and validated by the ERP.net Identity. They can be revoked instantly and are traceable by administrators. Two types of reference tokens exist: Token Type Full Name Represents Issued From Who Can Create Requires Trusted App Impersonates Scopes Required PAT Personal Access Token A specific user Profile (User) Site Any authenticated user (if allowed) Yes The user who created it Yes SAT Service Access Token A specific trusted application (via its system user) Instance Manager Site Administrators only (if allowed) Yes The system user of the trusted app Yes Trusted Application Policy Requirement Reference tokens cannot be issued unless explicitly allowed in the Trusted Application definition. Each trusted application includes the following policy setting: Attribute Purpose Values AccessTokens Controls who may issue reference tokens (PAT/SAT). None, AuthenticatedUsers, or AdministratorsOnly Meaning: None - Reference tokens cannot be issued. (Default and most secure.) AuthenticatedUsers - Any signed-in user can create a PAT for this app. Only administrators can issue SATs, since the Instance Manager site requires administrative access. AdministratorsOnly - Only administrators can issue PATs or SATs for this app. Warning Even if a user has permissions in the instance, they cannot create a PAT or SAT unless the trusted app explicitly allows it through this setting. Characteristics Always start with enrt_. Are issued manually - never automatically by OAuth flows. Are bound to a specific ERP.net instance. Have a defined expiration time (for security and compliance). Are stored securely in the ERP.net Identity and revocable immediately. Can log last used timestamp for audit and monitoring. Must be treated as secrets - never shared or embedded in public code or configuration. Usage Reference tokens can be used in any request that accepts a standard Bearer token or API key header. Option 1: Authorization Header GET /api/domain/odata/Customers HTTP/1.1 Host: testdb.my.erp.net Authorization: Bearer enrt_1D41D4694B4F02D3D6A31FFA07E20B73F48248B26C75A0CCCB5F9DBEE41F7960 Option 2: API Key Header GET /api/domain/odata/Customers HTTP/1.1 Host: testdb.my.erp.net X-Api-Key: enrt_1D41D4694B4F02D3D6A31FFA07E20B73F48248B26C75A0CCCB5F9DBEE41F7960 Other supported header names include: Api-Key X-API-KEY Note Use only one method per request - either Authorization or an API key header, not both. Personal Access Tokens (PAT) A Personal Access Token represents an individual user. It allows scripts, connectors, or integrations to act on behalf of that user without performing OAuth sign-in. Created from: the user's Profile Site. Requirements: An existing Trusted Application association. The target Trusted Application must have AccessTokens set to AuthenticatedUsers or higher. A chosen expiration time. One or more scopes (for example, read, update). Example use cases: A user's Excel connector that reads ERP.net data. Automated data exports running as the user. Developer testing or API prototyping. Warning PATs inherit the permissions of the issuing user. Always restrict scopes and expiration to the minimum necessary. Service Access Tokens (SAT) A Service Access Token represents an ERP.net application identity, not a user. It allows fully automated integrations to operate using the System User defined in the associated Trusted Application. Created from: the Instance Manager Site. Issued by: administrators only. Requirements: The target Trusted Application must have: SystemUserAllowed = true A valid System User assigned AccessTokens set to AdministratorsOnly Explicit scopes (for example, read, update) Defined expiration time Example use cases: Continuous data synchronization or ETL services. Middleware or background jobs that perform scheduled tasks. Automated integration frameworks that run 24/7. Note SATs use the system user of the trusted app. This ensures consistent permissions, stable identity, and centralized audit control. Security Guidelines Always store reference tokens in secure vaults or encrypted configuration files. Never commit them to source control or logs. Use short expiration times and rotate tokens regularly. Revoke immediately when an app or user no longer needs access. Use SATs for integrations, PATs for developer or user-level tools. Monitor last used timestamps to detect unused or suspicious tokens. Revocation and Auditing Reference tokens can be revoked at any time from: The Profile Site (for PATs) The Instance Manager Site (for PATs and SATs) Revocation is immediate - once revoked, the token becomes invalid for all future requests. ERP.net also tracks: Creation time Creator identity Scopes Last used timestamp This allows administrators to review and audit all reference token activity. Learn More Access Tokens Learn how ERP.net uses short-lived OAuth access tokens for standard app flows. Scopes Understand how scopes control what data your tokens can access. Token Lifetime and Renewal Learn how expiration and renewal policies affect security."
  },
  "auth/tokens/token-lifetime.html": {
    "href": "auth/tokens/token-lifetime.html",
    "title": "Token Lifetime and Renewal | ERP.net Developer Docs",
    "summary": "Token Lifetime and Renewal ERP.net uses multiple token types, each with its own lifetime and renewal strategy. Understanding these durations helps design secure and reliable authentication flows. Access Tokens Access tokens are short-lived credentials used to authorize API requests. Lifetime: 1 hour Purpose: To authenticate API calls on behalf of a user or application. Renewal: Obtain a new access token via a refresh token (interactive flows) or by repeating the client credentials request (service flows). Reasoning: Short validity limits the impact of token leakage. Note Access tokens are automatically verified by ERP.net APIs on every request. Expired tokens result in HTTP 401 (Unauthorized). Refresh Tokens Refresh tokens are longer-lived credentials that allow obtaining new access tokens without requiring the user to log in again. Lifetime: 1 month for confidential apps / 24 hours for public apps Issued To: Confidential, interactive applications (authorization code flow). Not Available For: Non-interactive (service) applications. Purpose: Maintain seamless user sessions without re-authentication. Usage: Exchange at /id/connect/token with grant_type=refresh_token. Example: POST /id/connect/token Content-Type: application/x-www-form-urlencoded client_id=my.trusted.app client_secret=<app_secret> grant_type=refresh_token refresh_token=<refresh_token_value> Reference Access Tokens (PAT, SAT) Reference tokens are manually issued, long-lived credentials designed for persistent or automated access. Lifetime: User-specified (days, months, or indefinite). Types: PAT – Personal Access Token (represents a specific user identity). SAT – Service Access Token (represents the system user defined in the Trusted Application). Revocation: Immediate; can be manually revoked from the Profile Site (PATs) or the Instance Manager Site (SATs). Requirements: The corresponding Trusted Application must allow issuing reference tokens through its AccessTokens policy (AuthenticatedUsers or AdministratorsOnly). Use Case: Persistent integrations, automation services, and developer utilities that need stable credentials across sessions. Note Use reference tokens only when automation or persistent access is required. For all other cases, prefer short-lived OAuth access tokens. Renewal Strategy Token Type Lifetime How to Renew Typical Use Case Access Token 1 hour Refresh token or new token request API calls Refresh Token 1 month (confidential) / 24 hours (public) User re-authentication Interactive apps Reference Token (PAT, SAT) User-defined Manual reissue Long-lived integrations Learn More Access Tokens Understand token format, claims, and validation. Reference Access Tokens (PAT, SAT) Learn how to create and manage long-lived manual tokens. Scopes See how scopes define access levels in all token types."
  },
  "auth/tokens/tokens-overview.html": {
    "href": "auth/tokens/tokens-overview.html",
    "title": "Tokens overview | ERP.net Developer Docs",
    "summary": "Tokens overview In ERP.net, tokens are used to authenticate and authorize applications and users when interacting with the system's APIs. They are the foundation of secure API access and the preferred way for external applications to communicate with ERP.net APIs. What Are Tokens Tokens are cryptographically signed credentials that represent an authenticated user or application. Instead of passing around usernames and passwords, tokens allow applications to securely prove their identity and permissions when calling APIs. ERP.net follows the OAuth 2.0 standard for token management, and all tokens are issued by the instance's ERP.net Identity. Types of Tokens Access Tokens Used by applications to call ERP.net APIs. They contain authorization data defining who or what the app represents and what it can do. Refresh Tokens Used by apps to obtain a new access token without forcing the user to sign in again. Available only to interactive clients. Reference Access Tokens (PAT, SAT) Manually issued, long-lived tokens used for integrations, scripts, or automation. PAT (Personal Access Token) – acts on behalf of a specific user. SAT (Service Access Token) – acts as a defined service identity (SystemUser). How Tokens Work in ERP.net Tokens are issued by the ERP.net Identity after successful authentication. The app then includes the token in API requests using the Authorization: Bearer <token> header. Tokens contain: Who is calling (user or service) What they can access (scopes) When the access expires Where the token was issued All API calls are validated against these claims before data access is granted. Why Use Tokens Security – avoids exposing user credentials in requests. Auditing – all API calls are traceable to a specific app or user identity. Scalability – authentication and authorization are decoupled from API logic. Flexibility – different tokens for different flows (interactive, service, or hybrid). Tokens also allow seamless integration with external systems and automation tools without compromising security or requiring direct user credentials. Token Flow in ERP.net When an external application connects to ERP.net, the flow generally involves: Authentication – The application authenticates via an OAuth 2.0 flow (Authorization Code, Client Credentials, or Hybrid). Token Issuance – ERP.net Identity issues the token representing the app or user identity. Accessing APIs – The app uses the token to authorize API requests. Token Expiration – Tokens expire after a defined period. Token Renewal – The app either uses a refresh token or requests a new access token as needed. Learn More Access Tokens Learn about how access tokens are issued and used in API requests. Reference Access Tokens (PAT, SAT) Understand how long-lived reference tokens enable service or personal access. Scopes Learn how scopes define which ERP.net resources a token can access. Token Lifetime and Renewal See how tokens expire, and how refresh tokens extend access securely."
  },
  "building-apps/concepts/api-best-practices.html": {
    "href": "building-apps/concepts/api-best-practices.html",
    "title": "Best Practices for Calling ERP.net APIs Securely | ERP.net Developer Docs",
    "summary": "Best Practices for Calling ERP.net APIs Securely Building apps that interact with ERP.net APIs requires careful attention to security, performance, and license usage. The following guidelines apply to both the Domain API and Table API and help ensure your integrations run safely and efficiently. Authentication and Tokens Always use OAuth 2.0 authentication via the ERP.net Identity. Never hardcode tokens, client secrets, or credentials in source code. Store access tokens securely - for example, in encrypted storage or a secure vault. Use short-lived access tokens and refresh tokens for long-running apps. For automation, use Service Access Tokens (SATs) instead of user tokens. Rotate tokens regularly and revoke any unused or compromised credentials. Caution Do not use Basic Authentication unless absolutely necessary (e.g., legacy BI tools). It is deprecated and significantly less secure. HTTPS and Data Protection Always use HTTPS when calling any ERP.net API. Never transmit access tokens or sensitive data over unencrypted channels. Validate SSL/TLS certificates to prevent man-in-the-middle attacks. Sanitize user inputs to avoid injection or malformed OData queries. API Efficiency Efficient API design improves performance, reduces server load, and minimizes license usage. Always filter requests to return only the necessary records. Use $select to fetch only the fields you actually need. Prefer bulk queries instead of fetching one record per call. It is faster and uses fewer sessions and network round-trips. Cache static or rarely changing entities, such as enterprise companies, user defined types or configurations. Avoid re-requesting them on every operation. For complex reports or data aggregations, use the Table API instead of the Domain API. Handle pagination with $skip and $top for large datasets, rather than requesting all data at once. Note Well-structured queries and smart caching dramatically reduce latency and license overhead while improving user experience. Session and License Management Each active session consumes a license slot. Avoid unnecessary session creation by reusing tokens where possible. Close idle sessions by logging out (interactive apps) or letting them expire naturally. For background integrations, use a dedicated system user to prevent conflicts. Monitor session counts and license usage in the Instance Manager. Error Handling and Resilience Handle 401 Unauthorized by reauthenticating or refreshing the token. Handle 429 Too Many Requests by applying exponential backoff or retry delays. Validate all API responses before processing. Log errors with sufficient context (endpoint, status code, token type). Design idempotent operations - repeatable without side effects. Security for BI and Table API Usage When using the Table API, always restrict data access with minimal scopes and filters. Apply row-level security through ERP.net permissions whenever possible. Use service identities (SATs) for scheduled BI refreshes instead of user credentials. Rotate BI access tokens periodically and audit their usage. Development and Testing Use sandbox instances for development. Separate test and production trusted applications. Never reuse production tokens in non-production environments. Enable verbose logging during testing - but redact tokens from logs. Summary Following these best practices will ensure your ERP.net integrations are: Secure – data and credentials are protected. Efficient – API usage is optimized for performance and cost. Compliant – sessions, licenses, and identities follow ERP.net rules. Learn More Domain API Reference Learn how to query and manipulate ERP.net business data. Table API Reference Retrieve high-volume analytical data with streaming support. Tokens Overview Understand access tokens, reference tokens, and scopes. License Slot Usage Learn how API sessions affect license consumption."
  },
  "building-apps/concepts/app-types.html": {
    "href": "building-apps/concepts/app-types.html",
    "title": "Application Types | ERP.net Developer Docs",
    "summary": "Application Types Application types describe how an application connects to an ERP.net instance, not what business problem it solves. They help you decide: whether users are involved at all whether API access happens on behalf of a user, on behalf of the application, or via a reference token which identity authority is involved which authentication guide applies Important ERP.net instance APIs are always accessed using tokens issued by the instance identity service (https://<instance>.my.erp.net/id). The global ERP.net Identity (id.erp.net) is used only for user authentication (SSO) and does not issue access tokens for instance APIs. Summary Application type Typical scenario Who signs in How API access is performed Auth guide Typical API SPA Applications Browser-only app, no backend Internal users On behalf of the signed-in user Instance ID for SPA Applications Domain API Web (Confidential) Applications Web app with backend Internal users On behalf of the signed-in user Instance ID for Web Applications Domain API Web Portals Customer / partner portals Internal and/or external users On behalf of the application (service identity) Instance ID for Web Portals Domain API Service Applications Background integrations, sync, daemons None On behalf of the application (service identity) Service Applications Domain API Automation Scripts, scheduled jobs, ops tooling None On behalf of a reference token Automations Domain or Table API Note Business Intelligence, reporting, and backup are usage patterns, not standalone application types. They are implemented using Service Applications or Automation, depending on operational needs. Application Type Details SPA Applications Use this type when your application: runs entirely in the browser has no backend component cannot keep a client secret Characteristics: users sign in interactively access tokens represent the signed-in user Authorization Code flow with PKCE is mandatory See: Instance ID for SPA Applications Web (Confidential) Applications Use this type when your application: has a backend capable of storing secrets serves internal users performs API calls as the signed-in user Characteristics: users sign in interactively access tokens are issued on behalf of the user Authorization Code flow is used See: Instance ID for Web Applications Web Portals Use this type when your application: allows users to sign in for identification or session context supports internal and/or external users performs all API access from the backend Characteristics: users authenticate for identity only external users never receive API access API calls are performed on behalf of the application combines Authorization Code (for users) and Client Credentials (for APIs) See: Instance ID for Web Portals Service Applications Use this type when your integration: runs without user interaction performs background processing or system integration needs controlled, scoped API access Characteristics: no user sign-in Client Credentials flow access tokens represent a service identity See: Service Applications Automation Use this type when your integration: is script-based or operational does not implement OAuth flows requires long-lived access Characteristics: no user interaction uses manually issued reference access tokens suited for jobs, tooling, and controlled automation See: Automations BI, Reporting, and Backup Scenarios Reporting, analytics, and backup workloads are implemented using: Service Applications for OAuth-based access, or Automation for long-running or scheduled tasks In these cases: prefer the Table API for high-volume, read-only access restrict scopes to read only See: Table API Overview Power BI Usage Guidelines Related Topics Choosing the Right API Trusted Applications Scopes"
  },
  "building-apps/concepts/application-server-endpoints.html": {
    "href": "building-apps/concepts/application-server-endpoints.html",
    "title": "Application Server Endpoints | ERP.net Developer Docs",
    "summary": "Application Server Endpoints Each ERP.net instance is represented by an application server, which is the central component of the platform. It provides access to essential runtime information, configuration details, and basic diagnostic tools through a small set of root-level HTTP endpoints. These endpoints are exposed directly under the instance root and are designed for discovery, monitoring, and administrative purposes. They operate independently of the hosted sites such as ERP.net Identity, Web Client, Client Center, Domain API, Table API. The base URL of an instance looks like this: https://<my-instance>.my.erp.net From this address, you can access a small set of public tools and information endpoints. They are primarily designed for system discovery, health monitoring, and administration utilities. Instance Landing Page - / Displays the default landing page with basic system information. Returns: Server version \"What's new\" link A list of available sites (Web Client, APIs, etc.) Example: GET https://<my-instance>.my.erp.net/ Site Auto-Discovery - /tools/auto-discovery Returns a JSON document that describes the current instance and the publicly exposed sites. GET https://<my-instance>.my.erp.net/tools/auto-discovery Response model (example): { \"Host\": \"string\", // Instance host name \"DbName\": \"string|null\", // Database name (if available) \"WebSites\": [ // Public sites for this instance { \"Type\": \"DomainAPI\", // See WebsiteType enum \"Status\": \"Working\", // See WebsiteStatus enum \"StatusDescription\": \"string\", \"Url\": \"https://.../api\", // Absolute URL \"System\": false, // true for system sites (e.g., ID) \"AdditionalProperties\": { // Optional, site-specific extras \"ODataServiceRoot\": \"https://.../api/domain/odata/\" // Only for DomainAPI } } ] } Properties Field Type Notes Host string Instance host name. DbName string \\| null Database name, if known. WebSites AutoDiscoveryWebSite[] List of publicly exposed sites. AutoDiscoveryWebSite Field Type Notes Type WebsiteType Type of site. Status WebsiteStatus Operational state of the site: • Unknown status not yet determined • Working site responds normally • NotWorking site is unreachable or unresponsive StatusDescription string Optional human-readable status detail. Url string (absolute URL) Root URL of the site. System boolean true for system sites (e.g., Identity). AdditionalProperties Dictionary<string,string> Optional site-specific extras. For DomainAPI, includes ODataServiceRoot pointing to the OData service root (<domain-api-url>/domain/odata/). Server Info & Downloads - /tools/server-info GET https://<my-instance>.my.erp.net/tools/server-info Response (example): { \"version\": \"26.1.0\", \"downloads\": { \"whatsNew\": \"https://<my-instance>.my.erp.net/sys/downloads/ErpNet_Whats_New.txt\", \"winClient\": \"https://<my-instance>.my.erp.net/sys/downloads/ErpNet.WinClient.Setup.x86.msi\", \"posClient\": \"https://<my-instance>.my.erp.net/sys/downloads/EnterpriseOne.Pos.Setup.x86.msi\", \"winClient64\": \"https://<my-instance>.my.erp.net/sys/downloads/ErpNet.WinClient.Setup.x64.msi\", \"posClient64\": \"https://<my-instance>.my.erp.net/sys/downloads/EnterpriseOne.Pos.Setup.x64.msi\" }, \"internalApi\": { \"useHttpCompression\": true } } Resource Monitor - /tools/resource-monitor Shows live resource usage statistics such as CPU and memory consumption. Response: application/json Example: GET https://<my-instance>.my.erp.net/tools/resource-monitor Response (example): { \"cpuUsage\": 7.12, \"processorCount\": 8, \"availableMemoryMiB\": 24567.3, \"usedMemoryMiB\": 1234.8, \"committedMemoryMiB\": 13802.6, \"totalMemoryMiB\": 25802.1 } Current instance version - /tools/ver Returns the current ERP.net instance version. Example: GET https://<my-instance>.my.erp.net/tools/ver Response: 26.2.0.76 SHA-256 Utility - /tools/sha256 Generates a SHA-256 hash from a given string and returns it as Base64. Query parameters: secret - The input string to hash Example: GET https://<my-instance>.my.erp.net/tools/sha256?secret=DEMO Response: { \"sha256\": \"dZ4Y...==\" }"
  },
  "building-apps/concepts/erp-instances.html": {
    "href": "building-apps/concepts/erp-instances.html",
    "title": "ERP Instance | ERP.net Developer Docs",
    "summary": "ERP Instance Each tenant in the ERP.net infrastructure is called an ERP Instance. General info When a client creates a subscription with the ERP.net service, they get an ERP Instance. A single account can create and manage more than one ERP Instance. This might be required for testing, validation or other purposes. Note A single ERP Instance can manage multiple legal entities (companies). Under the hood, each ERP Instance is managed as a single database. For this reason, the terms ERP Instance and database are sometimes used interchangeably. The proper term is ERP Instance, since this is more abstract and not related to any underlying technology. The ERP Instances are provided as a service from the ERP.net infrastructure and the actual storage is undistinguishable to the end user. UIN Each ERP Instance has a Unique Instance Name (UIN) or simply name. For example, the demonstration database is named \"demodb\". Root (Base) URL The ERP Instances are accessible through their root URL address. The root URL (aka Base URL) address is https://<<UIN>>.my.erp.net For example, the root URL of demodb is: https://demodb.my.erp.net You can go ahead and click that address. It opens the home page of the ERP Instance. For security reasons, it does not give access to much else than some general info and public downloads. The root URL is usually also used as base address for the instance-related web sites. For example, demodb has several web sites active. One of the sites is the Domain API site, available at: https://demodb.my.erp.net/api Note The web sites can be hosted at custom URL addresses. Using the Root URL is just a default. Instance Host/Hostname In some context, the documentation and/or software, uses the term \"Instance Host\" or \"Instance Hostname\". The instance host/name is just the host name of the instance, e.g.: demodb.my.erp.net The instance host/name is not a valid URL address. It is used usually for brevity and to denote that this is hostname for ERP.net instance."
  },
  "building-apps/concepts/glossary.html": {
    "href": "building-apps/concepts/glossary.html",
    "title": "Glossary and Key Terms | ERP.net Developer Docs",
    "summary": "Glossary and Key Terms This glossary explains common terms and concepts used throughout the ERP.net developer documentation. Access Token A short-lived token issued by ERP.net Identity that authorizes API requests. Used to prove that an app or user has permission to access ERP.net resources. Refresh Token A long-lived token used to obtain new access tokens without re-authenticating. Typically valid for 30 days. Reference Access Token Also known as a Personal Access Token (PAT) or Service Access Token (SAT). A manually generated, long-lived token stored on the server and represented by an opaque value (e.g. enrt_...). Trusted Application A registered app in ERP.net that defines how it authenticates, which users can issue tokens for it, and what System User it runs as. System User A dedicated internal user account used by background or service applications. Scope A permission boundary embedded in tokens. Determines what operations (e.g. read, update) the token holder can perform. Session A live connection between a token and an ERP.net instance. Sessions consume licenses and are automatically closed after inactivity. License Slot Represents one concurrent session in ERP.net. Each active session consumes a license slot until it ends or times out. ERP.net Identity The built-in ERP.net authentication authority that handles sign-in, issues tokens, and validates access for all apps. OAuth 2.0 The industry-standard protocol used for authentication and authorization in ERP.net. Defines flows like Authorization Code and Client Credentials. Authorization Code Flow Used by interactive applications (web or desktop) where a user signs in and authorizes the app to act on their behalf. Client Credentials Flow Used by service or background applications that act as themselves rather than a user. Authenticates via client ID and secret. Hybrid App An application that combines both user-facing and service components. Uses both Authorization Code and Client Credentials flows. Instance Manager The administrative interface for managing trusted apps, users, and licenses for an ERP.net instance. Profile Site A self-service web interface where users can manage their profile, passwords, and personal tokens (PATs). Domain API The main OData-based API for ERP.net business objects - ideal for apps and services that need structured, relational data access. Table API An OData-based, table-oriented API optimized for BI tools and large data extractions. Supports streaming for efficient large dataset transfers. Reference For a deeper understanding of these terms, explore: Authentication and Authorization Tokens Sessions Choosing the Right API"
  },
  "building-apps/concepts/overview.html": {
    "href": "building-apps/concepts/overview.html",
    "title": "Concepts Overview | ERP.net Developer Docs",
    "summary": "Concepts Overview This section describes the structural concepts that underpin all ERP.net integrations. It explains how ERP.net is organized from the perspective of an external application: how systems are segmented into instances, how applications are categorized, where integration endpoints live, and which security assumptions apply when calling APIs. The topics here establish shared terminology and boundaries that are used consistently throughout the Building Apps documentation. What This Section Covers This section focuses on: how an ERP.net instance is defined and why apps are always bound to a specific instance how application types describe common integration patterns and expected behavior how apps reach the platform through application server endpoints what it means to call APIs securely in the context of ERP.net the terminology used across documentation and configuration screens What This Section Does Not Cover This section does not provide: step-by-step implementation guidance authentication or token acquisition walkthroughs API usage examples or payload references Those topics are covered in dedicated sections. How to Use This Section Use this section as a reference when: deciding how an app should be structured interpreting configuration options or documentation language clarifying boundaries between identity, APIs, and instances If you want to start building immediately, proceed to Getting Started. If something later feels unclear or ambiguous, this section defines the underlying concepts."
  },
  "building-apps/getting-started/choose-app-type.html": {
    "href": "building-apps/getting-started/choose-app-type.html",
    "title": "Choose an Application Type | ERP.net Developer Docs",
    "summary": "Choose an Application Type Before registering your app, identify the application type that matches how your app will authenticate users and access ERP.net APIs. The application type describes how API access is performed: on behalf of a signed-in user on behalf of the application itself or using long-lived automation tokens This choice determines which setup and authentication guidance applies later. Application Type Overview Choose the row that best describes how your app identifies users and accesses ERP.net APIs: App behavior User involvement How API access is performed Application type Browser-based app with no backend; users sign in Internal users API access is performed on behalf of the signed-in user SPA Applications Web app with backend; users sign in Internal users API access is performed on behalf of the signed-in user Web (Confidential) Applications Web app where users sign in for identification only Internal and/or external users API access is performed on behalf of the application Web Portals No user interaction; background integration or sync None API access is performed on behalf of the application Service Applications Scheduled or scripted jobs using long-lived tokens None API access is performed on behalf of the token Automation Important notes: External (community) users are authenticated for identification only and never receive direct API access. When external users are involved, all API calls are performed on behalf of the application. If an app supports multiple user types, choose the application type based on how API access is performed, not who signs in. What This Choice Affects The selected application type determines: which authentication scenario applies whether tokens represent a user, an application, or a reference token which setup and implementation guides you should follow You do not configure anything at this stage. This step is only about choosing the correct documentation path. Reporting, Analytics, and Data Export Reporting, analytics, backups, and bulk exports are usage patterns, not separate application types. They are typically implemented as: Service Applications for OAuth-based, short-lived access, or Automation for controlled, long-running or scheduled tasks API selection (Domain API vs Table API) is handled in the next step. Detailed Reference For a full description of each application type and its expected behavior, see Application Types. Next Step Once you have identified the correct application type, continue with Choose the Right API."
  },
  "building-apps/getting-started/choose-right-api.html": {
    "href": "building-apps/getting-started/choose-right-api.html",
    "title": "Choosing the Right API | ERP.net Developer Docs",
    "summary": "Choosing the Right API ERP.net provides multiple APIs, each intended for a specific integration scenario. In this step, you select the API that best matches how your app will interact with an ERP.net instance. Available APIs API Description Typical Use Case Domain API Business-oriented API built on OData, exposing the ERP.net domain model with validation and relationships. Integrations, automation, and custom applications that need full business logic support. Table API Raw, table-level API built on OData, optimized for analytics; supports streaming for large datasets. Power BI and other reporting tools that need fast, read-only data access. How to Choose Use the Domain API if your app needs to: Work with business objects (documents, items, customers, orders) Create, update, or delete data Rely on ERP.net business rules and validations Use the Table API if your app needs to: Read large volumes of data efficiently Feed BI or reporting tools Perform analytics or backups without business logic If your app primarily changes data, choose the Domain API. If it primarily reads data in bulk, choose the Table API. Reference Documentation Detailed technical documentation for each API is available here: Domain API Reference Table API Reference Next Step After selecting the appropriate API, continue with Create a Trusted Application."
  },
  "building-apps/getting-started/create-trusted-app.html": {
    "href": "building-apps/getting-started/create-trusted-app.html",
    "title": "Create a Trusted Application | ERP.net Developer Docs",
    "summary": "Create a Trusted Application Before an app can authenticate or call ERP.net APIs, it must be registered in the target ERP.net instance as a Trusted Application. This registration defines how the instance recognizes your app and what level of access it may request. What You Are Doing in This Step In this step, you will: Create a Trusted Application record in the target ERP.net instance Assign a unique application identifier Enable the access modes required by your app Grant the minimal scopes needed for your integration You are not implementing authentication yet. You are defining the app's identity and permissions. Required Information When creating a Trusted Application, you will need to provide: A unique Application URI that identifies your app The client type (public or confidential), based on your app design The access modes your app requires (interactive, service, or both) The scopes your app is allowed to request If your app runs as a background service, you will also need: A system user with least-privilege permissions Configuration Guidance Use the following rules when configuring your Trusted Application: Use a stable, globally unique Application URI Grant only the scopes your app requires Enable interactive access only for user-facing apps Enable service access only for background integrations Prefer confidential clients unless your app cannot keep a secret Avoid enabling options you do not actively need. Reference Documentation This page does not describe all Trusted Application attributes. For a complete explanation of configuration options, attributes, and security considerations, see Trusted Applications. Next Step After registering the Trusted Application, continue with Get an Access Token."
  },
  "building-apps/getting-started/demo-api-call.html": {
    "href": "building-apps/getting-started/demo-api-call.html",
    "title": "Demo API Call (testdb) | ERP.net Developer Docs",
    "summary": "Demo API Call (testdb) This topic is an optional smoke test that validates: request format → connectivity → JSON response It is useful if you want to quickly verify that your tooling (curl, Postman, client code) can reach the API and receive data. Important This demo call does not confirm that your application is registered, authenticated, or authorized. To validate the full integration path (access token → API request → successful response) using your own instance, follow Make Your First API Call. When to Use This Use the demo instance if you: Want to test HTTP request formatting Want to confirm outbound connectivity to the service Want to inspect a real JSON payload quickly Do not use this demo path for production integrations or real customer data. Demo Instance and Reference Token The public demo instance is: Host: testdb.my.erp.net You can call it using the company-provided demo reference token. Warning The demo token is intended only for the public sandbox instance: It works only for testdb.my.erp.net. It may be rotated or revoked at any time. Do not use it for production integrations or real customer data. Treat it as a secret (do not publish it in client-side code or logs). Send the Request Example request: GET https://testdb.my.erp.net/api/domain/odata/Crm_Sales_Customers?$top=10 Authorization: Bearer enrt_C99474338E7E587DA64126E26F138E3E0E2D0E984256073427D122B4B39AC766 Accept: application/json Verify Success A successful demo call has all of the following: HTTP 200 OK A JSON response body No redirects to a login page If this succeeds, basic connectivity and request formatting are confirmed. What This Does Not Validate This demo call does not validate: Your app registration Token issuance from your identity service Authorization and permissions for your tenant Access to your instance data Next Step To validate a real end-to-end integration using your own instance, continue with Make Your First API Call."
  },
  "building-apps/getting-started/first-api-call.html": {
    "href": "building-apps/getting-started/first-api-call.html",
    "title": "Make Your First API Call | ERP.net Developer Docs",
    "summary": "Make Your First API Call This step validates the full integration path: access token → API request → successful response If this step succeeds, your app is correctly registered, authenticated, and authorized. Choose a Validation Endpoint Use the API you selected earlier and pick an endpoint that is: Read-only Simple Known to return data If you have not selected an API yet, return to Choosing the Right API. For the first call, avoid complex queries or write operations. Note If you only want to validate request format and basic connectivity using the public demo instance (testdb), see Demo API Call (testdb). Send the Request Use the access token obtained in the previous step and include it as a Bearer token. A minimal request looks like this: GET {api-endpoint} Authorization: Bearer {access_token} Accept: application/json Where: {access_token} is the token issued by the instance identity service {api-endpoint} belongs to the selected API surface (Domain API or Table API) Verify Success A successful first call has all of the following: HTTP 200 OK A JSON response body No redirects to a login page At this point, end-to-end access is confirmed. Warning Do not log access tokens or embed secrets in client-side code. See Security Best Practices. Next Step Once your first API call succeeds, continue with Next Steps."
  },
  "building-apps/getting-started/get-access-token.html": {
    "href": "building-apps/getting-started/get-access-token.html",
    "title": "Get an Access Token | ERP.net Developer Docs",
    "summary": "Get an Access Token In this step, you obtain a working access token that your app can use to call ERP.net APIs. Access tokens for ERP.net APIs are issued only by the identity service of a specific ERP.net instance. The purpose of this step is to follow the correct authentication flow for your scenario and verify that token issuance works end to end. Use the Correct Identity Authority When calling ERP.net APIs, your app must authenticate against the instance identity service. The instance identity service issues access tokens that are accepted by the instance APIs. The global ERP.net authority is used only for authentication scenarios where ERP.net acts as an external identity provider. It does not issue access tokens for ERP.net APIs. If you are unsure which authority applies to your scenario, see: Identity Authorities (Instance vs Global). Verify Trusted Application Configuration Before requesting a token, ensure that the app is correctly registered in the target instance: A Trusted Application exists and is enabled The correct access modes are enabled (interactive and/or service) The required scopes are allowed If this configuration is incorrect, token requests will fail regardless of the authentication flow. Reference: Trusted Applications Scopes Follow the Tutorial for Your Scenario The exact steps for obtaining a token depend on your application type and authentication model. Use the tutorial that matches your scenario: Web Applications Single Page Applications (SPA) Web Portals Service Applications Automations These tutorials are the source of truth for request parameters, flows, and examples. Validate the Token Before continuing, confirm that: A token is issued successfully (no authentication error) The token issuer matches the instance identity service The token is accepted by the target API Your first API request returns HTTP 200 If the API responds with 401 or 403, verify: The identity authority (issuer) is correct The Trusted Application configuration matches your scenario The required scopes are granted Next Step Once you have a valid access token, continue with Make Your First API Call."
  },
  "building-apps/getting-started/next-steps.html": {
    "href": "building-apps/getting-started/next-steps.html",
    "title": "Next Steps | ERP.net Developer Docs",
    "summary": "Next Steps You have successfully authenticated your app and made an API call against an ERP.net instance. From here, the next steps depend on what you are building. Work with Business Data (Domain API) If your app works with business objects or modifies data, start with the Domain API: Domain API Introduction Overview of the Domain API, data model, and general principles. Querying Data Filtering, paging, sorting, and querying entities. Data Manipulation Creating, updating, and deleting business objects. Common Tasks Practical patterns for frequent integration scenarios. Example Apps End-to-end examples demonstrating real integrations. Analytics and Reporting (Table API) If your integration focuses on analytics, reporting, or bulk data access: Table API Overview Read-only, high-performance access to raw table data. Power BI Usage Guidelines Recommended patterns for reporting and analytics workloads. Review Authentication and Security Before moving to production, review: Authentication and Authorization Identity model, tokens, flows, and scopes. Security Best Practices Token handling, secrets, least privilege, and auditing. At this point, you have a working integration and can proceed with deeper implementation using the sections above."
  },
  "building-apps/getting-started/overview.html": {
    "href": "building-apps/getting-started/overview.html",
    "title": "Getting Started | ERP.net Developer Docs",
    "summary": "Getting Started This guide walks you through the minimum steps required to build a working integration with ERP.net. By following this guide, you will register an app, authenticate it, and successfully call an ERP.net API against a real instance. What This Guide Covers The Getting Started flow consists of the following steps: Verify prerequisites and access to an ERP.net instance Register your app as a Trusted Application Obtain an access token Make a successful API call Each step builds on the previous one and results in a verifiable outcome. Expected Outcome At the end of this guide, you will have: A registered Trusted Application A working method for obtaining access tokens A successful API call returning a valid response Start Here Begin with Prerequisites."
  },
  "building-apps/getting-started/prerequisites.html": {
    "href": "building-apps/getting-started/prerequisites.html",
    "title": "Prerequisites | ERP.net Developer Docs",
    "summary": "Prerequisites This page lists what you must have in place before starting the Getting Started flow. If any of these are missing, stop here and resolve them first. Target ERP.net Instance You need the base URL of the ERP.net instance you will connect to, for example: https://{instance}.my.erp.net All API calls and authentication requests are scoped to a specific instance. App Scenario You should know whether your app operates: Interactively (users sign in) Non-interactively (service, automation, or background integration) This determines how the app authenticates and which setup steps apply later. Required Access To proceed, you must be able to: Register (or request registration of) a Trusted Application in the target instance Use (or request) the required scopes for your integration If you do not have this access, coordinate with the instance administrator before continuing. Tools You need a way to send HTTP requests to validate authentication and API access. Any of the following are sufficient: curl Postman Your application code Common Pitfalls Avoid the following: Mixing instance-specific and global identity authorities Guessing API endpoints instead of using documented ones Requesting overly broad permissions instead of the minimum required scopes"
  },
  "building-apps/installing-external-applications.html": {
    "href": "building-apps/installing-external-applications.html",
    "title": "External application lifecycle operations | ERP.net Developer Docs",
    "summary": "External application lifecycle operations Overview ERP.net supports a browser-initiated lifecycle flow for external applications via ERP.net Instance Manager. This flow allows an administrator to: Install an external application (Instance Manager creates a Trusted Application in the target ERP.net instance). Uninstall an external application (Instance Manager removes the app registration from the instance). After a successful operation, Instance Manager sends an app lifecycle event payload (schema = erpnet.appLifecycleEvent.v1) to the external application's redirectUrl, so the external application can complete onboarding. Related topics: Trusted Applications (configuration) Scopes Service Access Tokens OAuth2 Client Credentials Flow Security Best Practices Getting Started Prerequisites You have an ERP.net instance base URL (for example: https://mycompany.my.erp.net). You can authenticate to ERP.net Instance Manager with an administrator account. Your external application has: a stable applicationUri identifier an HTTPS redirectUrl endpoint that can receive an HTTP POST with a JSON body and return a successful (2xx) response Note In production, redirectUrl must be an absolute HTTPS URL. Endpoints Install endpoint GET {instanceBaseUrl}/manage/apps/lifecycle/install Example: https://mycompany.my.erp.net/manage/apps/lifecycle/install ?applicationUri=MyExternalAppIdentifier &redirectUrl=https://my-external-app.com/callback/ &applicationName=My External App &clientType=Confidential &requestSecret=true Uninstall endpoint GET {instanceBaseUrl}/manage/apps/lifecycle/uninstall Example: https://mycompany.my.erp.net/manage/apps/lifecycle/uninstall ?applicationUri=MyExternalAppIdentifier Install URL parameters Parameter Type Default Description applicationName string (none) Name of the application. Used to set the Trusted Application name/display name when the registration is created. applicationUri string (none) External application identifier used to create its registration in the ERP.net instance. Required. clientType string Public Client type of the application. Supported values: Confidential, Public. redirectUrl URL (none) Redirect URL used as the application's sign-in/impersonation callback. ERP.net Instance Manager also uses this URL to POST the lifecycle event payload (JSON) after a successful operation. impersonateAsInternalUserAllowed bool false For Public clients: whether impersonation as an internal user is allowed. impersonateAsCommunityUserAllowed bool false For Public clients: whether impersonation as a community user is allowed. requestSecret bool false If true, Instance Manager will attempt to issue credentials and include them in the lifecycle event payload. secretType string SAT Credential kind to issue when requestSecret=true. SAT = Service Access Token (a reference token). clientCredentials = a client secret that the app uses in the OAuth Client Credentials flow to obtain an access token. Supported values: SAT, clientCredentials (case-insensitive). Uninstall URL parameters Parameter Type Default Description applicationUri string (none) External application identifier to uninstall. Required. Validation rules ERP.net Instance Manager validates the request before allowing the user to proceed: Generic Only ERP.net instance administrators can perform install/uninstall. applicationUri is required. Install-specific If clientType=Public: redirectUrl must be present and valid. At least one impersonation flag must be enabled: impersonateAsInternalUserAllowed=true or impersonateAsCommunityUserAllowed=true If requestSecret=true for a Public client, the request is rejected: Error: Cannot request credentials for a public client. User flow (interactive approval) Your external application initiates a browser request to the install/uninstall endpoint. ERP.net Instance Manager opens. If the user is not authenticated, Instance Manager requires login. Instance Manager displays a confirmation page with the operation details and an Install / Uninstall action button. When the user clicks the action button: ERP.net Instance Manager performs the operation in the ERP.net instance. ERP.net Instance Manager sends an HTTP POST to redirectUrl with a JSON payload describing the lifecycle event. The callback must return a successful response (2xx). Otherwise, the operation is treated as failed. Lifecycle event payload (onboarding callback) ERP.net Instance Manager sends the lifecycle event payload to redirectUrl using HTTP POST with JSON. Payload fields Field Type Present Description schema string always Always erpnet.appLifecycleEvent.v1. eventId string (GUID) always Unique event identifier. event string always Event type, e.g. installed, uninstalled. occurredAt string (UTC timestamp) always When the event occurred (UTC). instanceBaseUrl string always Instance host/base URL (example: mycompany.my.erp.net). user string always The approving user (example: admin). secret string only when credentials are issued Issued credential value (sensitive). secretType string only when credentials are issued Credential type (SAT or ClientCredentials). Examples 1) Confidential without requesting a secret Request: https://mycompany.my.erp.net/manage/apps/lifecycle/install ?applicationUri=MyExternalAppIdentifier &redirectUrl=https://my-external-app.com/callback/ &applicationName=My External App &clientType=Confidential Response: { \"schema\": \"erpnet.appLifecycleEvent.v1\", \"eventId\": \"0799261b-6a1a-4a7a-afc6-6a9b7fcb8a8c\", \"event\": \"installed\", \"occuredAt\": \"2026-01-21T14:34:09.6573137Z\", \"instanceBaseUrl\": \"mycompany.my.erp.net\", \"user\": \"admin\" } 2) Confidential requesting a secret and specifying SAT Request: https://mycompany.my.erp.net/manage/apps/lifecycle/install ?applicationUri=MyExternalAppIdentifier &redirectUrl=https://my-external-app.com/callback/ &applicationName=My External App &clientType=Confidential &requestSecret=true &secretType=sat Response: { \"schema\": \"erpnet.appLifecycleEvent.v1\", \"eventId\": \"3857aa99-881c-4798-b888-7ed72d137691\", \"event\": \"installed\", \"occuredAt\": \"2026-01-21T14:39:20.6048228Z\", \"instanceBaseUrl\": \"mycompany.my.erp.net\", \"user\": \"admin\", \"secret\": \"enrt_CE17A40CBEBB9F59EECA1EF199F438D64FC42618B1677BE9279E8E4351BA9811\", \"secretType\": \"SAT\" } 3) Confidential requesting a secret and specifying ClientCredentials Request: https://mycompany.my.erp.net/manage/apps/lifecycle/install ?applicationUri=MyExternalAppIdentifier &redirectUrl=https://my-external-app.com/callback/ &applicationName=My External App &clientType=Confidential &requestSecret=true &secretType=clientCredentials Response: { \"schema\": \"erpnet.appLifecycleEvent.v1\", \"eventId\": \"148709ff-c9a2-49dc-96bc-88ee90fda10a\", \"event\": \"installed\", \"occuredAt\": \"2026-01-21T14:40:05.024675Z\", \"instanceBaseUrl\": \"mycompany.my.erp.net\", \"user\": \"admin\", \"secret\": \"dTscMD5yK7eMSw3jUKCKGgc1\", \"secretType\": \"ClientCredentials\" } 4) Uninstall Request: https://mycompany.my.erp.net/manage/apps/lifecycle/uninstall ?applicationUri=MyExternalAppIdentifier Response: { \"schema\": \"erpnet.appLifecycleEvent.v1\", \"eventId\": \"0e3bf686-4abc-4230-9ca0-47c4efa12b09\", \"event\": \"uninstalled\", \"occuredAt\": \"2026-01-21T14:42:23.1597831Z\", \"instanceBaseUrl\": \"mycompany.my.erp.net\", \"user\": \"admin\" } Concepts Client types Confidential Intended for server-side applications that can securely store credentials. May request credentials via requestSecret=true. Public Intended for apps that cannot securely store credentials (e.g. browser-based apps). Must provide redirectUrl. Must enable impersonation for at least one user type: internal and/or community Cannot request credentials (requestSecret=true is not allowed). Credential types When requestSecret=true (for confidential clients), Instance Manager can issue credentials: SAT Service Access Token (reference token). In the current implementation, it is issued with a long validity window (example: 10 years). ClientCredentials Client secret intended for use with the Client Credentials flow. Callback delivery (redirectUrl) After the user approves the action, Instance Manager sends the lifecycle event payload to redirectUrl via HTTP POST (JSON, camelCase). The external application must: accept the POST request validate and persist the onboarding data as appropriate return a successful HTTP status code (2xx) In production environments, redirectUrl must be an absolute HTTPS URL. Secret handling If the payload contains secret, treat it as a password: do not log it store it in a secret manager / vault restrict access (least privilege) Troubleshooting Only administrators can perform this action. Cause: The user is not an administrator. Resolution: Sign in with an administrator account in ERP.net Instance Manager. Missing required parameter: applicationUri. Cause: The install/uninstall URL does not include applicationUri. Resolution: Provide applicationUri in the query string. Public clients require a valid redirectUrl. Cause: clientType=Public but redirectUrl is missing or invalid. Resolution: Provide a valid redirectUrl (and ensure it meets the HTTPS requirement in production). Public clients must allow impersonation for at least one user type (internal or community). Cause: clientType=Public and both impersonation flags are false. Resolution: Set at least one of: impersonateAsInternalUserAllowed=true impersonateAsCommunityUserAllowed=true Cannot request credentials for a public client. Cause: clientType=Public with requestSecret=true. Resolution: Use clientType=Confidential if you need credentials issued, or set requestSecret=false for public clients. Callback fails (non-2xx response) Cause: The external application's redirectUrl endpoint returns an error response, or cannot be reached. Resolution: Ensure redirectUrl is reachable from ERP.net Instance Manager and returns a successful response (2xx). Ensure redirectUrl is absolute HTTPS in production."
  },
  "building-apps/overview.html": {
    "href": "building-apps/overview.html",
    "title": "Building Apps Overview | ERP.net Developer Docs",
    "summary": "Building Apps Overview This section describes how applications integrate with ERP.net at a platform level. Any software that connects to an ERP.net instance through its public APIs is treated by the platform as an ERP.net App. Apps are external to the core ERP and interact with it through well-defined boundaries. What an ERP.net App Is In ERP.net, an app is not a specific product or framework. It is a role assigned to any application that communicates with an instance through APIs. Apps may be implemented as: User-facing applications Background or service-based integrations Automation or synchronization components Reporting and analytics solutions Apps can operate internally, connect external systems, or be distributed through the ERP.net Marketplace. Different app designs are formalized as application types, which are described in more detail in Application Types. Where Apps Run Each ERP.net database is an instance. Apps always connect to a specific instance and are subject to that instance's configuration, data scope, and access rules. For details, see ERP.net Instances. How Apps Are Identified and Controlled Apps do not access an instance implicitly. Each app is explicitly registered inside the instance and represented as a Trusted Application. This registration defines how the app is identified and what level of access it is granted. Authentication and authorization are enforced by the ERP.net Identity Service and apply uniformly across all APIs. Authentication, authorization, and related concepts are covered in detail in Authentication and Authorization. How Apps Interact with the Platform ERP.net exposes APIs that apps use to interact with data and functionality within an instance. Different APIs are designed for different integration scenarios, such as application development or high-volume data access. The available API surface and access model depend on the app's design and intended use. Guidance on selecting the appropriate API is provided in Choosing the right API. High-Level Interaction Model flowchart LR user([User or Service]) --- app([ERP.net App]) subgraph \"ERP.net Instance\" direction TB idp([ERP.net Identity Service]) api([ERP.net APIs]) data([ERP.net Data]) api --> data end app -->|Authenticate| idp app -->|API Calls| api This model applies to all ERP.net Apps, regardless of implementation or deployment style. How to Proceed If you are ready to build an app, continue with Getting Started. That section walks through the initial setup, app registration, and making your first API calls."
  },
  "domain-api/common-tasks/change-language.html": {
    "href": "domain-api/common-tasks/change-language.html",
    "title": "Change the response language | ERP.net Developer Docs",
    "summary": "Change the response language Overview Thanks to the built-in multilanguage support you can save data in multiple languages. Then, when you retrieve them back via the Domain API, you get the data all at once as a complex type of multilanguage string- i.e. all translations you have defined. { \"en\": \"Apple\", \"de\": \"Apfel\" } Document printout However, sometimes there are cases where the data must be returned, visualized for a particular language. I.e. it's not appropriate to return all defined translations at once. An example of this is when you acquire a document printout. The result of this feature is a document, a file, rendered in a specific language. What if you want the printout to be displayed in a language other than the default? Note The default language in Domain API is English (en). If you want it to be generated in German, you must specify it explicitly. Supported ways to specify the response language Url parameter: culture=de Cookie, containing a key=value: .AspNetCore.Culture=de Accept-Language HTTP header: Accept-Language: de All you have to do is to specify the language in one of the ways listed above. Caution The methods mentioned above are applicable only when using OAuth for authorization. You can find additional information here. Warning If there's more than one way to change the language at the same time, prioritization takes place. The priority is the same as listed above: (1) url parameter, (2) cookie, (3) accept-language header. I.e. if you send a request, containing a url parameter culture=de and also specify an HTTP header Accept-Language: en, the chosen language will be German. Going back to the example of generating a document printout mentioned above, here's what a typical request looks like, POST /api/domain/odata/Crm_Invoicing_Invoices(51a63a99-c96d-4876-b205-fced610143ae)/GetPrintout HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json { \"fileFormat\": \"pdf\", \"printout\": { \"@odata.id\": \"General_Printouts(f5229037-b420-46a4-81a0-f11f7d112879)\" } } The result of the request will be the printout as base64 encoded pdf file in the default Domain API language. If you want to change the language, it's enough to simply specify it in one of the three ways above, POST /api/domain/odata/Crm_Invoicing_Invoices(51a63a99-c96d-4876-b205-fced610143ae)/GetPrintout HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json Accept-Language: de { \"fileFormat\": \"pdf\", \"printout\": { \"@odata.id\": \"General_Printouts(f5229037-b420-46a4-81a0-f11f7d112879)\" } } The only change is the additional request HTTP header Accept-Language: de. The result will be the same printout, but in German. Note Changing the language simply instructs ERP.net to \"choose\" it from what is saved in the multilanguage string attributes. If the \"chosen\" language isn't present in a multulanguage string attribute, it will be returned transliterated. All non-multilanguage strings will be returned as they are. Specify response language when using Basic Auth Unlike the recommended OAuth authorization method, changing the response language while using Basic Auth can only be accomplished by specifying the lang parameter in the request URL. E.g., POST /api/domain/odata/Crm_Invoicing_Invoices(51a63a99-c96d-4876-b205-fced610143ae)/GetPrintout?lang=bg HTTP/1.1 Host: demodb.my.erp.net Authorization: Basic xxxxx lang=bg - that's the addition, and as a result, the prinout will be returned, but in Bulgarian. Anyway, the use of Basic Auth is strongly discouraged and should be approached with special caution, only as a last resort. Here, you can find information on how to migrate your Basic Auth workflow to OAuth: Authentication in ERP.net Register trusted app Step-by-step / acquire an access token Other cases, where language change has an effect Error responses / messages For example, we'll update a customer, but in such a way that we get an error back. We'll trigger the R27159 validation business rule. PATCH /api/domain/odata/Crm_Customers(e99186bc-d3bc-4a93-b169-5baec1d45540) HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json { \"FromDate\": \"2022-01-01\", \"ThruDate\": \"2021-01-01\" } Accordingly, the result will be the following error: { \"error\": { \"message\": \"An error occurred while saving data to the database\\r\\n The validation R27159: FromDateLessThanThruDate failed for event Commit: \\r\\n\\r\\nCustomer's From Date 1/1/2022 12:00:00 AM should not be greater than customer's Thru Date 1/1/2021 12:00:00 AM. (Constraint R27159)\" } } If we change the language (this time as a url parameter), the request will look like this, PATCH /api/domain/odata/Crm_Customers(e99186bc-d3bc-4a93-b169-5baec1d45540)?culture=bg HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json { \"FromDate\": \"2022-01-01\", \"ThruDate\": \"2021-01-01\" } The difference is adding the culture=bg parameter to the url. We'll receive the same message, but translated into Bulgarian: { \"error\": { \"message\": \"Грешка при записване.\\r\\n Валидацията R27159: FromDateLessThanThruDate не е била успешна при събитие Commit: \\r\\n\\r\\nСтойността на полето 'От дата' 1.01.2022 г. 0:00:00 ч. не трябва да надвишава стойността на полето 'До дата' 1.01.2021 г. 0:00:00 ч. (Constraint R27159)\" } }"
  },
  "domain-api/common-tasks/context-parameters.html": {
    "href": "domain-api/common-tasks/context-parameters.html",
    "title": "Context parameters | ERP.net Developer Docs",
    "summary": "Context parameters In some cases the behaviour of the domain model depends on the provided context parameters. Such parameters are the current user, current language, current enterprise company, current enterprise company location and current role. For example some business rules require current enterprise company to determine the costing and pricing currency of a product. The current user is implicitly determined by the session - this is the logged in internal user. The language may be provided by one of the standard ways defined by ASP.NET Core - culture URL parameter, .AspNetCore.Culture cookie or Accept-Language HTTP header. Providing current enterprise company, enterprise company location and role for the API request. 1. URL Parameters CurrentEnterpriseCompanyId=GUID1&CurrentEnterpriseCompanyLocationId=GUID2&CurrentRoleId=GUID3 OR ErpContextParameters=GUID1,GUID2,GUID3 The ErpContextParameters URL parameter requires three guids - the first one is enterprise company Id, the second one is enterprise company location Id and the third one is the role Id. 2. HTTP header Prefer The Prefer HTTP Header can be used by a client to request particular server behaviors. In this case we can append multiple Prefer headers: Prefer: CurrentEnterpriseCompanyId=GUID1 Prefer: CurrentEnterpriseCompanyLocationId=GUID2 Prefer: CurrentRoleId=GUID3 OR Prefer: ErpContextParameters=GUID1,GUID2,GUID3 3. Cookie We can provide cookie with name ErpContextParameters and value 'GUID1,GUID2,GUID3' Validation If the provided value can't be parsed to a valid guid it is ignored. If the current user has no acces to the provided enterprise company by security reasons, the provided CurrentEnterpriseCompanyId is ignored. If the provided company location Id is not amongs the company locations of the current enterprise company the value is ignored. If the provided role Id is not accessible by the current user the value is ignored."
  },
  "domain-api/common-tasks/create-notification.html": {
    "href": "domain-api/common-tasks/create-notification.html",
    "title": "Create notification | ERP.net Developer Docs",
    "summary": "Create notification Overview As already known, notifications in ERP.net are an entity, part of the domain model. Communities.Notifications Entity. Roughly, each notification is a message intended for a specific user. Additionally, the notification MAY reference a data object- e.g. the notification subject. This is expressed through the following entity attributes: User DataObject ERP.net creates and manages various notifications according to certain business rules, triggered by specific events. E.g. when someone replies to your comment- you'll get a notification. This flow is managed by a specific business rule (R33428 SocialComment - Notify User Comment Replied) More information about all notification types (i.e. notification classes) and when they're created can be found in the separate topic Notifications. Create a notification programmatically It's possible to create a notification yourself via the Domain API. You simple need to: Specify the entity that will be the subject of the notification. Invoke its method CreateNotificaiton. Populate the required notification's attributes such as the target user, the notification class, the notification subject. POST /api/domain/odata/Crm_Customers(79f3f74e-098a-4d91-9714-c4f845c2dc62)/CreateNotification HTTP/1.1 Host: demodb.my.erp.net Content-Type: application/json { \"user\": { \"@odata.id\": \"Systems_Security_Users(9da64839-a8d0-491d-aebb-4d18fa42b014)\" }, \"notificationClass\": \"NT_SOC_NEW_POST\", \"subject\": \"Hello from Domain API!\" } That's it. A notification will be created. Addressed to the specified user; originating from the specified customer. CreateNotification() in detail CreateNotification is an API method, defined in the EntityObject type. This means that it can be invoked from any entity. It's available for every entity in our Domain Model documententation. Here's a link to the method, used in the example from above, https://docs.erp.net/model/entities/Crm.Customers.html#createnotification Additionally, once the notification is created (as persistent data, in the database), it will be wrapped in a real-time event, which will be sent to the target user (as a real-time event). In this way, you can not only create notifications programmatically, but also notify users in real time. More information about real-time events can be found in the separate topic in the documentation. Real-time events"
  },
  "domain-api/common-tasks/handling-renames.html": {
    "href": "domain-api/common-tasks/handling-renames.html",
    "title": "Handling entity type renames | ERP.net Developer Docs",
    "summary": "Handling entity type renames Sometimes, entity types in ERP.net are renamed. In one version, they are called X, and in the next version, they are called Y. Of course, we avoid doing this as much as we can. But sometimes it is unavoidable and has to be done. For example, we have renamed \"General.DocumentPrintImages\" (\"General_DocumentPrintImages\" in the API) to \"Systems.Internal.DocumentPrintImages\". This, naturally, is a problem for applications, which access these entities through the API. To alleviate the problem, we have taken numerous measures: 1. Error message containing the new name When you access an entity, which has been renamed, ERP.net Domain API returns an informative error message, which contains the new name of the entity type For example: The provided entity set name 'General_DocumentPrintImages' is no more supported. The new name of this entity is 'Systems_Internal_DocumentPrintImages'. List of all entity renames can be found at https://testdb.my.erp.net/api/domain/odata/GetRenamedEntityTypes. You have to change your application to use the new name. 2. Support both old and new versions If you want your app to support both the old and the new version of ERP.net Domain API, you can check the version with the following function: /GetVersion The function returns a JSON object with \"version\" property. Example: https://testdb.my.erp.net/api/domain/odata/GetVersion Example response: { \"@odata.context\": \"https://testdb.my.erp.net/api/domain/odata/$metadata#Erp.OpenObject\", \"version\": \"24.1.5.41\" } 3. Automate entity type renames If you want to implement some form of automation for these pesky renames, we support end-point, which returns all renames, along with some related data: /GetRenamedEntityTypes The function returns a JSON array with entity type rename containig OldName, NewName and Version (the version when the new name replaces the old name). Example: https://testdb.my.erp.net/api/domain/odata/GetRenamedEntityTypes Example response: \"@odata.context\": \"https://testdb.my.erp.net/api/domain/odata/$metadata#Collection(Erp.OpenObject)\", \"value\": [ { \"OldName\": \"Systems_Core_DataEntryDefaultValues\", \"NewName\": \"Systems_Internal_DataEntryDefaultValues\", \"Version\": \"24.1.5.35\" }, { \"OldName\": \"Systems_Core_ExtensibleDataObjects\", \"NewName\": \"Systems_Internal_ExtensibleDataObjects\", \"Version\": \"24.1.5.35\" }, ... Finding the Actual Entity Type Name You can use the result of this function to determine the actual entity type name. Here is an example of how this can be achieved: // The variable $renames contains the array of all entity type renames returned by the ~/GetRenamedEntityTypes function. // The variable $entitySet is the provided entity set name, which may have been renamed. // The $renames collection may contain entries where an entity type name has been renamed multiple times. // To find the valid name, we need to iterate through all renames and update the $entitySet accordingly. foreach (var rename in $renames) { if (rename.OldName == $entitySet) { $entitySet = rename.NewName; } } // After the loop, $entitySet will contain the actual entity type name. 4. List of renames To view the list of renamed entity types, go to the following address: Renamed entity types"
  },
  "domain-api/common-tasks/index.html": {
    "href": "domain-api/common-tasks/index.html",
    "title": "Common tasks | ERP.net Developer Docs",
    "summary": "Common tasks This section includes examples of common tasks performed with the Domain API. Change the response language Context parameters Create notification Handling entity type renames Master/Detail Attributes Register Trusted Application Retrieve Products Working with documents CONTAINS Using contains filter function for string attribute: General_Contacts_Parties?$top=5&$filter=contains(PartyCode,'30') Try it Yourself Using contains filter function for multi-language attribute: General_Contacts_Parties?$top=5&$filter=contains(PartyName,'Ivan') Try it Yourself IN OPERATOR Not every attribute in ERP.net supports in filter operator. Generally all navigation properties support in, some enum attributes and occasionaly some other attributes. This information you can find in the Domain Model Reference. Using in for Id attribute: General_Products_Products?$top=10&$filter=Id in (edf2bd2a-7e4d-e111-a06c-00155d00050a, cf728601-1fd5-4853-ab23-01deeee7d038) Try it Yourself Using in for Document State attribute: Crm_Sales_SalesOrders?$top=10&$filter=State in ('FirmPlanned', 'Released')&$select=State Try it Yourself Using in for DocumentType navigation property: Crm_Sales_SalesOrders?$top=10&$select=DocumentType&$filter=DocumentType in ('General_DocumentTypes(de4913f3-962a-4289-a0f3-01bc2c1da21d)', 'General_DocumentTypes(a8b99412-3348-4c12-abdf-1a6a15ab5449)') Try it Yourself Passing inherited entity uri-s (Document.ToParty is of type General_Contacts_Party. The types General_Contacts_Company and General_Contacts_Person are inherited by General_Contacts_Party): Crm_Sales_SalesOrders?$top=10&$filter=ToParty in ('General_Contacts_Persons(2e97f255-f410-4925-8c51-211c8eaa18b8)', 'General_Contacts_Companies(bc60d0bc-2804-4e3c-b355-04184aef5505)') Note: if you pass uri-s to General_Contacts_Party entity the query can be optimized and will be faster than specifying inherited entity uri-s. Try it Yourself CAST The following uri returns the parent document of a specified sales order cast as Crm_Presales_Offer. Note: The type must be specified with the namespace which for all entities is Erp. Crm_Sales_SalesOrders(11217345-3659-43be-a85d-005eaaa3aaac)/Parent/Erp.Crm_Presales_Offer SELECT DEFAULT By default only system attributes are present in the JSON result. The Id attribute, custom properties and calculated attributes are not present. Use the keyword default in $select clause to include all default attributes. To include custom properties and calculated attributes they must be specified explicitly in $select clause. General_Products_Products?$top=1&$select=default,CalculatedAttribute_name NESTED EXPAND Crm_Sales_SalesOrders(59098bcf-f331-478f-91c2-f5520590f534)?$expand=Lines($expand=Product($select=Codes,Name,PartNumber;$expand=Codes($select=Code))) EXPAND $ref - returns the items as links Crm_Sales_SalesOrders(59098bcf-f331-478f-91c2-f5520590f534)?&$expand=Lines/$ref FILTER BY DATE Crm_Sales_SalesOrders?$top=2&$filter=DocumentDate eq 2012-01-01T00:00:00Z FILTER BY Custom Property General_Products_Products?$top=10&$select=CustomProperty_color&$filter=CustomProperty_color eq 'blue' FILTER BY Quantity and Amount Crm_Sales_SalesOrderLines?$top=10&$filter=QuantityValue ge 3 and QuantityValue le 5 and LineAmountValue ge 15.45&$select=Quantity Request COUNT applying filter Crm_Invoicing_Invoices/$count?$filter=DocumentDate eq 2020-03-23T00:00:00Z This request returns the number of invoices for the specified date. See http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361043 Crm_Sales_SalesOrderLines/$count?$filter=SalesOrder/Void eq false and SalesOrder/State ge 'Released' and Product eq 'General_Products_Products(35d5bcb9-0881-4bc8-bfe4-84fb874d4626)' This request returns the number of released sales order lines for a given product. Using $top, $skip and $count Crm_Sales_SalesOrderLines?$filter=SalesOrder/Void eq false and SalesOrder/State ge 'Released'&$top=10&$skip=120&$count=true The $count=true query option specifies that the total number of rows for the specified filter will be included in the result along with the data. UPDATE PRODUCT PATCH ~/General_Products_Products(59098bcf-f331-478f-91c2-f5520590f534) { \"@odata.type\": \"#Erp.General_Products_Product\", \"ABCClass\": \"A\", \"StandardLotSizeBase\": { \"Value\": 3.45, \"Unit\": \"бр\" }, \"MeasurementUnit@odata.bind\": \"https://mycompany.com/api/domain/odata/General_MeasurementUnits(5c5e77ce-60bb-4338-abd0-3a2acb27ff93)\" } FILTER BY DOCUMENT STATE Crm_Sales_SalesOrders?$top=1&$filter=State ge Erp.General_DocumentState'Released' FILTER BY MULTIPLE DOCUMENT TYPES Crm_Sales_SalesOrders?$top=2&$filter=DocumentType eq 'General_DocumentTypes(f8a93d3a-8cf3-4a09-9d45-667d664cb98d)' and DocumentType eq 'General_DocumentTypes(f8a93d3a-8cf3-4a09-9d45-667d664cb98e)' and DocumentType eq 'General_DocumentTypes(f8a93d3a-8cf3-4a09-9d45-667d664cb98f)' FILTER BY MasterDocument with Sales Order URI Crm_Sales_SalesOrders?$top=2&$filter=MasterDocument eq 'Crm_Sales_SalesOrders(70ef9b04-d843-df11-a1e1-0018f3790817)' CHANGE DOCUMENT STATE POST ~/Crm_Sales_SalesOrders(59098bcf-f331-478f-91c2-f5520590f534)/ChangeState { \"newState\" : \"FirmPlanned\", \"userStatus\": {\"@odata.id\": \"General_DocumentTypeUserStatuses(1ee1249e-4ef5-46b4-8409-26b2130d09c7)\"} } MAKE DOCUMENT VOID POST ~/Crm_Sales_SalesOrders(11217345-3659-43be-a85d-005eaaa3aaac)/MakeVoid { \"reason\" : \"test api method\", \"voidType\": \"VoidDocument\" }"
  },
  "domain-api/common-tasks/master-detail-attributes.html": {
    "href": "domain-api/common-tasks/master-detail-attributes.html",
    "title": "Master/Detail Attributes | ERP.net Developer Docs",
    "summary": "Master/Detail Attributes Description There are many entity types in ERP.net which are in master/detail relationship. For example, the Sales Orders entity type is master to the Sales Order Lines entity type. Following the relationship between their respective entity types, some attributes (or references) might be in master/detail relationship. For example, the SalesOrder.Store and SalesOrderLine.LineStore are in master/detail relationship. For in-depth information about master/detail attribute relationship, refer to the technical documentation. Very simplified version of the story from dev perspective: The detail attribute is the important one. It is considered by the business logic. The master attribute is used mainly for at-a-glance user information. The master attribute contains value only when the value (of the detail attribute) for all lines is the same. Otherwise, it is NULL. The detail attribute generally should be a required (not-NULL) attribute. However, there are exceptions, so check the model docs to be sure. Best practices When creating data Set the value of the detail attribute for each line, according to your business requirements. For the master attribute: If ALL detail lines have the same value for the detail attribute, set that value. Otherwise (if there are different values) - set NULL. When consuming data Use the detail attribute value to properly implement your business logic. If you are referring to the value of the master attribute, be sure to properly handle the possible NULL values. Examples All lines have the same value In this example, the master attribute has a value, because it is the same for all lines. Entity Attribute Value Sales Order 00596 Store Main Sales Order 00596 - Line 01 Line Store Main Sales Order 00596 - Line 02 Line Store Main Sales Order 00596 - Line 03 Line Store Main Different values on the lines In this example, the master attribute is NULL, because there are lines with different values. Entity Attribute Value Sales Order 00597 Store NULL Sales Order 00597 - Line 01 Line Store Main Sales Order 00597 - Line 02 Line Store Remote 01 Sales Order 00597 - Line 03 Line Store Main"
  },
  "domain-api/common-tasks/register-trusted-app.html": {
    "href": "domain-api/common-tasks/register-trusted-app.html",
    "title": "Register Trusted Application | ERP.net Developer Docs",
    "summary": "Register Trusted Application In this topic, you register an app in an ERP instance so the ERP.net Identity can provide authentication and authorization services for your application and its users. Each application that uses ERP.net APIs needs to be registered. Whether it's a client application like a web or mobile app, or it's a web API that backs a client app, registering it establishes a trust relationship between your application and the ERP instance. Note In future versions of ERP.net platform this way to register a trusted application will no longer be available, because of the sec scope (Only ERP.net Identity itself will be granted with the sec scope) The ERP.net instance will provide a browser accessible endpoint where the application will provide its client_id, client_secret_hash, scopes and other required parameters to register the application. This endpoint will redirect the user to the login screen and if the user is a database administrator he or she will be able to approve the application registration. Register an application Registering your application establishes a trust relationship between your app and the ERP.net database instance. That means that your database trusts the application. We'll show how to register an application manually, using the Domain API Query Tool. Follow these steps to create the app registration: Sign in to your ERP instance and open the Domain API Query Tool. Every ERP.net database has it's own query tool on the Domain API site. The Domain Api site is usually hosted on address https://{COMPANY}.my.erp.net/api and the query tool is on https://{COMPANY}.my.erp.net/api/domain/query In this example we'll use the DEMODB ERP.net instance query tool: https://demodb.my.erp.net/api/domain/query ⚠️ You need to be a database administrator in order to be able to register a new trusted application. If the application is confidential, we need to prepare an application secret. Use this endpoint to get the application secret hash (Replace mysecret with your secret): https://demodb.my.erp.net/sys/tools/sha256?secret=mysecret In the query tool we'll create a new record for System.Security.TrustedApplications entity. Register interactive confidential application Query: Systems_Security_TrustedApplications Type: POST Body: { \"ApplicationUri\": \"MYDEMOCLIENT\", \"Name\": \"MY DEMO CLIENT\", \"ClientType\": \"Confidential\", \"ApplicationSecretHash\": \"T/AGymuI51LwjLeIFxRQXOs9IHnupDKs/ajhWODR2C4=\", \"ImpersonateAsCommunityUserAllowed\": true, \"ImpersonateAsInternalUserAllowed\": true, \"ImpersonateLoginUrl\": \"http://localhost:5080/myapp/signin-oidc\", \"ImpersonateLogoutUrl\": \"http://localhost:5080/myapp/\", \"SystemUserAllowed\": false } ApplicationUri is the unique name that identifies the application. This is the client_id in the OAuth terminology. Name is the display name of the application. ClientType - Confidential or Public. ApplicationSecretHash a hash of the application secret - previously created using https://demodb.my.erp.net/sys/tools/sha256?secret=mysecret tool. ImpersonateAsCommunityUserAllowed must be true if your application will work with community users. Community users are users that do not have access to system resources. They are usually customers of the company that owns the ERP.net database instance. ImpersonateAsInternalUserAllowed must be true if internal users will use the application. ImpersonateLoginUrl is a comma separated list of allowed URLs that are used from the application to receive the authorization code. When the user loads the application in the browser, if sign in is required, the browser is redirected to ERP.net Identity login page. After successful login the browser is redirected to the provided return_url that must be one of the URLs specified in ImpersonateLoginUrl providing the authorization_code through code url parameter. This code is used by the application to request an access_code that is used to gain access to ERP.net server resources. ImpersonateLogoutUrl is a comma separated list of allowed URLs that are used after the user is logged out from the name Identity and \"Return to app\" button is clicked. SystemUserAllowed specifies if the application can act as a service application that is impersonated as specific user. Register interactive public application Query: Systems_Security_TrustedApplications Type: POST Body: { \"ApplicationUri\": \"MYDEMOCLIENT\", \"Name\": \"MY DEMO CLIENT\", \"ClientType\": \"Public\", \"ImpersonateAsCommunityUserAllowed\": true, \"ImpersonateAsInternalUserAllowed\": true, \"ImpersonateLoginUrl\": \"http://localhost:5080/myapp/signin-oidc\", \"ImpersonateLogoutUrl\": \"http://localhost:5080/myapp/\", \"SystemUserAllowed\": false } Register service application Query: Systems_Security_TrustedApplications Type: POST Body: { \"ApplicationUri\": \"MYSERVICEDEMOCLIENT\", \"Name\": \"Service Demo Client\", \"ApplicationSecretHash\": \"T/AGymuI51LwjLeIFxRQXOs9IHnupDKs/ajhWODR2C4=\", \"ClientType\": \"Confidential\", \"SystemUserAllowed\": true, \"SystemUser\": { \"@odata.id\": \"Systems_Security_Users(cc314327-3d04-477f-ac53-cde19d8350e9)\" } } SystemUser is the user for the service application."
  },
  "domain-api/common-tasks/retrieve-products.html": {
    "href": "domain-api/common-tasks/retrieve-products.html",
    "title": "Retrieve Products | ERP.net Developer Docs",
    "summary": "Retrieve Products The following query: Retrieves 10 products, without any order Filters by: Active = true Selects the following attributes: Id - the unique Id of the product. Part Number - the product code. Name - the multi-language product name. ProductGroup - reference to the Product Group containing the product. StandardPricePerLot - Amount object, containing the standard price. Description - textual description of the product. This description is clear text and does not support any formatting. There is also Description_Html attribute, which can be used to contain description with HTML formatting. MeasurementUnit - reference to measurement units. This is the default sales measurement unit of the product. https://demodb.my.erp.net/api/domain/odata/General_Products_Products?$top=10&$filter=Active%20eq%20true&$select=CatalogDescriptionHtml,Description,Id,MeasurementUnit,Name,PartNumber,ProductGroup,StandardPricePerLot You can edit the query in the Query Builder: https://demodb.my.erp.net/api/domain/querybuilder#General_Products_Products?$top=10&$filter=Active%20eq%20true&$select=CatalogDescriptionHtml,Description,Id,MeasurementUnit,Name,PartNumber,ProductGroup,StandardPricePerLot"
  },
  "domain-api/common-tasks/working-with-documents.html": {
    "href": "domain-api/common-tasks/working-with-documents.html",
    "title": "Working with documents | ERP.net Developer Docs",
    "summary": "Working with documents See Documents on technical documentation. Retrieving and updating documents is the same as any other entity in the domain. However there are some specific rules that apply only to documents. For example documents on state Released or above can not be modified directly. They must be modified with adjustment documents. Another important attribute of the documents that can not be modified with simple PATCH request is State. The examples below show some tasks related to documents. Create document Document can be created only by specifying the required properties. Other properties will be filled by it's constant default value or it's LateDefault expression. If Front-End model is used in API Transaction dependent property values are recalculated upon property change. For example in SalesOrderLine line.ProductDescription is set to line.Product.Name when line.Product changes. In the example bellow a new SalesOrder is created with one SalesOrderLine. Note that measurement units and currencies are specified before passing Quantity or Amount values. This is required because the quantity or amount contains the code of the measurement unit or currency. POST ~/Crm_Sales_SalesOrders { \"DocumentType\": { \"@odata.id\": \"General_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)\" }, \"EnterpriseCompany\": { \"@odata.id\": \"General_EnterpriseCompanies(b0e80577-fbbe-4c9b-811e-20b6c6dd465f)\" }, \"Customer\": { \"@odata.id\": \"Crm_Customers(15f2640f-f374-4017-ae2d-d2a41535f054)\" }, \"DocumentCurrency\": { \"@odata.id\": \"General_Currencies(3187833a-d3c1-4804-bfc0-e17e6aee3069)\" }, \"Lines\": [ { \"Product\": { \"@odata.id\": \"General_Products_Products(81d38b50-fd06-e611-8292-b31071e2ee7f)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 1, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 20, \"Currency\": \"BGN\" } } ] } Change document state HTTP C# POST ~/Crm_Sales_SalesOrders(59098bcf-f331-478f-91c2-f5520590f534)/ChangeState { \"newState\" : \"FirmPlanned\", \"userStatus\": {\"@odata.id\": \"General_DocumentTypeUserStatuses(1ee1249e-4ef5-46b4-8409-26b2130d09c7)\"} } Make document void HTTP C# POST ~/Crm_Sales_SalesOrders(11217345-3659-43be-a85d-005eaaa3aaac)/MakeVoid { \"reason\" : \"test api method\", \"voidType\": \"VoidDocument\" } Recalculate document This method is used to recalculate some document details such as Document Amounts (like VAT), Bonus Programs etc. It make sense only in the context of Front-End transaction because the recalculated changes remain only in memory. They must be commited to the database with a separate call to EndTransaction{commit=true}. HTTP C# POST ~/Crm_Sales_SalesOrders(11217345-3659-43be-a85d-005eaaa3aaac)/Recalculate Create adjustment documents Released documents can be modified only with adjustment documents. The API provides a convenient method to create adjustment documents: CreateAdjustmentDocuments. The method requires TransactionId in the request header. The method creates adjustment documents for modified released documents. The adjustment documents are created in separate transaction and their state is changed to 'Adjustment'. The method does not commit or rollback the current front-end transaction. HTTP C# // Begin a front-end transaction POST ~/BeginTransaction { \"model\": \"frontend\" } // The returned transaction id must be set in the request header for each subsequent query. The header name is TransactionId. // Update some sales order lines. PATCH ~/Crm_Sales_SalesOrderLines(34217345-3659-43be-a85d-005eaaa3aaac) TransactionId: xxxx { \"Quantity\": {\"Value\": 5.0, \"Unit\": \"PCE\"} } // Update another line. PATCH ~/Crm_Sales_SalesOrderLines(65217345-3659-43be-a85d-005eaaa3aaac) TransactionId: xxxx { \"Quantity\": {\"Value\": 15.0, \"Unit\": \"PCE\"} } // Call CreateAdjustmentDocuments to create the adjustment documents and apply the changes to the original document. // Adjustment documents will be created for all modified released documents in the current transaction. POST ~/CreateAdjustmentDocuments TransactionId: xxxx // End the transaction without committing because updating released document directly is not allowed. POST ~/EndTransaction TransactionId: xxxx { \"commit\": false } Create multiple lines to an existing document A possible scenario is when you have a document created, but later you want to add its lines. PATCH ~/Crm_Sales_SalesOrders(283e4c71-2d77-4083-81b6-4c7f17668d7e) { \"Lines\": [ { \"LineNo\": 10, \"Product\": { \"@odata.id\": \"General_Products_Products(81d38b50-fd06-e611-8292-b31071e2ee7f)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 1, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 20, \"Currency\": \"BGN\" } }, { \"LineNo\": 20, \"Product\": { \"@odata.id\": \"General_Products_Products(08fc0b95-01d8-4876-9074-67898c0bd98b)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 5, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 10, \"Currency\": \"BGN\" } }, { \"LineNo\": 30, \"Product\": { \"@odata.id\": \"General_Products_Products(396f958d-1952-4c6f-ac66-9211962720d4)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 67, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 1.23, \"Currency\": \"BGN\" } } ] } Create a sales order with automatic calculation of line prices and amounts The term \"automatic\" actually means the execution of the front-end business rules, related to the sales order and its sales order lines. Therefore, this is only possible in a front-end transaction. POST ~/BeginTransaction { \"model\": \"frontend\" } After, just create the sales order and its lines at once: POST ~/Crm_Sales_SalesOrders TransactionId: xxxx { \"DocumentNo\": \"12345\", \"DocumentType\": { \"@odata.id\": \"General_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)\" }, \"EnterpriseCompany\": { \"@odata.id\": \"General_EnterpriseCompanies(b11b2f31-71b5-4443-a4b7-b5e9cd664a64)\" }, \"Customer\": { \"@odata.id\": \"Crm_Customers(eebf02a5-052e-4a8d-9a24-270546d73942)\" }, \"DocumentCurrency\": { \"@odata.id\": \"General_Currencies(3187833a-d3c1-4804-bfc0-e17e6aee3069)\" }, \"Lines\": [ { \"LineNo\": 10, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 2, \"Unit\": \"PCS\" }, \"Product\": { \"@odata.id\": \"General_Products_Products(bc5a90ed-eca3-4e70-9987-395da25f6487)\" } } ] } Finally, commit the transaction: POST ~/EndTransaction TransactionId: xxxx { \"commit\": true }"
  },
  "domain-api/complex-types/amount.html": {
    "href": "domain-api/complex-types/amount.html",
    "title": "Amount (Complex value) | ERP.net Developer Docs",
    "summary": "Amount (Complex value) The ERP domain model declares a special type for amount (currency) properties. The amount is represented by value and currency. Properties Name Type Description Currency String The currency of the amount represented by it's sign. Value Decimal The value of the amount. Domain API Example: { \"LineAmount\": { \"Value\": \"3.55\", \"Currency\": \"USD\" } } Note Because Amount is odata complex object it can not participate in uri $filter query parameter. To filter by Amount or Quantity properties you can use the following: ~/Logistics_Inventory_StoreTransactionLines?$filter=QuantityValue ge 5.555 ~/Crm_Sales_SalesOrderLines?$filter=LineAmountValue ge 5.555"
  },
  "domain-api/complex-types/custom-property-value.html": {
    "href": "domain-api/complex-types/custom-property-value.html",
    "title": "Custom Property Value | ERP.net Developer Docs",
    "summary": "Custom Property Value Custom Properties (also called Custom Attributes in the domain terminology) are user-defined attributes, which can supplement the predefined system attributes. Definition of а Custom Property For reference information about the definition of the custom properties, see @General.CustomProperties. Here are some highlights for the definition record: EntityName contains the name of the entity, for which the property is defined. You can find the entity name for each entity in the model documentation. For example, the entity name for @Crm.Customers is \"Crm_Customers\" (check it out in the link - see the tag line under the entity name). LimitToAllowedValues - this defines whether the property is free text or is limited to a list of allowed values. AllowedValuesEntityName - specifies that the allowed values are retrieved from the specified entity. When this is NULL, the allowed values are retrieved from @General.CustomPropertyAllowedValues . Data type and values In the Domain API, the custom properties are properties of type General_CustomPropertyValue. The API name of the custom property starts with 'CustomProperty_' followed by the user defined property code. Note Properties with Code, which does not conform to the specification for identifier name, might not be accessible through the API. See Identifier Name Specification. Each database contains different custom properties and that is why each database have different EDM model ($metadata). Reset If a user creates new custom property in the database, this custom property is not exposed in the Domain API in real time. This is because the Domain API caches all repositories and their attributes until next restart. To refresh the cached attributes you must call the ~/domain/reset endpoint. Example: https://demodb.my.erp.net/api/domain/reset Note Executing /reset requires authenticated user connection. Composition of the CustomPropertyValue type Name Type Description Value String The short value. This is the actual value of the custom property. Description MultilanguageString This is long, descriptive, multi-language value of the custom property. Can be null. ValueId Guid The Id of the entry represented by the property value. It's the id of the allowed value. Can be null. Example \"CustomProperty_color\": { \"Value\": \"аpple\", \"ValueId\": \"5263a2d3-88b0-41db-adae-31c76135719e\", \"Description\": { \"EN\": \"The Apple.\", \"DE\": \"Die Apfel.\" } } Note To filter by Custom Property you must use only the short value (only eq is supported): General_Products_Products?$top=10&$select=CustomProperty_color&$filter=CustomProperty_color eq 'apple'"
  },
  "domain-api/complex-types/index.html": {
    "href": "domain-api/complex-types/index.html",
    "title": "Complex types | ERP.net Developer Docs",
    "summary": "Complex types Complex types are used in OData to encapsulate richer data types for properties. Complex types are a composition of properties. ERP.net utilizes the following complex types: Amount Quantity CustomPropertyValue MultilanguageString"
  },
  "domain-api/complex-types/multi-language-string.html": {
    "href": "domain-api/complex-types/multi-language-string.html",
    "title": "Multilanguage string (Complex value) | ERP.net Developer Docs",
    "summary": "Multilanguage string (Complex value) Some text properties support value in more than one language. This properties are of multi-language string type. The multi-language string can store many language strings, indexing them by language key. The language key is a CultureInfo two letter ISO language name, like \"en\", \"de\", etc. For example, the name of a product is a data attribute, which can simultaneously contain translation of the product name in many languages. When you retrieve the value of this attribute with the Domain API, you get values similar to: { \"en\": \"Apple\", \"de\": \"Apfel\" } All translations are a single value All translations in a multi-language string are treated as a single value. You cannot change only one language pair - all pairs are updated simultaneously. The client applications are responsible for managing all language pairs. Filtering The equality comparison for multi-language string is ambiguous. The APIs generally do not support direct equality comparisons. Note Domain API supports only the filter function contains. For example, in Domain API, the following is supported: ~/General_Products_Products?$filter=contains(Name,'ppl') However, this is not valid: ~/General_Products_Products?$filter=Name eq 'Apple'"
  },
  "domain-api/complex-types/quantity.html": {
    "href": "domain-api/complex-types/quantity.html",
    "title": "Quantity (Complex value) | ERP.net Developer Docs",
    "summary": "Quantity (Complex value) The ERP domain model declares a special type for quantity properties. The quantity is represented by value and measurement unit. Properties Name Type Description Unit String TThe measurement unit of the quantity represented by it's code. Value Decimal The value of the quantity. Domain API Example: { \"Quantity\": { \"Value\": \"5.555\", \"Unit\": \"PCS\" } } Note Because Quantity is odata complex object it can not participate in uri $filter query parameter. To filter by Amount or Quantity properties you can use the following: ~/Logistics_Inventory_StoreTransactionLines?$filter=QuantityValue ge 5.555 ~/Crm_Sales_SalesOrderLines?$filter=LineAmountValue ge 5.555"
  },
  "domain-api/data-manipulation/create.html": {
    "href": "domain-api/data-manipulation/create.html",
    "title": "| ERP.net Developer Docs",
    "summary": "Create Operations Creating an Entity To create a new entity in ERP.net, you use the POST method of the OData service. The request body contains the entity data in JSON format. Example: Creating a new Crm_Sales_SalesOrder: POST https://testdb.my.erp.net/api/domain/odata/Crm_Sales_SalesOrders Content-Type: application/json { \"DocumentType\": { \"@odata.id\": \"Systems_Documents_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)\" }, \"EnterpriseCompany\": {\"@odata.id\": \"General_EnterpriseCompanies(2115c294-33e9-41bd-bc0d-0cd0b7ee1735)\" }, \"Customer\": { \"@odata.id\": \"Crm_Sales_Customers(c8a65f60-26d0-4c3a-81c9-f367dd811908)\" }, \"DocumentNotes\": \"New sales order for testing\" } Required Fields: DocumentType: Type of the document. EnterpriseCompany: The company that owns the order. Customer: The customer for this sales order. Other fields are optional or have defaults. Always validate your data according to the entity model. For full details on the Crm_Sales_SalesOrder entity and all available fields, see the documentation of the used entity. For example Sales Orders. Create a sales order along with the lines. POST https://testdb.my.erp.net/api/domain/odata/Crm_Sales_SalesOrders { \"DocumentType\": { \"@odata.id\": \"General_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)\" }, \"EnterpriseCompany\": { \"@odata.id\": \"General_EnterpriseCompanies(b0e80577-fbbe-4c9b-811e-20b6c6dd465f)\" }, \"Customer\": { \"@odata.id\": \"Crm_Customers(15f2640f-f374-4017-ae2d-d2a41535f054)\" }, \"DocumentCurrency\": { \"@odata.id\": \"General_Currencies(3187833a-d3c1-4804-bfc0-e17e6aee3069)\" }, \"Lines\": [ { \"Product\": { \"@odata.id\": \"General_Products_Products(81d38b50-fd06-e611-8292-b31071e2ee7f)\" }, \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" }, \"Quantity\": { \"Value\": 1, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 20, \"Currency\": \"BGN\" } } ] }"
  },
  "domain-api/data-manipulation/data-validation.html": {
    "href": "domain-api/data-manipulation/data-validation.html",
    "title": "Data Validation and Business Rules | ERP.net Developer Docs",
    "summary": "Data Validation and Business Rules ERP.net enforces data validation through a combination of System Business Rules and User Business Rules: System Business Rules: Predefined rules for each entity (e.g., Crm.Sales.SalesOrders) that automatically enforce business logic on the back-end. Examples include assigning a sales person, validating fiscal numbers, or restricting line directions. These rules ensure data consistency and compliance without manual intervention. User Business Rules: Custom rules defined by developers or administrators to implement organization-specific validations. These can be applied on the back-end for security and integrity, and optionally on the front-end for immediate feedback. Together, system and user business rules ensure that all data entered or modified in ERP.net adheres to required business logic and organizational policies. Front-End vs. Back-End Models ERP.net uses two models to handle entity data and business logic — the front-end model and the back-end model. While both represent the same entities, they differ in the business rules and data validations that are executed. Front-End Model: Designed for immediate feedback in client applications. It contains business rules that are triggered on attribute change events — for example, when a user edits a field in a form, dependent fields may be recalculated or validated right away. This provides a dynamic and interactive user experience. Back-End Model: Used when the data is committed to the server (e.g., on save, post, or document state change). It contains rules and validations that enforce business integrity, such as required field checks, calculated defaults, and document-level logic triggered by workflow events like state transitions. In short, the front-end model reacts to user edits, while the back-end model enforces consistency and performs final validations before persisting the data. For more details, see Transactions in Domain API."
  },
  "domain-api/data-manipulation/delete.html": {
    "href": "domain-api/data-manipulation/delete.html",
    "title": "Delete Operations | ERP.net Developer Docs",
    "summary": "Delete Operations ERP.net supports deleting entities using the DELETE HTTP method. The request removes the specified entity from the system. Key Points: Use DELETE with the entity’s OData ID. Business rules on the back-end may enforce restrictions or cascade actions during deletion. Example: Deleting a sales order: DELETE https://testdb.my.erp.net/api/domain/odata/Crm_Sales_SalesOrders(f3fe442a-d5fe-49a9-8bda-00c895d630bb) Only the entity specified in the request is removed; related entities may be affected according to system rules and cascades."
  },
  "domain-api/data-manipulation/erpnet-action.html": {
    "href": "domain-api/data-manipulation/erpnet-action.html",
    "title": "@erpnet.action instance annotation | ERP.net Developer Docs",
    "summary": "@erpnet.action instance annotation In OData instance annotations can be used to define additional information associated with a particular result, entity, property, or error. The @erpnet.action annotation can be provided in the body of update request (POST, PATCH) or in the Import action. Example usage POST General_Products_Products { \"@erpnet.action\": \"merge\", \"PartNumber\": \"DAT003\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": {\"Name\": \"Pieces\" } }, \"MeasurementUnit\": { \"Code\": \"pcs\" }, \"Name\": {\"EN\": \"Domain API Test 002\"}, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": {\"EN\": \"Domain API Tests\"} } } The purpose of this annotation is to provide a better way to update, create, merge or delete data. The value of the @erpnet.action annotation determines the type of operation that will be performed using the provided JSON data. Allowed values Action Description create Always creates a new object. update Updates an existing object. This is the default for the top-level JSON object in a PATCH request. If @erpnet.action: update is explicitly specified for a nested (referenced) object, the properties of the referenced object are modified. delete Deletes an existing object. Can be used in Import. find Searches for a matching object and uses the first found. If no matching object is found, an error is thrown. If the JSON object contains data properties, they are ignored — the found object remains unchanged. findOrNull Searches for a matching object and uses the first found. If none is found, returns null. If the JSON object contains data properties, they are ignored — the found object remains unchanged. findOrCreate Searches for a matching object and uses the first found. If none is found, a new object is created and populated with the provided data properties. findSingle Searches for a matching object and uses the first found. If no matching object is found or more than one matching object is found, an error is thrown. findSingleOrNull Searches for a matching object and uses the first found. If no matching object is found or more than one matching object is found, returns null. merge Searches for a matching object and uses the first found. If none is found, a new object is created and populated with the provided data properties. If an existing object is found, it is updated with the provided data properties. Default values If the @erpnet.action annotation is not present in the object, the following defaults are applied: For top-level objects: POST → @erpnet.action: create PATCH → @erpnet.action: update For nested objects: If only properties defining the search criteria are provided (either @erpnet.findBy or data properties usable in a find action), → @erpnet.action: find Otherwise → @erpnet.action: merge @erpnet.findBy Annotation The @erpnet.findBy annotation explicitly defines the search criteria used when an existing object should be located. It is applicable to the following @erpnet.action values: find findOrNull findOrCreate findSingle findSingleOrNull merge Structure The value of the annotation is an object with one or more of the following string properties: { \"ExternalId\": \"...\", \"ExternalSystem\": \"...\", \"Id\": \"...\", \"Code\": \"...\", \"Name\": \"...\", \"DisplayText\": \"...\" } Property Details ExternalId — Used to find an existing object by its specific external identifier. ExternalSystem — Optional. Can be provided alongside ExternalId to further qualify the search. Id — Used to find an object by its unique identifier (Guid). Code — Used to find an object by its code. This applies only to entities that provide a CodeDataMember. The CodeDataMember for a specific entity can be found in its documentation. Name — Used to find an object by its name. This applies only to entities that provide a NameDataMember. The NameDataMember for a specific entity can be found in its documentation. The search operation performs a case-insensitive contains match. DisplayText — Searches by the entity’s display text using a contains operation. This is equivalent to using the $search parameter in OData queries. Find Criteria Evaluation The find operation uses only the first available criterion from the @erpnet.findBy annotation in the following priority order: ExternalId (+ optional ExternalSystem) Id Code Name DisplayText If multiple properties are specified, only the first one (in the order they appear) is used. For example: \"@erpnet.findBy\": { \"ExternalId\": \"123\", \"ExternalSystem\": \"SomeSystem\", \"Code\": \"345\" } In this case, the search will be performed only by ExternalId and ExternalSystem, while Code will be ignored. Default behavior If the @erpnet.findBy annotation is omitted, the search criteria are automatically derived from the provided object’s properties. For example { \"Customer\": { \"Number\": \"Г89163\" } } is equivalent to { \"Customer\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": {\"Code\": \"Г89163\"} } } because \"Number\" is the CodeDataMember for customers we perform search by Code. This is a nested object and only CodeDataMember property is provided so the @erpnet.action is determined as find. Examples Note: You can try all examples directly in the ERP.net Query Tool. In the tool, you can choose the HTTP method and execute not only GET requests, but also POST, PATCH, and DELETE. This allows you to test queries, create, update, or delete data directly against the public test database. Import products Below are several examples of importing products. In this first example, we create a product while providing the measurement unit and category by their IDs. The ProductGroup uses implicit merge, meaning it searches by code. Note: If a product group is found, its code and name will be updated with the provided values. If there are no changes, the object remains Unchanged and is not written to the database. However, if the group’s name was manually edited after the initial import (for example, a the group name is translated to some other language), this change will be lost due to the MERGE, which will set the entire multi-language value for Name attribute. POST General_Products_Products { \"PartNumber\": \"DAT001\", \"Name\": {\"EN\": \"Domain API Test 001\"}, \"BaseMeasurementCategory@odata.bind\": \"General_Products_MeasurementCategories(045d1e60-2114-4ca7-b636-0666dd0d2ec8)\", \"MeasurementUnit@odata.bind\": \"General_Products_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\", \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": {\"EN\": \"Domain API Tests\"} } } In this example, we explicitly set @erpnet.action: merge. This means the system will first look for a product by its code before creating a new one. POST General_Products_Products { \"@erpnet.action\": \"merge\", \"PartNumber\": \"DAT002\", \"Name\": {\"EN\": \"Domain API Test 002\"}, \"BaseMeasurementCategory@odata.bind\": \"General_Products_MeasurementCategories(045d1e60-2114-4ca7-b636-0666dd0d2ec8)\", \"MeasurementUnit@odata.bind\": \"General_Products_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\", \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": {\"EN\": \"Domain API Tests\"} } } Same as above, but without using IDs for the measurement unit and category — only the name and code are used. The BaseMeasurementCategory is searched by Name - this is General_MeasurementCategories?$filter=contains(Name,\"Pieces\"). POST General_Products_Products { \"@erpnet.action\": \"merge\", \"PartNumber\": \"DAT003\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": {\"Name\": \"Pieces\"} }, \"MeasurementUnit\": { \"@erpnet.action\": \"find\", \"Code\": \"pcs\" }, \"Name\": {\"EN\": \"Domain API Test 003\"}, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": {\"EN\": \"Domain API Tests\"} } } Same as the previous example, but the measurement unit omits the @erpnet.action annotation. The action again is find because we only provide the code attribute. POST General_Products_Products { \"@erpnet.action\": \"merge\", \"PartNumber\": \"DAT003\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": {\"Name\": \"Pieces\"} }, \"MeasurementUnit\": { \"Code\": \"pcs\" }, \"Name\": {\"EN\": \"Domain API Test 003\"}, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": {\"EN\": \"Domain API Tests\"} } } This example searches by ExternalId. POST General_Products_Products { \"@erpnet.action\": \"merge\", \"ExternalId\": \"EXT004\", \"PartNumber\": \"DAT004\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": {\"Name\": \"Pieces\"} }, \"MeasurementUnit\": { \"Code\": \"pcs\" }, \"Name\": {\"EN\": \"Domain API Test 004\"}, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": {\"EN\": \"Domain API Tests\"} } } Merging Customer In the following example we are editing a sales order and want to MERGE the customer. The merge action first attempts to find an existing object by the provided attributes. The provided customer data is interpretted as \"@erpnet.action\": \"merge\", \"@erpnet.findBy\": { \"Code\": \"CS0099\" } First, the system will search for a customer with Number = \"CS0099\". If none is found, it will create a new customer and fill it's Number and Party. The Party will also attempt a merge. The provided data can't be transformed to @erpnet.findBy because we provide Company.Name, which is not a NameDataMember for the PartiesRepository, so no lookup by name will be performed. The NameDataMember for parties is \"PartyName\". If there is no findBy arguments a new Party will be created. Erp.General_Contacts_Party is abstract class so we can't create a party directly. We should specify the exact inheritor type. This is done with \"@odata.type\": \"Erp.General_Contacts_Company\". Now the system knows what object to create. As a result, a new company will be created. It is safe to pass the attributes defined in \"Erp.General_Contacts_Company\" type, so the system can set their values in the created company. PATCH Crm_Sales_SalesOrders(fd8e5bd8-5fa4-4eae-a763-aad226b9101d) { \"Customer\": { \"Number\": \"CS0099\", \"Party\": { \"@odata.type\": \"Erp.General_Contacts_Company\", \"Name\": { \"EN\": \"New Company\"}, \"RegistrationType\": {\"EN\": \"Ltd\" } } } } Import Sales Order In the following example, we create a sales order without using any IDs. The system automatically determines the @erpnet.action and @erpnet.findBy criteria based on the provided properties. POST Crm_Sales_SalesOrders { \"DocumentType\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"Code\": \"CRM_SALES_ORDER\" }, \"EnterpriseCompany\": { // defaults to: @erpnet.action = find \"@erpnet.findBy\": { \"Code\": \"546346373\" } }, \"EnterpriseCompanyLocation\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"PartyCode\": \"00193\" }, \"Customer\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"Number\": \"Г89163\" }, \"DocumentCurrency\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"CurrencySign\": \"BGN\" }, \"Lines\": [ { \"Product\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"PartNumber\": \"DAT001\" }, \"QuantityUnit\": { // defaults to: @erpnet.action = find, @erpnet.findBy = Code \"Code\": \"pcs\" }, \"Quantity\": { \"Value\": 1, \"Unit\": \"pcs\" }, \"UnitPrice\": { \"Value\": 20, \"Currency\": \"BGN\" } } ] }"
  },
  "domain-api/data-manipulation/error-handling.html": {
    "href": "domain-api/data-manipulation/error-handling.html",
    "title": "Error Handling | ERP.net Developer Docs",
    "summary": "Error Handling When an error occurs during a Domain API operation, the service returns an HTTP status code 500 (Internal Server Error) and a JSON body containing detailed error information. The JSON response provides: A user-readable message (message) A technical error code (code) The error type (type) Additional diagnostic details (info) Example: POST https://testdb.my.erp.net/api/domain/odata/General_Products_Products { \"PartNumber\": \"DAT100\", \"Name\": { \"EN\": \"Duplicate Test\" }, \"MeasurementUnit@odata.bind\": \"General_Products_MeasurementUnits(7dbe6d6a-22ef-4c2f-a798-054bc2d13c8b)\" } Response: { \"message\": \"Prohibited duplication in table 'dbo.Gen_Products_Table'.\\n\\nThe set of values for the following fields could not be saved more than once...\", \"code\": 2129, \"type\": \"Aloe.EnterpriseOne.Server.ServerAPI.Exceptions.EnterpriseOneServerException\", \"info\": \"System.Exception: Prohibited duplication in table 'dbo.Gen_Products_Table'...\", \"messageFormat\": \"Prohibited duplication in table '{0}'.\\n\\nThe set of values for the following fields could not be saved more than once.\\n\\nFields: ({1})\\n\\nDuplicated value: ({2})\\n\\nIndex: {3}\\n\\nPlease remove the duplicate record or change the value of any of the fields listed.\", \"parameters\": [ \"dbo.Gen_Products_Table\", \"IX_Inv_Materials_Table_Number\", \"DAT100\", \"IX_Inv_Materials_Table_Number\" ] } Notes The message field usually contains localized user-readable text. The info field can include a stack trace for debugging in non-production environments. The parameters and messageFormat fields are useful for programmatic handling or translation of structured errors."
  },
  "domain-api/data-manipulation/import.html": {
    "href": "domain-api/data-manipulation/import.html",
    "title": "Import | ERP.net Developer Docs",
    "summary": "Import ERP.net Domain API defines an Import endpoint which can be used to import multiple entities at once. Import is unbound (not bound to any entity) action (actions are called with HTTP POST method) that inserts, updates or deletes multiple objects. Specification with example: { \"transaction\": \"all-objects\" | \"per-object\" (default), \"model\": \"frontend\" (default) | \"backend\", \"objects\": [ { \"@odata.type\": \"Crm_Sales_Customers\", \"@erpnet.action\": \"merge\" (default) | \"create\" | \"update\" | \"delete\" ... }, ... ] } Parameters model: - allowed values are common or frontend. This parameter indicates the data model used for the import. Front-end data model uses front-end business rules. For example front-end logic is when Quantity of a SalesOrderLine is changed the corresponding QuantityBase is calculated by a dedicated front-end business rule. Common model defines minimal business logic applicable in all cases - front-end or back-end. The default is frontend. transaction: - all-objects or per-object. This parameter defines when the changes will be commited to the database. If all-objects is specified all changes are committed at once at the end of the import. If per-object is specified every object is saved when it is ready. The default is per-object. objects - an array of entity objects for import. Properties of the objects element \"@odata.type\" - Each object must specify valid entity type. The entity type is the singular form of the entity set and can be found in the documentation for each entity. The @odata.type always starts with the default namespace Erp. - Example Erp.General_Products_Product \"@erpnet.action\" - This is an optional annotation for the desired import action. For top-level objects the default action is create. For more information see this article. \"@erpnet.findBy\" - This is an optional annotation that specifies the search criteria for the find action. For more information see this article. Any data property of the imported object. Return value Specification with example { \"result\": \"success\" | \"fail\", \"objects\": [ { \"@erpnet.result\": \"success\" | \"fail\", \"@odata.id\": \"Crm_Sales_Customers(<guid>)\", \"@erpnet.message\": \"<error-message>\" \"@erpnet.state\": \"Added\" | \"Modified\" | \"Deleted\" | \"Unchanged\" }, ... ] } Properties of the result value \"@erpnet.result\" - success or fail. The result is success only if all objects are imported successfully. objects - an array of object results - one object for each imported object. Properies of the each returned object \"@erpnet.result\" - success or fail. \"@odata.id\" - the ODATA Id of the imported object. If result is fail this is not available. \"@erpnet.message\" - the error message. \"@erpnet.state\" - the status of the imported object. One of \"Added\" | \"Modified\" | \"Deleted\" | \"Unchanged\". Indicates the operation performed for the object. Only the \"@odata.id\" is included in the result - no other properties. Examples Import Products The following example performs merge action for General_Products_Products. If existing product is found by the provided ExternalId it's PartNumber, BaseMeasurementCategory, MeasurementUnit, Name and ProductGroup are updated. The action for the referenced objects is find because the included properties are only these that can be used in find criteria. BaseMeasurementCategory is searched by Name (providing @erpnet.findBy), MeasurementUnit and ProductGroup are searched by Code. POST ~/Import { \"model\": \"frontend\", \"transaction\": \"per-object\", \"objects\": [ { \"@odata.type\": \"Erp.General_Products_Product\", \"@erpnet.action\": \"merge\", \"ExternalId\": \"EXT000\", \"PartNumber\": \"DATP000\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": { \"Name\": \"Pieces\" } }, \"MeasurementUnit\": { \"Code\": \"pcs\" }, \"Name\": { \"EN\": \"Domain API Test 000\" }, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": { \"EN\": \"Domain API Tests\" } } }, { \"@odata.type\": \"Erp.General_Products_Product\", \"@erpnet.action\": \"merge\", \"ExternalId\": \"EXT001\", \"PartNumber\": \"DATP001\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": { \"Name\": \"Pieces\" } }, \"MeasurementUnit\": { \"Code\": \"pcs\" }, \"Name\": { \"EN\": \"Domain API Test 001\" }, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": { \"EN\": \"Domain API Tests\" } } }, { \"@odata.type\": \"Erp.General_Products_Product\", \"@erpnet.action\": \"merge\", \"ExternalId\": \"EXT002\", \"PartNumber\": \"DATP002\", \"BaseMeasurementCategory\": { \"@erpnet.action\": \"find\", \"@erpnet.findBy\": { \"Name\": \"Pieces\" } }, \"MeasurementUnit\": { \"Code\": \"pcs\" }, \"Name\": { \"EN\": \"Domain API Test 002\" }, \"ProductGroup\": { \"Code\": \"DATG01\", \"Name\": { \"EN\": \"Domain API Tests\" } } } ] } Try it Yourself Import Sales Order In this example, the Import action demonstrates how you can create or update complex records without manually specifying IDs. The key convenience is that referenced objects (like Customer, Product, or ProductGroup) can be automatically imported or updated within the same request. This makes the Import API extremely useful for data synchronization with external systems, where you may not have direct access to internal record IDs but still need to ensure all related entities are properly linked and up to date. The system automatically determines the @erpnet.action and @erpnet.findBy criteria based on the provided properties of the nested objects. POST https://testdb.my.erp.net/api/domain/odata/Import { \"objects\":[ { \"@odata.type\":\"Erp.Crm_Sales_SalesOrder\", \"DocumentType\":{ \"Code\":\"CRM_SALES_ORDER\" }, \"EnterpriseCompany\":{ \"@erpnet.findBy\":{ \"Code\":\"714895\" } }, \"EnterpriseCompanyLocation\":{ \"PartyCode\":\"00111\" }, \"Customer\":{ \"Number\":\"CST001\", \"Party\":{ \"@odata.type\":\"Erp.General_Contacts_Company\", \"PartyCode\":\"CST001\", \"Name\":{ \"EN\":\"Customer 01\" }, \"RegistrationType\":{ \"EN\":\"Ltd\" }, \"RegistrationNumber\":\"001001001\" }, \"EnterpriseCompany\":{ \"@erpnet.findBy\":{ \"Code\":\"714895\" } } }, \"DocumentCurrency\":{ \"CurrencySign\":\"GBP\" }, \"Lines\":[ { \"Product\":{ \"PartNumber\":\"PRD001\", \"BaseMeasurementCategory\":{ \"@erpnet.action\":\"find\", \"@erpnet.findBy\":{ \"Name\":\"Pieces\" } }, \"MeasurementUnit\":{ \"Code\":\"pcs\" }, \"Name\":{ \"EN\":\"Product 001\" }, \"ProductGroup\":{ \"Code\":\"PGT01\", \"Name\":{ \"EN\":\"Product Group 01\" } } }, \"QuantityUnit\":{ \"Code\":\"pcs\" }, \"Quantity\":{ \"Value\":1, \"Unit\":\"pcs\" }, \"UnitPrice\":{ \"Value\":20, \"Currency\":\"GBP\" } } ] } ] } Try it Yourself NOTE In case @erpnet.action annotation is missing, a default value is used. For top-level objects the default value of @erpnet.action is create. For nested objects the default @erpnet.action is find if only properties defining the search criteria are provided (either @erpnet.findBy or data properties usable in a find action). If other data properties are provided the default @erpnet.action is merge. See @erpnet.action topic. Explanation of the Automatic Actions Property Automatic Action Description DocumentType find The system searches for a document type with Code = \"CRM_SALES_ORDER\". Document types are predefined, so we search by code. EnterpriseCompany find Since only Code is provided, the system performs a lookup for an existing Enterprise Company with that code. EnterpriseCompanyLocation find The field PartyCode uniquely identifies the company location, so the system searches by it. Customer merge Customers are matched by Number. If a customer with Number = \"CST001\" exists, it’s passed to the sales order. Otherwise, a new one is created. The Party subobject (Company) will also be created if missing. Customer → Party merge Because Party is an abstract class, the type is explicitly specified as Erp.General_Contacts_Company. A new Party (Company) record is created if none exists (The system first looks up existing party by PartyCode). DocumentCurrency find The CurrencySign uniquely identifies the currency (e.g., \"GBP\"), so an existing record is used. Lines — Represents an array of line items that will be created as part of the sales order. Product merge The system searches for an existing product with PartNumber = \"PRD001\". If not found, a new product is created. This behavior prevents duplicate product definitions. Product → BaseMeasurementCategory find Uses Name = \"Pieces\" to locate the measurement category. Note that searching by multi-language properties is always with contains criteria. Product → MeasurementUnit find Looks up the measurement unit by Code = \"pcs\". Product → ProductGroup merge Uses Code = \"PGT01\" to find or create a product group. If it exists, it’s reused; otherwise, it’s created with the given name. QuantityUnit find The system searches for a measurement unit with Code = \"pcs\". Quantity / UnitPrice — These are complex properties of the order line and are directly assigned, not looked up. Error Handling The result contains the error message for each failed object. Example: { \"@erpnet.result\": \"fail\", \"objects\": [ { \"@erpnet.result\": \"fail\", \"@erpnet.message\": \"Object not found: EnterpriseCompany, action: find, findBy: {\\\"Code\\\":\\\"546346373\\\"}.\", \"@erpnet.error\": { \"message\": \"Object not found: EnterpriseCompany, action: find, findBy: {\\\"Code\\\":\\\"546346373\\\"}.\", \"code\": 0, \"type\": \"InvalidOperationException\", \"info\": \"System.InvalidOperationException: Object not found: EnterpriseCompany, action: find, findBy: {\\\"Code\\\":\\\"546346373\\\"}.\\r\\n at ErpNet.Model.OData.ODataResourceInfo.GetObject()\\r\\n at ErpNet.Model.OData.ODataResourceInfo.Execute()\\r\\n at ErpNet.Model.OData.ODataResourceInfo.Execute()\\r\\n at ErpNet.Model.OData.ODataResourceInfo.Execute()\\r\\n at ErpNet.Model.OData.Operations.ImportAction.HandleRequest(ODataContext odataContext, IDictionary`2 parameters, IODataRequestMessage requestMessage)\", \"messageFormat\": null, \"parameters\": null } } ] }"
  },
  "domain-api/data-manipulation/index.html": {
    "href": "domain-api/data-manipulation/index.html",
    "title": "Data Manipulation | ERP.net Developer Docs",
    "summary": "Data Manipulation Create Create new entity record. Update Update entity. Delete Delete entity. Property Dependencies and Update Order The order of provided properties is important. Data Validation and Business Rules ERP.net uses two models to handle entity data and business logic — the front-end model and the back-end model. While both represent the same entities, they differ in the business rules and data validations that are executed. Transactions ERP.net supports transactions to ensure that multiple operations on entities are processed consistently. Transactions allow you to group create, update, or delete operations into a single unit of work that is either committed or rolled back as a whole. Actions ERP.net uses the @erpnet.action annotation to control how JSON data is processed when creating, updating, or importing entities. It provides a flexible way to specify operations such as create, update, delete, find, and merge for top-level or nested objects. Data Import ERP.net provides an Import endpoint that allows you to insert, update, or delete multiple entities in a single request. This unbound action enables efficient bulk operations, supporting both front-end and back-end models. Data Sync ERP.net provides Data Synchronization to efficiently keep client applications up-to-date with system changes. Instead of fetching all data repeatedly, Data Sync retrieves only entities that have changed since the last synchronization, ensuring minimal network usage and fast updates. Error Handling When an error occurs during a Domain API operation, the service returns an HTTP status code 500 (Internal Server Error) and a JSON body containing detailed error information."
  },
  "domain-api/data-manipulation/transactions.html": {
    "href": "domain-api/data-manipulation/transactions.html",
    "title": "Domain API Transactions | ERP.net Developer Docs",
    "summary": "Domain API Transactions Тhe ErpNet Domain API introduces a server-side transaction that holds any change of an entity object made between calls of BeginTransaction and EndTransaction. An api transaction is a data set that contains the data for the objects used in the transaction. When we create a domain object in a transaction, a data set containing the data for this object is created in the memory of the api process. If we create another object in the same transaction, the second object is also saved in the same data set. The data is not yet present in the database until we commit the transaction. If we update the same field with different API requests in the same transaction, the value of the field remains the one submitted last. If we use a front-end transaction, each submission of a value for a given field will trigger front-end events that may update other fields. When the transaction is committed, the entire dataset is submitted to the database. At this point, we don't guarantee the order in which records from the same table are inserted into database. That's why several objects that have reference to the same entity type must be created in different transactions (for example parent-child related documents). BeginTransaction BeginTransaction is unbound (not bound to any entity) action (actions are called with HTTP POST method) that initializes an object transaction on the server and returns a TransactionId token as a plain text (not json - for example XXXXX). This object transaction is something like memory data-set that holds copies of database records. If any subsequent request includes the TransactionId token in the HTTP header (like this: TransactionId:XXXXX) the requested operation will not be executed against the database but against the memory transaction. This means that any POST, PATCH and DELETE requests will be executed only in memory. Parameters model: allowed values are common or frontend. This parameter indicates the data model used for the transaction. Front-end data model uses front-end business rules. For example front-end logic is when Quantity of a SalesOrderLine is changed the corresponding QuantityBase is calculated by a dedicated front-end business rule. Common model defines minimal business logic applicable in all cases - front-end or back-end. The default is common. trackChanges: true or false. This parameter enables the usage of GetChanges and WaitForChanges functions. This means that if parameter trackChanges is not true any call to GetChanges and WaitForChanges will return error. GetChanges GetChanges is unbound function - functions are invoked through GET HTTP method. This function requires the HTTP header TransactionId to be passed. It also requires the front-end transaction to be initialized with trackChanges: true. Front-end transactions support front-end business rules. These are rules that are usually triggered on attribute change. For example if we change the DocumentDate attribute of a SalesOrder (using regular PATCH request including the TransactionId in the request header), this change will trigger updates of several other attributes. If the front-end transaction is initialized with trackChanges: true, the changes will be collected in the server side (inside the front-end transaction). GetChanges returns all changes made after the last call of GetChanges or WaitForChanges. The changes are grouped by operation type (insert, update, delete), entity name, entity id. The call of GetChanges (or WaitForChanges) clears the collected changes in the transaction. If no change is made after the last call of GetChanges it will return empty result (empty JSON object). WaitForChanges WaitForChanges is unbound function that returns the same result as GetChanges but if there is not any change the function blocks until a change occurs or until it times out. The wait timeout is 2 minutes. This function requires the HTTP header TransactionId to be passed. It also requires the front-end transaction to be initialized with trackChanges: true. The response format of GetChanges and WaitForChanges follows this JSON schema: \"insert\" | \"update\" | \"delete\" : { \"<entity-name>\" : { // example: \"General_Products_Products\" \"<id>\": { // example: 59098bcf-f331-478f-91c2-f5520590f534 (Guid) \"<attribute>\": <value> // example: \"ABCClass\": \"A\" } } } EndTransaction EndTransaction is unbound action that disposes the memory transaction created with BeginTransaction. After EndTransaction the transaction id becomes invalid. Parameters commit: true or false. Specifies whether to commit the transaction (save the changes) or not. Default is true. To commit the changes made in the memory transaction to the database you should provide the parameter commit = true. Note The object transaction is called Front-End because any change of an entity object will trigger front-end business rules. For example if Quantiy of a SalesOrderLine is changed the corresponding QuantityBase will be automatically recalculated. This is front-end behavior - if front-end transaction is not used the QuantityBase will not be automatically recalculated and it's value must be explicitly set. Through Front-End Transaction, GetChanges or WaitForChanges we can synchronize our UI passing only the user actions to the server - such as update of an attribute, creating new object or deleting existing object. Transaction Lifespan and Management Each transaction has a defined lifespan. In a typical scenario: The lifespan of a transaction starts with the BeginTransaction call and ends with the EndTransaction call Additionally, each transaction has an absolute maximum lifespan, which is 25 minutes. Note Every transaction will be automatically cleared 25 minutes after its creation unless it has already been explicitly cleared with EndTransaction. If you reference the TransactionId of a cleared (or not existing) transaction, an error will be returned: \"Invalid TransactionId {id}\". Note It is best practice to keep transactions short and always close them when your work with them is complete. Examples Simple usage of a front end transaction BeginTransaction POST /api/domain/odata/BeginTransaction HTTP/1.1 Host: https://example.com Content-Type: application/json { \"model\": \"frontend\" } Response (Transaction id): 843f05ff3f62400c990d2a3b119e256e Update Make subsequent updates of products PATCH /api/domain/odata/General_Products_Products(59098bcf-f331-478f-91c2-f5520590f534) HTTP/1.1 Host: https://example.com Content-Type: application/json TransactionId: 843f05ff3f62400c990d2a3b119e256e { \"ABCClass\":\"A\", \"StandardLotSizeBase\":{\"Value\":3.45,\"Unit\":\"PCS\"}, \"MeasurementUnit@odata.bind\":\"https://example.com/api/domain/odata/General_MeasurementUnits(5c5e77ce-60bb-4338-abd0-3a2acb27ff93)\" } CommitTransaction POST /api/domain/odata/EndTransaction HTTP/1.1 Host: https://example.com Content-Type: application/json TransactionId: 843f05ff3f62400c990d2a3b119e256e { \"commit\": true } Updating SalesOrder.DocumentDate and calling GetChanges BeginTransaction POST /api/domain/odata/BeginTransaction HTTP/1.1 Host: https://example.com Content-Type: application/json { \"model\": \"frontend\", \"trackChanges\": true } Response (Transaction id): fd5d3bbc38ae4dd9a8a5c0ff46c8e3af Updating DocumentDate This update triggers many front-end business rules that update many other attributes in the sales order and it's lines. PATCH /api/domain/odata/Crm_Sales_SalesOrders(33cd6cb9-0f43-df11-a1e1-0018f3790817) Host: https://example.com Content-Type: application/json TransactionId: fd5d3bbc38ae4dd9a8a5c0ff46c8e3af { \"DocumentDate\": \"2020-05-08T00:00:00Z\" } Response: nocontent Call GetChanges The result is a JSON object with all changes made after the last call to GetChanges (or BeginTransaction if GetChanges is not called yet). GET /api/domain/odata/GetChanges HTTP/1.1 Host: https://example.com Content-Type: application/json TransactionId: fd5d3bbc38ae4dd9a8a5c0ff46c8e3af Response: { \"@odata.context\": \"https://clients.inco.bg/api/domain/odata/$metadata#Erp.OpenObject\", \"update\": { \"Crm_Sales_SalesOrders\": { \"33cd6cb9-0f43-df11-a1e1-0018f3790817\": { \"PaymentDueDate\": \"2020-05-08T00:00:00Z\", \"PaymentDueStartDate\": \"2020-05-08T00:00:00Z\", \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"DocumentDate\": \"2020-05-08T00:00:00Z\" } }, \"Crm_Sales_SalesOrderLines\": { \"c253add9-0f43-df11-a1e1-0018f3790817\": { \"HistoricalUnitCost\": null, \"RequestedQuantity\": null, \"StandardUnitPrice\": null, \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"LineAmount\": { \"Value\": 1.62, \"Currency\": \"BGN\" }, \"Quantity\": { \"Value\": 2, \"Unit\": \"бр\" }, \"QuantityBase\": { \"Value\": 2, \"Unit\": \"бр\" }, \"StandardQuantityBase\": { \"Value\": 2, \"Unit\": \"бр\" }, \"UnitPrice\": { \"Value\": 0.9, \"Currency\": \"BGN\" } }, \"c653add9-0f43-df11-a1e1-0018f3790817\": { \"HistoricalUnitCost\": null, \"RequestedQuantity\": null, \"StandardUnitPrice\": null, \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"LineAmount\": { \"Value\": 5.53, \"Currency\": \"BGN\" }, \"Quantity\": { \"Value\": 3, \"Unit\": \"бр\" }, \"QuantityBase\": { \"Value\": 3, \"Unit\": \"бр\" }, \"StandardQuantityBase\": { \"Value\": 3, \"Unit\": \"бр\" }, \"UnitPrice\": { \"Value\": 2, \"Currency\": \"BGN\" } }, \"c753add9-0f43-df11-a1e1-0018f3790817\": { \"HistoricalUnitCost\": null, \"RequestedQuantity\": null, \"StandardUnitPrice\": null, \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"LineAmount\": { \"Value\": 4.38, \"Currency\": \"BGN\" }, \"Quantity\": { \"Value\": 6, \"Unit\": \"kg\" }, \"QuantityBase\": { \"Value\": 6, \"Unit\": \"kg\" }, \"StandardQuantityBase\": { \"Value\": 6, \"Unit\": \"kg\" }, \"UnitPrice\": { \"Value\": 0.8, \"Currency\": \"BGN\" } }, \"c153add9-0f43-df11-a1e1-0018f3790817\": { \"HistoricalUnitCost\": null, \"RequestedQuantity\": null, \"StandardUnitPrice\": null, \"RequiredDeliveryDate\": \"2020-05-08T00:00:00Z\", \"LineAmount\": { \"Value\": 10.56, \"Currency\": \"BGN\" }, \"Quantity\": { \"Value\": 10, \"Unit\": \"l\" }, \"QuantityBase\": { \"Value\": 20, \"Unit\": \"бр\" }, \"StandardQuantityBase\": { \"Value\": 20, \"Unit\": \"бр\" }, \"UnitPrice\": { \"Value\": 1.17348, \"Currency\": \"BGN\" } } } } }"
  },
  "domain-api/data-manipulation/update-order.html": {
    "href": "domain-api/data-manipulation/update-order.html",
    "title": "Property Dependencies and Update Order | ERP.net Developer Docs",
    "summary": "Property Dependencies and Update Order In ERP.net, setting a property may trigger internal events that automatically update other dependent properties. Because of this, the order in which properties are set is important when creating or updating entities through the API. For example, the Quantity field is a complex type that depends on the QuantityUnit reference. If you set the Quantity before assigning the correct QuantityUnit, the system may interpret the value using an outdated or incorrect unit, leading to validation or conversion errors. To ensure correct behavior, always set the unit before the quantity value. Example: {` \"QuantityUnit\": { \"@odata.id\": \"General_MeasurementUnits(6f7cbe0e-9a2a-4e3b-9b64-4f86d8c9e7f0)\" }, \"Quantity\": { \"Value\": 1.00, \"Unit\": \"PCE\" } } This ensures that the system knows which measurement unit applies before processing the quantity, preventing inconsistencies when working with values in different units. NOTE: The same rule applies to other dependent fields such as Amount and Currency — always set the currency reference before specifying the amount value."
  },
  "domain-api/data-manipulation/update.html": {
    "href": "domain-api/data-manipulation/update.html",
    "title": "Update Operations | ERP.net Developer Docs",
    "summary": "Update Operations ERP.net supports updating entities using the PATCH method, which performs partial updates. Only the fields included in the request are modified; all other properties remain unchanged (except dependent properties updated by business rules triggered on attribute change). Key Points: Use PATCH to modify one or more fields of an existing entity. You do not need to send the entire entity. Always consider property dependencies — some fields must be set in a specific order (e.g., QuantityUnit before Quantity, Currency before Amount). Business rules and validations defined in the front-end or back-end models will be applied depending on how the data is processed. ERP.net supports optimistic locking to prevent conflicts during concurrent updates. Learn more in Optimistic Locking. Example: Updating the notes of a sales order: PATCH https://testdb.my.erp.net/api/domain/odata/Crm_Sales_SalesOrders(f3fe442a-d5fe-49a9-8bda-00c895d630bb) Content-Type: application/json { \"DocumentNotes\": \"Updated sales order description\" } Required Considerations: If updating fields involved in calculations or triggers, ensure dependent properties are included in the correct order. Only include fields you intend to modify; others will remain unchanged. System and user business rules will execute as appropriate (front-end rules on attribute changes, back-end rules on commit or document events). For more details on entity properties and rules, refer to the documentation of each entity. Foe example Sales Orders Documentation. Notes For concurrency control and optimistic locking see Data Sync topic."
  },
  "domain-api/data-sync/event-push.html": {
    "href": "domain-api/data-sync/event-push.html",
    "title": "Event push | ERP.net Developer Docs",
    "summary": "Event push Pushing events allows external app to be notified in real time when an event is triggered in ERP.net. Event push in ERP.net is implemented through Webhooks. Webhooks A Webhook is simply a way for ERP.net to call an external app in (near) real time. Webhooks are setup in two steps: A webhook template is setup in the Web Hooks entity. The template is activated using the WEBHOOK action in a User-defined business rule. Note Setting up user-defined business rules (UDBR) is outside the scope of this topic. UDBR allows you to select the business events which need to be pushed to the external app. For assistance in setting up UDBR, seek professional advice. Destination Webhooks allow ERP.net to call the external app in near real-time. However, if for any reason, the app is not able to accept the call, the event might be missed. We strongly advice, the usage of webhooks to be only for pushing an event to an enterprise grade messaging system, such as the Azure Service Bus. Usage It is up to the receiving application to decide what to do with the event. However, it usually updates some internal state, based on the event. In case the external app implements some forms of data sync between its private database and ERP.net, you might want to check the Object version topic."
  },
  "domain-api/data-sync/incremental-pull.html": {
    "href": "domain-api/data-sync/incremental-pull.html",
    "title": "Incremental pull by last update time | ERP.net Developer Docs",
    "summary": "Incremental pull by last update time Overview Some integrations need to periodically pull only the entities that have changed since the last successful synchronization run (incremental sync). Starting from v26.2, aggregate root entities expose a calculated attribute AggregateLastUpdateTimeUtc, which can be used to implement incremental pulls via Domain API. AggregateLastUpdateTimeUtc is a UTC timestamp. Getting started 1) Select the last update timestamp To retrieve the value, explicitly select AggregateLastUpdateTimeUtc: General_Products_Products?$top=10&$select=Id,AggregateLastUpdateTimeUtc,PartNumber 2) First synchronization run (full initial sync) On the first run there is no watermark. If you want a complete local copy, the recommended approach is to do a full initial pull and only then start incremental pulls. Recommended approach (full initial sync): Perform a full pull (no filter on AggregateLastUpdateTimeUtc). Always use paging ($top) and follow @odata.nextLink until completion. Process each item idempotently (upsert). While processing all pages, track maxSeenUtc = the maximum AggregateLastUpdateTimeUtc value you have successfully processed. Persist the watermark only after the whole initial run finishes successfully: watermarkUtc = maxSeenUtc This ensures that the first incremental run starts from a safe point in time. Alternative (start “from now”, no history): If you do not need historical data, you can initialize: watermarkUtc = nowUtc and start incremental pulls from watermarkUtc - overlap. This starts the sync from “current time”, but it does not load existing/older records. 3) Incremental pulls (watermark + overlap) A robust incremental sync uses a small overlap window to avoid missing changes around the watermark boundary. Store watermarkUtc (the last successfully processed point in time). Choose an overlap duration. For the next run, request changes from fromUtc = watermarkUtc - overlap. NOTE Domain API incremental sync uses $filter=... ge ..., so using an overlap window and idempotent processing is required. Recommended overlap: 5 minutes (default) 30 minutes (heavy workloads / large transactions) up to 1 hour (worst-case safety window) NOTE For synchronization scenarios, use $top=1000 and do not use a value greater than 1000. If the payload per row is large (many selected fields and/or $expand), consider using a smaller $top. Example: watermarkUtc = 2023-06-09T10:00:00.000Z overlap = 5 minutes fromUtc = 2023-06-09T09:55:00.000Z General_Products_Products? $top=1000& $select=Id,AggregateLastUpdateTimeUtc,PartNumber& $filter=AggregateLastUpdateTimeUtc ge 2023-06-09T09:55:00.000Z Because the filter intentionally goes a bit back in time, the result may contain duplicates that you have already processed in previous runs (or earlier pages of the same run). Your sync logic must be idempotent (see “Handling duplicates” below). 4) Page through results using @odata.nextLink When $top is provided, Domain API returns @odata.nextLink. Recommended client behavior: Treat @odata.nextLink as an opaque URL. Keep requesting it until the server stops returning @odata.nextLink. This paging approach is required for large result sets. For more details, see Paging results ($top and @odata.nextLink). Concepts AggregateLastUpdateTimeUtc AggregateLastUpdateTimeUtc is available for entities that are aggregate roots. The value is calculated from the Extensible Data Object (EDO) change tracking (i.e. it represents the aggregated “last update moment” for the whole aggregate). This makes it suitable for incremental pull scenarios where any change in the aggregate tree should be considered an update. Using overlap Overlap reduces the chance of missing changes around the watermark boundary (latency, clock skew, boundary equality, retries). Typical approach: Query from watermarkUtc - overlap using ge Deduplicate and process idempotently Advance watermark only after a successful full run Handling duplicates (required) Duplicates are expected when using overlap. The sync code should be idempotent. A practical approach is to store a per-entity checkpoint keyed by Id: lastAppliedUtcById[Id] = last processed AggregateLastUpdateTimeUtc for this entity Then, for every received item: If item.AggregateLastUpdateTimeUtc <= lastAppliedUtcById[item.Id] → skip (duplicate/older) Else → upsert + update the per-entity checkpoint Pseudocode: maxSeenUtc = watermarkUtc for each page (following @odata.nextLink): for each item: lastApplied = lastAppliedUtcById[item.Id] (or null) if lastApplied != null and item.AggregateLastUpdateTimeUtc <= lastApplied: continue upsert(item) lastAppliedUtcById[item.Id] = item.AggregateLastUpdateTimeUtc maxSeenUtc = max(maxSeenUtc, item.AggregateLastUpdateTimeUtc) watermarkUtc = maxSeenUtc // advance watermark only after successful commit of the whole run Troubleshooting I don’t see AggregateLastUpdateTimeUtc The attribute is available only for entities that are aggregate roots. If the entity set you are querying is not an aggregate root, the attribute will not be exposed. Also make sure that the AggregateLastUpdateTimeUtc is explicitly included in $select clause. My incremental sync produces duplicates This is expected when using overlap (fromUtc = watermarkUtc - overlap). Ensure your sync logic is idempotent and deduplicates by (Id, AggregateLastUpdateTimeUtc) as described above. I keep reprocessing the same rows on every run Common causes: The overlap window is too large for the update rate of the dataset. The sync advances the watermark incorrectly (e.g. persisting watermarkUtc before the whole run has completed successfully). The watermark is not persisted, so every run starts from an old value. Recommended approach: Persist watermarkUtc only after a successful full run. Consider reducing the overlap window if duplicates are too frequent. I suspect that some updates are missing Common causes: Overlap is too small for your worst-case transaction duration / processing delays. The sync persists watermarkUtc even when the run fails halfway. Recommended approach: Increase overlap (e.g. from 5 minutes to 30 minutes, or up to 1 hour for worst-case safety). Persist the watermark only after successful commit of the whole run."
  },
  "domain-api/data-sync/index.html": {
    "href": "domain-api/data-sync/index.html",
    "title": "Data synchronization | ERP.net Developer Docs",
    "summary": "Data synchronization Data sync occurs in many scenarios, where an external app synchronizes data betweed it and ERP.net. Data sync tasks of an external app include: Receive real time notifications for changes in ERP.net Check whether an object is updated in ERP.net since last check Implement UI with Optimistic locking for data, stored in ERP.net The data sync framework implemented in ERP.net Domain API allows efficient implementation of such scenarios. For more information, select from the topics below: Event push Object version Optimistic locking Incremental pull Note The data sync support is first available in ERP.net v.2022.1."
  },
  "domain-api/data-sync/object-version.html": {
    "href": "domain-api/data-sync/object-version.html",
    "title": "Object version | ERP.net Developer Docs",
    "summary": "Object version Object version is a system and API supported way for applications to track changes in ERP.net entities. Change tracking The changes are aggregated in the Entity aggregates. This means, that, if for example, an external app updates a single Sales Order Line, the update creates a new version for the whole Sales Order aggregate. Object version reflects this change by increasing its counter with 1. In short, Object version is owned by the aggregate root and it's a subject for the whole aggregate tree. The version will increment after each change in the aggregate tree- this means attributes, custom properties, references, etc. Note Applications should not depend on strict monotonically increasing values of Object version. In some scenarios, it might skip values. However, it is guaranteed, that upon update, the value is changed. Setup In order for the Object version system to start working, the aggregate (e.g, its root entity) must be setup to Track Changes with at least level 1. Usage Object version is available through the Domain API for each entity type. In order for the API to return the object version, it must be explicitly selected in the API call. For example: Crm_Sales_SalesOrders(a727114c-3b36-e311-81cb-00155d001f00)?$select=Lines,ObjectVersion&$expand=Lines($select=ObjectVersion,default) Note Retrieving the object version is resource intensive operation. Perform it only when strictly necessary and only for the entities, for which it is required."
  },
  "domain-api/data-sync/optimistic-locking.html": {
    "href": "domain-api/data-sync/optimistic-locking.html",
    "title": "Optimistic locking | ERP.net Developer Docs",
    "summary": "Optimistic locking Optimistic concurrency control is a no-lock concurrency control method. In ERP.net it is implemented through the Object version API. Optimistic locking is usually used in the following scenarios: Replication of data between external data source and ERP.net. Implementing external UI for data apps. Usage scenario External app allows its users to modify an entity, stored in an ERP.net instance. The external app reads the entity, including the Object version. The external app presents a UI to the end user and allows them to edit the entity. When the user saves the data, the app call the update API, providing the data + the previously read Object version. The system checks whether the Object version in the ERP.net instance is still the same and proceeds with the update ONLY if it is the same; otherwise, it returns error. Note For replication scenarios, the steps are the same, with the exception of step 2, which might not be a UI, but a time frame between two synchronizations. By implementing the above scenario, the app guarantees that it would not overwrite other apps changes if such have occurred in ERP.net between step 1 and step 3. Note It is the decision of the app to provide Object version when updating the entity. If Object version is not provided, the system would not perform the optimistic locking check."
  },
  "domain-api/execute-script.html": {
    "href": "domain-api/execute-script.html",
    "title": "ExecuteScript | ERP.net Developer Docs",
    "summary": "ExecuteScript ERP.net Domain API defines an ExecuteScript endpoint which can be used to execute JavaScript code directly in the domain context. ExecuteScript is an unbound OData action, invoked via HTTP POST, whose request body contains raw JavaScript source code. The script runs server-side in a sandboxed runtime with access to the Domain Model and may query, create, update, or delete domain data. Endpoint POST /api/domain/odata/ExecuteScript Request body Required. The request body must contain plain JavaScript source code, encoded as UTF-8 text. Warning The body is not JSON There are no parameters The entire request stream is interpreted as JavaScript If the body is empty or whitespace, the action fails. Example POST https://<your-instance>.my.erp.net/api/domain/odata/ExecuteScript Content-Type: text/plain Accept: application/json console.log('Starting script'); // Example: deactivate all active customers var customers = Domain.Crm.Sales.CustomersRepository.query({ active: { equals: true } }); const customersCount = customers.length; for (var i = 0; i < customersCount; i++) { customers[i].Active = false; } console.log(`Processed ${customersCount} customers.`) Transaction control from JavaScript The script runtime exposes a global Transaction object, which allows the script to explicitly control transaction boundaries. You can start a transaction, commit changes, or roll everything back directly from JavaScript: Transaction.begin(); Transaction.commit(); Transaction.rollback(); Use Transaction.rollback() to safely discard changes when you detect invalid data or want a \"dry run\" style execution. Use Transaction.commit() only when you are sure all changes are consistent and should be persisted. External transaction control ExecuteScript can execute inside an externally managed Domain API transaction. If a transaction has been started beforehand using the BeginTransaction unbound action and its TransactionId is provided in the request headers, the script runs within that existing transaction. In this case: All changes are applied to the in-memory transaction dataset. The script does not implicitly commit or end the transaction. Final persistence is controlled externally via EndTransaction with commit: true or commit: false. This allows ExecuteScript to be composed with other Domain API operations as part of a larger transactional workflow, where transaction lifecycle (begin, commit, rollback) is managed outside the script. Warning External transaction interaction When ExecuteScript runs inside a transaction started via BeginTransaction, the global Transaction object operates on that same transaction. Calling Transaction.begin(), Transaction.commit(), or Transaction.rollback() from the script will directly affect the external transaction and may interfere with its lifecycle. This usage is not recommended. When a transaction is managed externally, control it only via the Domain API transaction actions. For more details about transaction lifecycle and management, see the Domain API Transactions documentation. Result On success, the action returns a JSON object with execution metadata and captured console output. Example response { \"ok\": true, \"sessionId\": \"f3b2c8a7...\", \"transactionId\": \"9d1a4e2c...\", \"durationMs\": 37, \"console\": \"Starting script\\nProcessed 128 customers\" } Fields ok - Always true on success sessionId - Current session identifier transactionId - Current in-memory transaction identifier, if any durationMs - Script execution time in milliseconds console - Output collected from the global console object, if used Error handling If script execution fails due to: empty request body JavaScript runtime error exceeded runtime constraints the action returns an OData error response and no changes are committed. Learn More ERP.net Scripting documentation Advanced scripting examples"
  },
  "domain-api/index.html": {
    "href": "domain-api/index.html",
    "title": "Domain API | ERP.net Developer Docs",
    "summary": "Domain API Introduction The Domain API is the primary API for accessing and manipulating data in ERP.net. It is most useful for UI and service apps. For BI, you should use the Table API. For an overview and introduction of the Domain API, read the thorough presentation at the home page of the developer docs. Based on OData The Domain API is based on the OData protocol. It allows object-oriented access to the data exposed by the ERP.net domain objects. The OData API is structured along a number of entity types (called \"repositories\" in ERP.net), that represent the Domain Model of the ERP Instance. Each entity type contains data attributes, which can be filtered, sorted, etc. The model also provides information on how to navigate between the repositories. For a quick introduction to OData, check the beginners tutorial at the OData site: https://www.odata.org/getting-started/understand-odata-in-6-steps/ Next steps To learn more about the ERP.net Domain API, read below: Querying data - Introduction to data querying. Data manipulation - Introduction to data manipulation. Common tasks - Useful examples. Working with documents - working with documents is a common scenario when using the API. Batch requests (OData site) - ERP.net fully supports batch requests, saving round-trips to the server."
  },
  "domain-api/libraries.html": {
    "href": "domain-api/libraries.html",
    "title": "Domain API Libraries | ERP.net Developer Docs",
    "summary": "Domain API Libraries The Domain API is based on the OData protocol. It provides object-oriented access to the data exposed by ERP.net domain objects. The Domain API is an HTTP RESTful API and can be accessed through standard HTTP requests. However, using a client library simplifies authentication, request building, and result parsing. ERP.net Libraries .NET ErpNet.Api.Client ErpNet.Api.Client is the official .NET client library for ERP.net APIs. It supports both Table API and Domain API, built on top of the OData standard. NuGet packages: ErpNet.Api.Client ErpNet.Api.Client.DomainApi Example: var erpNetDatabaseUri = \"https://demodb.my.erp.net\"; // Create ErpNetServiceClient object to obtain a service access token. // In the database there must be trusted application registration with // ApplicationUri: \"ServiceDemoClient\" and ApplcationSecretHash=Sha256(\"DEMO\"). ErpNetServiceClient identityClient = new ErpNetServiceClient( erpNetDatabaseUri, \"ServiceDemoClient\", \"DEMO\"); // Obtain the web address of the DomainApi for the database. var apiRoot = await identityClient.GetDomainApiODataServiceRootAsync(); // Create the service DomainApiService service = new DomainApiService( apiRoot, identityClient.GetAccessTokenAsync); // Create query command with $top, $filter, $select and $expand clauses. ODataCommand command = new ODataCommand(\"General_Products_Products\"); command.Type = ErpCommandType.Query; command.FilterClause = \"contains(PartNumber,'001')\"; command.SelectClause = \"Id,PartNumber,Name,ProductGroup\"; command.ExpandClause = \"ProductGroup($select=Id,Code,Name)\"; command.TopClause = 5; // Get the ODATA json result as IDictionary<string,object> var result = await service.ExecuteDictionaryAsync(command); Using typed entities: // Use anonymous types for $select and $expand clause var cmd = service.Command<Product>() .Top(5) .Filter(p => p.PartNumber.Contains(\"001\")) .Select(p => new { p.Id, p.PartNumber, p.Name, ProductGroup = new { p.ProductGroup.Id, p.ProductGroup.Code, p.ProductGroup.Name } }); var result = await cmd.LoadAsync(); // The HTTP command is: // GET General_Products_Products?$top=5&$filter=contains(PartNumber,'001') // &$select=Id,PartNumber,Name,ProductGroup // &$expand=ProductGroup($select=Id,Code,Name) For more samples, see: ErpNet.Api.Client Samples Generic OData Libraries The Domain API follows the OData standard, so any OData-compliant library can be used to access it. You can explore a list of available client libraries for different programming languages at: https://www.odata.org/libraries/"
  },
  "domain-api/querying-data/complex-types.html": {
    "href": "domain-api/querying-data/complex-types.html",
    "title": "| ERP.net Developer Docs",
    "summary": "Handling Complex Data Types Some entities include complex or multi-part data types. For detailed explanations and examples, see Complex Data Types. Multi-language Strings: Some fields may have different values for each language. These fields are represented as a complex object with one property per language. For example: { \"Name\": { \"EN\": \"Laptop\", \"DE\": \"Laptop\", \"FR\": \"Ordinateur portable\" } } Use the property corresponding to the desired language when displaying or processing the value. NOTE: Multi-language fields support only filtering with the contains(Field, 'value') function. Other filter operators are not supported. Example: General_Products_Products?$filter=contains(Name,'ap')&$top=10 Quantities and Amounts: Fields with units (e.g., Quantity, Amount) require attention to precision and currency. Example: \"Quantity\": { \"Value\": 12.5, \"Unit\": \"kg\", } \"Amount\": { \"Value\": 250.00, \"Currency\": \"USD\" } Example: To filter by Quantity or Amount value you can use the special (internal) property named {Property}Value. For example in Crm_Sales_SalesOrderLines we have Quantity property. We can filter by quantity value: [Crm_Sales_SalesOrderLines?$top=10&$filter=QuantityValue ge 10](https://testdb.my.erp.net/api/domain/query?GET+Crm_Sales_SalesOrderLines?$top=10&$filter=QuantityValue ge 10) Enums and References: Some fields reference other entities or use enumerated values. Use $expand or lookups to resolve them. Example: { \"State\": \"New\", \"Customer\": { \"Id\": 123, \"Number\": \"009987\" } } Examples: The enum values are represented as string. You can filter by enum value like this Crm_Sales_SalesOrders?$top=10&$filter=State eq 'Released'&$orderby=DocumentDate desc To filter by reference use it's odata id: Crm_Sales_SalesOrders?$top=10&$filter=DocumentType eq 'Systems_Documents_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)' For more information see Complex Types Topic"
  },
  "domain-api/querying-data/filterable-references.html": {
    "href": "domain-api/querying-data/filterable-references.html",
    "title": "Filterable references | ERP.net Developer Docs",
    "summary": "Filterable references Overview Query filters allow each attribute from the entity to be filtered. References also can be filtered, by equalling them to single or multiple instances of the referenced entity. Sometimes however, we don't know the exact referened entity, but want to filter by the attributes of the referenced entity. Note In SQL terms, this is very similar to JOIN-ing the referenced table and then filtering in the WHERE by some of the columns of the referenced table. For example, in the Customers Entity, we might want to filter by the attributes of the related Parties Entity. Finding out if a reference is filterable Because of the static way the SQL data access layer is built (using only Stored Procedures), filtering by the attributes of a referenced entity is not always possible. To be able to filter by a reference, the auto-generated SQL procedures should already JOIN the referenced table. For this reason, only a handful of the referenes support filtering. Note Ownership references are ALWAYS filterable. For example, starting from SalesOrderLines Entity, you can filter by the attributes of the SalesOrder. To find out if an attribute supports filtering, look for the FilterableReference tag in the attribute details. For example, see how StoreOrderLine reference is filterable: https://docs.erp.net/model/entities/Crm.Customers.html#party Try in Query Builder To filter the customers by the attributes of the related party, you can use the following query: https://testdb.my.erp.net/api/domain/querybuilder?Crm_Customers?$filter=contains(Party/PartyName,'com')&$expand=Party($select=PartyName)&$select=Party To filter the sales order lines by the attributes of the owner sales order, you can use the following query: https://testdb.my.erp.net/api/domain/querybuilder?Crm_Sales_SalesOrderLines?$top=10&$filter=SalesOrder/State%20eq%20'Released'%20and%20SalesOrder/Void%20eq%20false To filter the unfulfilled store order lines view by the state of the store order use the following query: https://testdb.my.erp.net/api/domain/querybuilder?Logistics_Inventory_StoreOrderLinesUnfulfilledView?$top=10&$filter=StoreOrderLine/StoreOrder/State%20eq%20%27Released%27"
  },
  "domain-api/querying-data/index.html": {
    "href": "domain-api/querying-data/index.html",
    "title": "Querying Data | ERP.net Developer Docs",
    "summary": "Querying Data The Querying Data section explains how to retrieve information from ERP.net using the Domain API. All queries use standard OData conventions, with some ERP.net-specific extensions. OData Basics ERP.net exposes entities (repositories) through an OData-compliant service. Each entity represents a type of data in the system, such as Customer, Order, or Product. Service Root URL: The base URL for all queries. Example: https://testdb.my.erp.net/api/domain/odata/ Entity Types: Each entity can be queried independently. Common entities include: Crm_Sales_Customers Crm_Sales_SalesOrders General_Products_Products In This Section Query Options Explains the URL parameters used for querying data. Paging results How to page large result sets using $top and @odata.nextLink ($skiptoken vs $skip). Query Builder ERP.net includes a Visual Query Designer to simplify query creation Query Tool The ERP.net Query Tool allows you to experiment with Domain API requests directly in the browser. Filterable References Filter by properties of a referenced object. Examples Useful examples and common tasks."
  },
  "domain-api/querying-data/paging.html": {
    "href": "domain-api/querying-data/paging.html",
    "title": "Paging results ($top and | ERP.net Developer Docs",
    "summary": "Paging results ($top and @odata.nextLink) Overview When retrieving large datasets through the Domain API, clients should page results instead of requesting “everything at once”. Paging is enabled by providing $top. When $top is present, the response may include @odata.nextLink, which the client must follow to retrieve the next page. NOTE @odata.nextLink is an opaque (transparent) server-generated URL. Clients must not parse it, modify it, or attempt to “recreate” it. The only correct behavior is to request the URL exactly as returned by the server. Getting started 1) Pick a page size (recommended for synchronizations) For synchronization / data replication scenarios, a good default is: $top=1000 (recommended) do not use a value greater than 1000 The goal is to keep each request predictable in duration and payload size, while still being efficient enough for large pulls. If the payload per row is large (many selected fields or expanded references), consider using a smaller $top. NOTE Recommended for synchronizations: use $top=1000 and do not use a value greater than 1000. Example: General_Products_Products?$top=1000&$select=Id,PartNumber 2) Request the first page and follow @odata.nextLink Start with the initial query (including $top). If the server returns @odata.nextLink, request it to get the next page. Continue until @odata.nextLink is no longer returned. Recommended client behavior: Treat @odata.nextLink as an opaque URL (do not parse or modify it). Keep requesting it until the server stops returning @odata.nextLink. Concepts Why $top is required $top serves two purposes: It limits the payload size of a single response. It enables server-driven paging via @odata.nextLink so the client can safely fetch the whole result set page-by-page. For synchronization workloads, server-driven paging is the recommended approach for pulling large datasets reliably. Why $top=1000 is a good default for synchronization In sync scenarios, clients often need to read many rows (sometimes millions) and must balance: efficiency (fewer requests), stability (avoid very large responses), resilience (retries should be cheap), consistent throughput over time. Using $top=1000 is a practical default because it typically provides good throughput without making individual requests too heavy. It also makes retry logic simpler: if a request fails, you retry a relatively small batch. If you select many fields, use $expand, or the entity payload is large, using a smaller $top may reduce memory usage and response size per request. NOTE Always page using $top and @odata.nextLink for synchronization. Avoid designs that depend on “single huge response”. @odata.nextLink is opaque (clients must not analyze it) Clients must treat @odata.nextLink as a server-generated continuation link. Whether the link contains $skiptoken (keyset paging) or $skip (offset paging) is an internal server decision and does not change the client algorithm: always follow @odata.nextLink exactly as returned. NOTE Do not branch sync logic based on whether the link contains $skiptoken or $skip. Server behavior: $skiptoken vs $skip (for reference) Depending on the query shape, Domain API may generate @odata.nextLink using different paging strategies. If the query targets an entity set backed by a table (not a view) and does not specify $orderby, @odata.nextLink may contain: $skiptoken={NEXT_ID} This is keyset paging based on the default ordering by Id. Example: \"@odata.nextLink\": \"General_Products_Products?$top=1000&$select=Id&$count=true&$skiptoken=3f253c9a-5936-e311-81cb-00155d001f00\" If the query is against a view or if $orderby is specified, @odata.nextLink may be generated using $skip (offset paging), e.g.: ...&$skip={prevSkip + top} This is an implementation detail. Clients must not rely on a specific strategy and must not branch logic based on whether the link contains $skiptoken or $skip. Implementation detail (for expectations) For requests with $top, the server may internally fetch one extra row to determine whether there is a next page and to construct @odata.nextLink. Troubleshooting I don’t get @odata.nextLink @odata.nextLink is returned only when $top is specified and there are more results after the current page. I don’t get $skiptoken (I get $skip instead) $skiptoken may be returned only when: $top is specified, no $orderby is specified, the entity set is backed by a table (not a view). If any of these conditions is not met, @odata.nextLink may use $skip."
  },
  "domain-api/querying-data/query-builder.html": {
    "href": "domain-api/querying-data/query-builder.html",
    "title": "Query Builder | ERP.net Developer Docs",
    "summary": "Query Builder Description ERP.net has an integrated visual Query Builder. The Query Builder allows building queries, specific to the ERP Instance. When you use the Query Builder, it allows you to select the user-defined data and calculated attributes in that instance. The Query Builder allows the developers to create the query visually and then just re-use the query text, replacing the parameters. Try it To access the Query Builder for DEMODB, go to: https://demodb.my.erp.net/api/domain/querybuilder Tip User: Admin Password: 123 While the query is built, the Query Builder changes its URL. For example, to preview the same query for the first 10 products in the Query Builder, head to: https://demodb.my.erp.net/api/domain/querybuilder#General_Products_Products?$top=10 When you press Execute in the Query Builder, you can preview the result both as table and as JSON. Note Pay attention to the link under the selected entity, which opens the documentation for the entity."
  },
  "domain-api/querying-data/query-options/filter.html": {
    "href": "domain-api/querying-data/query-options/filter.html",
    "title": "$filter query option | ERP.net Developer Docs",
    "summary": "$filter query option $filter is a standard OData query option, implemented with some limitations in ERP.net. Not every operation and function provided by the OData standard are implemented. For a great introduction to $filter, read the OData $filter tutorial. This article mostly emphasizes on the implementation details of $filter in ERP.net. Supported operators Operator Description eq Equal ge Greater than or equal le Less than or equal and Returns true if both the left and right operands evaluate to true. in The in operator returns true if the left operand is a member of the right operand. The right operand MUST be a comma-separated list of primitive value. Operator 'or' is not supported Operator 'or' is not supported. However all navigation properties and some properties of enumerable type (e.g. General_Document.State) support the 'in' operator. Operator 'eq' The operator 'eq' is used to compare an attribute with value. Compare Id: General_Products_Products?$filter=Id in 0e8fb111-5b04-4eab-a890-47cfb9cfa4c4 Compare reference General_Products_Products?$filter=ProductGroup eq 'General_Products_ProductGroups(0bf6b45c-7ec1-484d-9f84-00072b77fabb)' Compare integer Crm_Sales_SalesOrderLines?$filter=LineNo eq 10 Compare string General_Products_Products?$filter=PartNumber eq '1234' Compare enum Similar to string: Crm_Sales_SalesOrders?$filter=State eq 'Released' Compare stored attribute Use only the \"short\" value of the stored attribute: General_Products_Products?$filter=CustomProperty_color eq 'blue' Operator 'in' The 'in' operator can be used for minimizing the query round trips. Examples: List of Id values: General_Products_Products?$filter=Id in (0e8fb111-5b04-4eab-a890-47cfb9cfa4c4, 14389ba0-ee5c-459e-afd0-d74c17240f28) List of enum values: Crm_Sales_SalesOrders?$top=10&$filter=State in ('FirmPlanned', 'Released')&$select=State List of reference values: Crm_Sales_SalesOrders?$top=10&$select=DocumentType&$filter=DocumentType in ('General_DocumentTypes(f8a93d3a-8cf3-4a09-9d45-667d664cb98d)', 'General_DocumentTypes(469b67b1-8b4b-4fb4-9d97-20c96105a85a)') List of reference values with different types (polymorphism): Crm_Sales_SalesOrders?$top=10&$filter=ToParty in ('General_Contacts_Persons(adb66f3f-e173-4a37-878c-000920f44ff0)', 'General_Contacts_Companies(39148781-d316-4d4d-a392-0002f73710f2)') Filter by date and date-time attributes Example: Crm_Sales_SalesOrders?$top=10&$filter=DocumentDate ge 2020-01-01Z Note! Filter by date-time is not supported! A date-time value in the filter is truncated to date only. For example $filter=TransactionTimestamp le 2020-01-05T23:59:59.999Z is converted to $filter=TransactionTimestamp le 2020-01-05T00:00:00Z. If we want to find all store transaction lines for date 2020-01-05 we should make filter $filter=TransactionTimestamp ge 2020-01-05T00:00:00Z and TransactionTimestamp ge 2020-01-06T00:00:00Z and then in the result we must check for lines on 2020-01-06. Filter by complex attributes In ODATA complex objects can not participate in the $filter clause. The quantities and amounts in DomainApi are represented as complex objects that contain the value and the measurement unit (or currency). To filter by Amount or Quantity attribute you can use the name of the attribute followed by 'Value': ~/Logistics_Inventory_StoreTransactionLines?$filter=QuantityValue ge 5.555 ~/Crm_Sales_SalesOrderLines?$filter=LineAmountValue ge 5.555 CustomPropertyValue is another complex type. To filter by Custom Property you must use only the short value (only eq is supported): General_Products_Products?$top=10&$select=CustomProperty_color&$filter=CustomProperty_color eq 'blue' MultilanguageString is another complex type. Multi-language properties support only filter function contains: ~/General_Products_Products?$filter=contains(Name,'ppl') This is an invalid filter: ~/General_Products_Products?$filter=Name eq 'Apple' Supported standard functions Edm.Boolean contains(Edm.String, Edm.String) Edm.Boolean endswith(Edm.String, Edm.String) Edm.Boolean startswith(Edm.String, Edm.String) Supported non-standard $filter functions Edm.Boolean contains(Erp.MultilanguageString, Edm.String) Returns true if the second string is contained in any language of the first multi-language string. Example: ~/Crm_Customers?$filter=contains(Party/PartyName,'Peter') Edm.Boolean contains(NavigationProperty, Edm.String) Returns true if the string is contained in the entity, refereced by the navigation property. Example: ~/Crm_Customers?$filter=contains(SalesPerson,'Peter') Edm.Boolean equalnull(any-type,any-type) Returns true if the first argument is equal to the second argument or the first argument is null. Example: ~/Crm_Sales_SalesOrders?&$filter=equalnull(Store,'Logistics_Inventory_Stores(8d7dd360-17cc-47f4-a878-1ee0f06445ad)') Edm.Boolean lessequalnull(any-type,any-type) Returns true if the first argument is less than or equal to the second argument or the first argument is null. Example: ~/Crm_SalesPersons?$top=10&$filter=lessequalnull(ContractEndDate,2019-02-01T00:00:00.000Z) Edm.Boolean greaterequalnull(any-type,any-type) Returns true if the first argument is greater than or equal to the second argument or the first argument is null. Example: ~/Crm_SalesPersons?$top=10&$filter=greaterequalnull(ContractStartDate,2019-02-01T00:00:00.000Z)"
  },
  "domain-api/querying-data/query-options/index.html": {
    "href": "domain-api/querying-data/query-options/index.html",
    "title": "Query options | ERP.net Developer Docs",
    "summary": "Query options Query options allow you to control the amount and order of the data that a data service returns for the resource identified by the URI. OData system query options are provided by the OData framework and documented in detail in the OData specification at http://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part2-url-conventions.html. For a great introduction to query options, read the OData query data tutorial. List of supported query options Query Option Origin Description $count OData The $count system query option allows clients to request a count of the matching resources included with the resources in the response. The $count query option has a Boolean value of true or false. $expand OData The $expand system query option specifies the related resources or media streams to be included in line with retrieved resources. $filter OData The $filter system query option allows clients to filter a collection of resources that are addressed by a request URL. $metadata OData Returns the data model (which is the structure of all resources). $orderby OData Specifies an expression for determining which values are used to order the collection of records identified by the resource path section of the URI. $select OData Limits the data to the specified attributes. $skip OData The $skip query option requests the number of items in the queried collection that are to be skipped and not included in the result. $skiptoken OData The $skiptoken is an opaque, server-generated identifier used for server-side paging that directs the client to the specific starting point of the next subset of results. $top OData The $top system query option requests the number of items in the queried collection to be included in the result. $search OData The $search system query option allows clients to request items within a collection matching a free-text. Each entity implements the searching in a different way. options Extension List of comma separated options/flags that affect the behavior of the system. Note Options marked as \"Extension\" are not part of the OData standard and are specific to the ERP.net Domain API. They do not use $ in front of their name, as it is reserved for standard OData query options."
  },
  "domain-api/querying-data/query-options/options.html": {
    "href": "domain-api/querying-data/query-options/options.html",
    "title": "| ERP.net Developer Docs",
    "summary": "options query option Note options is Domain API specific option and is not part of the OData standard. Therefore, this option DOES NOT have \"$\" in front of its name. options contains option flags, which are provided as url arguments. Flag Description skipnulls Indicates that properties with null value are not returned in the JSON result. Example: options=skipnulls"
  },
  "domain-api/querying-data/query-options/search.html": {
    "href": "domain-api/querying-data/query-options/search.html",
    "title": "$search query option | ERP.net Developer Docs",
    "summary": "$search query option Description $search is a system query option, a standard one in the OData protocol. The $search system query option restricts the result to include only those entities, matching the specified search expression. The search expression is a freeform string. For more detailed info, strictly defined according to the OData protocol, check this resource here. How the search works When an entity is searched, it's checked for a match between the searched string and the value of one or more attributes. Exactly which attributes of the entity will be checked for a match, depends on which are specified in the entity's default search members and display text format. Note The attributes for an entity to search for a match are those, defined in the Default search members and the Display text format. For each different entity. Default search members They're defined at the system level and may differ for different entities. The exact search members for each entity can be found in the documentation, but there's a rule that's generally true in most cases, Note The default search members (i.e. attributes) for an entity are these, supporting Code and Name. E.g. the Customers entity has its default search members: Number; Party.PartyName https://docs.erp.net/model/entities/Crm.Customers.html Display text The search is also performed on the attributes, part of the display text attribute. It's available for all entities. https://docs.erp.net/model/entities/Systems.Core.EntitySettings.html#displaytextformat https://docs.erp.net/tech/advanced/data-objects/display-format.html Usage Just see the query below, GET ~/Crm_Customers?$select=Number&$search=\"015\" This will return all customers, matching the searched string 015. E.g., { \"@odata.context\": \"~/$metadata#Crm_Customers\", \"value\": [ { \"@odata.id\":\"Crm_Customers(79480957-f0b6-49c4-9874-2cd150de982a)\", \"Number\": \"aa00015\" }, { \"@odata.id\":\"Crm_Customers(806637f2-abd1-4e7b-8ac0-71222a0b1afd)\", \"Number\": \"ab30151\" }, { \"@odata.id\":\"Crm_Customers(f812a533-0e56-4e57-8d1f-52d05b98c8b6)\", \"Number\": \"ab30156\" } ] } The result contains all customers that contain 015 in their number. OK, let's make an another try: GET ~/Crm_Customers?$select=Party&$expand=Party($select=PartyName)&$search=\"UNI\" Here's the result: { \"@odata.context\": \"~/$metadata#Crm_Customers\", \"value\": [ { \"@odata.id\":\"Crm_Customers(eebf02a5-052e-4a8d-9a24-270546d73942)\", \"Party\": { \"@odata.id\":\"General_Contacts_Parties(b8aa4272-3e55-435b-b1ab-170afee896d4)\", \"PartyName\": { \"EN\": \"UNI Sofia Ltd\", \"BG\": \"УНИ София Лтд\" } } } ] } Obviously, the result contains all customers, having a \"UNI\" in their name. The examples above were when we have a match on the default search members- i.e. the Number and Party.PartyName in the Customers entity. Let's see an example where the search will be performed on the members, defined in the entity's display text attribute. To do this, we'll first change the display text format for the customers entity (because the default one is {Party.PartyName:T}) to the following one: {Party.PartyName:T} / {GracePeriodDays} Now if we make a request such as: GET ~/Crm_Customers?$select=Number,GracePeriodDays,Party&$expand=Party($select=PartyName)&$search=\"50\" The result will be the following: { \"@odata.context\": \"~/$metadata#Crm_Customers\", \"value\": [ { \"@odata.id\":\"Crm_Customers(eca3ca4d-c4fa-44df-9983-d69388a8893a)\", \"GracePeriodDays\": 50, \"DisplayText\": \"Test Company 1 Ltd / 50\", \"Number\": \"number001\", \"Party\": { \"@odata.id\":\"General_Contacts_Parties(841e89e4-44c2-4c8f-b4d9-6402c3e5fb28)\", \"PartyName\": { \"EN\": \"Test Company 1 Ltd\" } } }, { \"@odata.id\":\"Crm_Customers(bc446b31-7326-4c35-bca6-55c918e33215)\", \"GracePeriodDays\": 7, \"DisplayText\": \"Test Company 2 Ltd / 7\", \"Number\": \"number050\", \"Party\": { \"@odata.id\":\"General_Contacts_Parties(395fa6b1-8fd4-418a-87f6-d8bece1fc7ad)\", \"PartyName\": { \"EN\": \"Test Company 2 Ltd\" } } } ] } Two customers- the first has a match on the attribute GracePeriodDays (50) and the second has a match on the Number (number050) attribute."
  },
  "domain-api/querying-data/query-options/select.html": {
    "href": "domain-api/querying-data/query-options/select.html",
    "title": "$select query option | ERP.net Developer Docs",
    "summary": "$select query option Description $select is an OData system query option. The $select system query option allows clients to request a specific set of properties for each entity or complex type. For a great introduction to $select, read the OData $filter tutorial. $expand The $select query option is often used in conjunction with the $expand system query option, to define the extent of the resource graph to return ($expand) and then specify a subset of properties for each resource in the graph ($select). Expanded navigation properties MUST be returned, even if they are not specified as a selectItem. Default attributes When there is no $select clause or '$select=*', only the default attributes are returned. The attributes, which are returned by default are: System attributes like Name, Description, PartNumber, etc. References like ProductType, ProductGroup, etc (in OData terminology - Navigation properties) The following attributes are not returned by default: The 'Id' attribute Custom (user-defined) attributes Child lists (OData terminology: Collection navigation properties) Calculated attributes Example: GET ~/General_Products_ProductTypes?$top=2 The result is: { \"@odata.context\": \"https://example-server.com/example-db/api/domain/odata/$metadata#General_Products_ProductTypes\", \"value\": [ { \"@odata.id\": \"General_Products_ProductTypes(c696c660-9aa4-4fe5-a396-126af4101792)\", \"IsDefault\": false, \"IsFixedAsset\": false, \"IsServiceActivityService\": false, \"IsServiced\": true, \"IsShipped\": true, \"IsStocked\": true, \"LotAutoCreation\": true, \"Code\": \"001\", \"Name\": { \"BG\": \"sdds\" } }, { \"@odata.id\": \"General_Products_ProductTypes(880b0c31-a9ef-4a3c-a0e7-13d39aa57464)\", \"IsDefault\": false, \"IsFixedAsset\": false, \"IsServiceActivityService\": false, \"IsServiced\": false, \"IsShipped\": false, \"IsStocked\": false, \"LotAutoCreation\": false, \"Code\": \"test sch\", \"Name\": { \"BG\": \"test sch\" } } ] } Note Non default properties must be explicitly specified in the $select clause. Example: GET ~/General_Products_Products?$top=2&$select=CustomProperty_WebName,CalculatedAttribute_ExampleAttr The result will only contain the selected properties. The default $select keyword You can explicitly use the keyword default in the $select clause to include all default properties. GET ~/General_Products_Products?$top=2&$select=default,CustomProperty_WebName,CalculatedAttribute_ExampleAttr The result will contain all default properties plus the selected CustomProperty_WebName and CalculatedAttribute_ExampleAttr."
  },
  "domain-api/querying-data/query-tool.html": {
    "href": "domain-api/querying-data/query-tool.html",
    "title": "ERP.net Query Tool | ERP.net Developer Docs",
    "summary": "ERP.net Query Tool The ERP.net Query Tool allows you to experiment with Domain API requests directly in the browser. It is available in every ERP.net instance. It supports all HTTP methods, so you can run: GET queries to retrieve data POST requests to create new entities or execute actions PATCH requests to update existing entities DELETE requests to remove entities You can also provide a JSON payload for POST and PATCH requests, allowing you to test complex object creation or updates. Try it here: ERP.net Query Tool Example usage: Select the HTTP method (GET, POST, PATCH, DELETE) Enter the entity set name and any query parameters Provide JSON payload for POST or PATCH Execute the request and view the JSON response directly in the browser"
  },
  "domain-api/querying-data/url-components.html": {
    "href": "domain-api/querying-data/url-components.html",
    "title": "URL components of an OData query | ERP.net Developer Docs",
    "summary": "URL components of an OData query https://demodb.my.erp.net/api/domain/odata/General_Products_Products?$top=10&$orderby=Name \\_________________________________________/\\_______________________/ \\___________________/ | | | service root URL resource path query options Service Root URL - this is the address of the API + /domain/odata/ Resource Path - The requested entity Query Options - optional query options NOTES: The address of the API is usually and by default: https://<<Instance_Name>>.my.erp.net/api/ However, this is not certain. Each site in ERP.net can have its own address, which is configurable. For example, this is also valid address: https://erpapi.example.com/ The ERP.net API Resource Path supports only specifying a single entity. REST style sub-entities are not supported. However, the API allows many other ways to expand into sub-entities. Query Options Allow the user to specify optional Query Options. For more information, visit the OData standards page: http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_URLComponents"
  },
  "domain-api/samples/build-ecommerce-website.html": {
    "href": "domain-api/samples/build-ecommerce-website.html",
    "title": "Build E-Commerce Website | ERP.net Developer Docs",
    "summary": "Build E-Commerce Website"
  },
  "domain-api/samples/build-payment-connector.html": {
    "href": "domain-api/samples/build-payment-connector.html",
    "title": "Build Payment Connector | ERP.net Developer Docs",
    "summary": "Build Payment Connector The Payment Connector sample demonstrates connecting ERP.net with Stripe. The app demonstrates simplified workflow: Internal user logins interactively. The most recent 10 payment orders, accessible by the user, are displayed. The user chooses a payment order. The selected payment order is exported to a demo Stripe account. After a demo payment is made, the app creates a Payment Transaction with the payment details. The app includes the following basic tasks: Register UI app. Login interactive. List Payment Orders. Create Payment Transaction. The app is written entirely in JavaScript and hosted in GitHub Pages. You can access the app source project here. To run the application, click here. You can use admin/123 for internal user logon."
  },
  "domain-api/samples/dotnet-service-app.html": {
    "href": "domain-api/samples/dotnet-service-app.html",
    "title": "Dot Net Service Application | ERP.net Developer Docs",
    "summary": "Dot Net Service Application This app demonstrates a Service Application created in .net. Register Trusted Application See source in GitHub"
  },
  "domain-api/samples/dotnet-web-app.html": {
    "href": "domain-api/samples/dotnet-web-app.html",
    "title": "Dot Net Web Application | ERP.net Developer Docs",
    "summary": "Dot Net Web Application Register Trusted Application See source in GitHub"
  },
  "domain-api/samples/index.html": {
    "href": "domain-api/samples/index.html",
    "title": "| ERP.net Developer Docs",
    "summary": ""
  },
  "domain-api/samples/javascript-client.html": {
    "href": "domain-api/samples/javascript-client.html",
    "title": "Javascript Interactive Client | ERP.net Developer Docs",
    "summary": "Javascript Interactive Client Register Public Trusted Application See source in GitHub For more detailed tutorial for authentication, see https://identityserver4.readthedocs.io/en/latest/quickstarts/4_javascript_client.html"
  },
  "domain-api/samples/php-interactive-client.html": {
    "href": "domain-api/samples/php-interactive-client.html",
    "title": "PHP Interactive Web Application | ERP.net Developer Docs",
    "summary": "PHP Interactive Web Application Register Confidential Trusted Application See source in GitHub"
  },
  "domain-api/samples/php-service-client.html": {
    "href": "domain-api/samples/php-service-client.html",
    "title": "PHP Service Application | ERP.net Developer Docs",
    "summary": "PHP Service Application Register Service Trusted Application See source in GitHub"
  },
  "domain-api/samples/src/dotnet/ErpNetDemoClient/wwwroot/lib/jquery-validation/LICENSE.html": {
    "href": "domain-api/samples/src/dotnet/ErpNetDemoClient/wwwroot/lib/jquery-validation/LICENSE.html",
    "title": "The MIT License (MIT) | ERP.net Developer Docs",
    "summary": "The MIT License (MIT) Copyright Jörn Zaefferer Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "includes/erpnet.html": {
    "href": "includes/erpnet.html",
    "title": "| ERP.net Developer Docs",
    "summary": "ERP.net"
  },
  "includes/name.html": {
    "href": "includes/name.html",
    "title": "| ERP.net Developer Docs",
    "summary": "ERP.net"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the ERP.net Developer Documentation | ERP.net Developer Docs",
    "summary": "Welcome to the ERP.net Developer Documentation Here you will find all the necessary resources for building applications targeting the ERP.net services. This documentation contains developer resources. For business logic and other technical documentation, you might want to check the Technical Documentation. ERP Instances The ERP.net service is a hosted ERP service. Accessing the data is done through ERP Instances. When you sign up at erp.net, you can create and manage a new ERP Instance. An ERP Instance is a tenant in the hosting environment. It is multi-company, e.g. it allows managing multiple related legal entities (companies) in one instance. You don't need to create separate instances for each managed company. Each ERP Instance has a unique name. The instance can be accessed at: https://<<instance_name>>.my.erp.net For example, the demonstration database, DEMODB, is located at: https://demodb.my.erp.net The API Each ERP Instance CAN have an API site. It \"can\" have, because, the API is a site, similar to other sites, which the instance can launch. In order for the API to function, it needs to be configured and launched for the ERP Instance. The common URL for the API site is /api/ inside the ERP instance. For example, the DEMODB has an API site at: https://demodb.my.erp.net/api/ The Domain API The Domain API is the primary means for accessing and manipulating data in the ERP Instance. It can currently be consumed in OData 4 format. The Domain API is an API proxy for the object-oriented Domain Model of ERP.net. It is targeted towards UI and service apps. These kinds of apps usually read and update moderate amounts of data. The Domain API is NOT adequate for read-only dumping of very large amounts of data, which is usually done by BI applications. BI applications should find other solutions or try to read data in small chunks. The Domain API is located at /domain/odata/ within the API site. For DEMODB, this is at: https://demodb.my.erp.net/api/domain/odata/ Tip User: Admin Password: 123 If you try the above link, it will ask you for user credentials. Most ERP Instances should, by default, be configured to NOT accept basic authentication. However, for demonstration purposes, DEMODB is configured to allow it. Sample Query OData v4 allows the creation of URL-based queries. For example, to take the first 10 products (in undefined order), you can use: https://demodb.my.erp.net/api/domain/odata/General_Products_Products?$top=10 [!NOTE:] The above will return unformatted JSON result, intended to be consumed by client app. For a quick overview of OData, see this topic - Understand OData in 6 steps. The Query Builder ERP.net has integrated visual Query Builder. The Query Builder allows building queries, specific to the ERP Instance. When you use the Query Builder, it allows you to select the user-defined data and calculated attributes in that instance. The Query Builder allows the developers to create the query visually and then just re-use the query text, replacing the parameters. To access the Query Builder for DEMODB, go to: https://demodb.my.erp.net/api/domain/querybuilder While the query is built, the Query Builder changes its URL. For example, to preview the same query for the first 10 products in the Query Builder, head to: https://demodb.my.erp.net/api/domain/querybuilder#General_Products_Products?$top=10 When you press Execute in the Query Builder, you can preview the result both as a table and as JSON. Note Pay attention to the link under the selected entity, which opens the documentation for the entity. The Query Tool The Query Tool is a simple Postman-like tool for querying the database. It does not have the visual building abilities of the Query Builder. However, it can represent all possible REST requests and is very simple to use. Note The Query Tool is the default tool, which is used to represent queries in forum posts, tickets, etc. To access the Query Tool for DEMODB, go to: https://demodb.my.erp.net/api/domain/query Query Basics ERP.net allows only a subset of the full OData queries. Generally, you cannot do JOINs and filter with OR. However, you can filter by multiple values, like the SQL IN operator: https://demodb.my.erp.net/api/domain/odata/General_Products_Products?$top=10&$filter=Id%20in%20(edf2bd2a-7e4d-e111-a06c-00155d00050a,cf728601-1fd5-4853-ab23-01deeee7d038) Instance API Reference Each ERP Instance has its own API reference documentation. The instance-specific API reference documentation is like the Model docs. The main difference is that the reference documentation of a specific ERP Instance lists also the user-defined attributes. The user-defined attributes can be queried mostly like the system attributes. The instance reference documentation of DEMODB is at: https://demodb.my.erp.net/api/domain/docs Tip Since the instance API reference contains user-defined objects from the database, it is accessible only after authentication. For general-purpose information, check the Model. Security Someone said: \"Security is hard, deal with it\". The hard truth is that security today is much harder than it was 10 years ago. Once upon a time, there was a user and a password. Today, we have OAuth with Trusted Apps, Security Tokens, complicated security workflows, and all the other things. There are some good things, though. Single Sign-On, multi-factor authentication, and other extras come to mind. But, at the end of the day, you have to do much more work to create a secure app. ERP.net is based on the OAuth 2 security paradigm with OpenID Connect support. For more information about security, read Introduction to authentication in ERP.net. Next Steps Continue with the main documentation sections: Building Apps Learn how to design, configure, and build integrations and applications. Authentication and Authorization Understand identity, tokens, flows, scopes, and security configuration. For API-specific work, see: Domain API documentation Reference and guides for working with ERP.net business objects and logic. Domain Model Reference information about entities, relationships, business rules, and operations."
  },
  "table-api/index.html": {
    "href": "table-api/index.html",
    "title": "Table API | ERP.net Developer Docs",
    "summary": "Table API The primary purpose of the Table API is to allow external BI (Business Intelligence) tools to quickly pull raw data for further analysis. Authentication The Table API supports the following types of authentication: OAuth 2.0 Basic Authentication Caution Although Basic Authentication is supported, its use is strongly NOT recommended due to its significantly lower level of security. For more information, see Authentication. Tables For information about the tables that can be queried, see the Table Model. Best practices for refreshing data when building external BI systems based on a TableAPI site Introduction The first step in building a BI system is loading (Extract) data from the source database. This is done using a TableAPI site that allows an authorized user to access raw data at the table level. It is essential to achieve optimal transfer speed by using the capabilities provided for filtering the primary information to minimize data refresh time. For this reason, we describe best practices when using TableAPI (OData) data source to power PowerBI and BI data analysis platforms in general. The information is organized with increasing complexity and presented through examples for ease of understanding, allowing for step-by-step code copying and testing. Following these guidelines is necessary to avoid potential errors and delays when loading data. There are two main ways to download data: Using OData.Feed to read data from the source Using Web.Contents to read data from the source In both approaches, you must manually set parameters and filters for queries to achieve optimal results. This includes specifying the fields returned by the query (listed in the select clause) and setting the filter that will be applied to determine the data. Filters can be applied either on fields of the table that will be loaded, or on related tables at a higher level in the hierarchical model. This means that a table containing document rows can be filtered by fields in the document head (e.g., filtering by Document_Date), which will enable incremental refreshing of data. Both options use authentication via Basic identification (username and password). These access authorization parameters must be entered in both PowerBI Desktop and the PowerBI model published online. For a small database, it may be possible to skip the presets described below. However, as databases grow, BI models extend, and service configurations change, it becomes imperative to define initial parameters to be used throughout the entire BI project. Pre-defining and setting important common parameters The main parameters required for work are: RangeStart - System mandatory parameter when using incremental refresh, setting the start time for a subperiod RangeEnd - System required parameter when using incremental refresh, setting the end time for a subperiod TopCount - User parameter to facilitate project editing, containing the number of records to download baseURL - User parameter specifying a site (TableAPI) from which data is downloaded The RangeStart and RangeEnd parameters are of type Date/Time and must have values set so that preview data can be loaded when working with the model in PowerBI Desktop. The TopCount parameter is of type Decimal number and sets the number of records to be fetched with a single query. In the PowerBI Desktop development environment, this should be a relatively small value, such as 500, so that preview data can be loaded quickly. The baseURL parameter is of type Text and contains the address of the TableAPI site. It's good to define it this way because it can be easily changed from one location in the entire project should any change occur. For example, it could have the following value: \"https://test-tableAPI.erp.net\" Picture 1 Loading model information Select \"OData feed\" from the menu using the \"New source\" button. Fill in the data as shown in the picture (assuming we have defined the baseURL parameter as shown above). Picture 2 The available objects data will be loaded, allowing you to see what each one looks like. This is necessary to determine the field names you'll need to filter by or use when filtering by a reference field. The following picture shows what the Crm_Sales_Orders object looks like, particularly the field used to reference the document head needed for filtering (the Document_Reference field). Picture 3 You can choose to load data directly this way, as it supports additional filtering by fields in the table and selecting which fields to load. This method does NOT SUPPORT filtering by reference fields and is therefore not applicable if incremental refresh is to be used! Loading data via OData.Feed reading from source This method is suitable for testing only in PowerBI Desktop because it is NOT SUPPORTED by online PowerBI. It is described here as it provides basic insights into understanding and working with TableAPI queries. Some of the steps described below are also applicable to other data sources. General guidelines for operation are provided through the following points: Set the data source for each Query that uses TableAPI in the first step (Source) as follows: = OData.Feed(baseURL & \"/tableapi/odata/{Table_Name}{Parameters}\", null, [Implementation=\"2.0\"]) {Table_Name} - replaced with the name of the table to be loaded, e.g., Gen_Documents {Parameters} - replaced with OPTIONAL parameters to the query If access authorization is not set yet, you must select one with Basic type and specify the values of the \"User name\" and \"Password\" parameters for the user who has access to the TableAPI application. The parameter section (if present) must begin with a \"?\" symbol. Parameters are separated from one other by the \"&\" symbol. Possible parameters are: \"$filter=\" - Specifies the conditions that the returned data will meet \"$select=\" - Sets the fields to be returned by the query \"$top=\" - Sets the maximum number of records to return from the query Use permanent filtering. Add the appropriate filter in the URL using the options supported by TableAPI. An example of filtering table Gen_Document by active (Void=false) and released (State>=30) documents: let Source = OData.Feed(baseURL & \"/tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30\", null, [Implementation=\"2.0\"]) in Source To get this step code, you can add the following in the OData source URL (in addition to the one shown in picture 2): /tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30 Add filtering by fields with listed values. To the above example, you also need to add filtering by Entity_Name for values 'Inv_Transactions' and 'Crm_Sales_Orders': =OData.Feed(baseURL & \"/tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30 and Entity_Name in ('Inv_Transactions','Crm_Sales_Orders')\", null, [Implementation=\"2.0\"]) Note that TableAPI supports filtering by enumerated values, and this can be done directly from the PowerBI Desktop interface. Here is what the query generated by PowerBI Desktop looks like before adding the filtering: HTTP GET /tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30&$top=1000 This happens if the Void and State filterings for Gen_Documents, as well as Gen_Documents, are selected entirely through the interface. The steps generated in this process can be viewed in the Advanced editor: let Source = OData.Feed(baseURL & \"/tableapi/odata/\", null, [Implementation=\"2.0\"]), Gen_Documents_table = Source{[Name=\"Gen_Documents\",Signature=\"table\"]}[Data], #\"Filtered Rows\" = Table.SelectRows(Gen_Documents_table, each([Void] = false)), #\"Filtered Rows1\" = Table.SelectRows(#\"Filtered Rows\", each [State] >= 30) in #\"Filtered Rows1\" Through the interface, we can also add Entity_Name filtering as shown in the following picture: Picture 4 This will trigger the creation of the next step with code: = Table.SelectRows(#\"Filtered Rows1\", each([Entity_Name] = \"Crm_Sales_Orders\" or [Entity_Name] = \"Inv_Transactions\")) The following query will be executed to the data source, where the addition from this filtering is shown: HTTP GET /tableapi/data/Gen_Documents?$filter=Void eq false and State ge 30 and (Entity_Name eq 'Crm_Sales_Orders' or Entity_Name eq 'Inv_Transactions')&$top=1000 This example shows the support in the TableAPI filter construct: and (Field_Name eq 'Value1' or Field_Name eq 'Value2' ... or Field_Name eq 'ValueN') Everything described in this section can be used for nomenclatures that will be fully loaded or do not need filtering by reference fields. Filtering by date type fields. As an example, we will use the Document_Date field to select documents only from the first 6 months of the year: =OData.Feed(baseURL & \"/tableapi/odata/Gen_Documents?$filter=Void eq false and State ge 30 and Document_Date ge 2023-01-01T00:00:00Z and Document_Date le 2023-06-30T00:00:00Z\", null, [Implementation=\"2.0\"]) Note the date format 'YYYY-MM-DDThh:mm:ssZ' and respect it when using dates. Filter by referenced fields (fields from related tables that are not present in the current table). An example of such a query is filtering records from the Inv_Transactions table by taking only those for active (Void=false) and released (State>=30) documents: =OData.Feed(baseURL & \"/tableapi/odata/Inv_Transactions?$filter=Document_Reference/Void eq false and Document_Reference/State ge 30\", null, [Implementation=\"2.0\"]) This filtering is similar to the one in step 2, the only difference being a reference to the field by which we will filter. You can define the names of the fields pointing to reference tables as shown in picture 3. In order to support filtering by reference, this needs to be explicitly documented in the Table model documentation. Filter by fields from tables present in the Owner Tables Hierarchy list. Filtering by fields for tables present in the Owner Tables Hierarchy list described in the Table model documentation is always supported! Additionally, you can filter on a field that is not in a directly related table (located more than one level away in the hierarchy). For example, if we want to filter Inv_Transaction_Lines by a date of the document in which the rows are included (Document_Date field of Gen_Documents), we must pass through two consecutive references as shown in the example: =OData.Feed(baseURL & \"/tableapi/odata/Inv_Transaction_Lines?$filter=Transaction_Reference/Document_Date ge 2023-01-01T00:00:00Z and Transaction_Reference/Document_Reference/Document_Date le 2023-01-31T23:59:59Z\", null, [Implementation=\"2.0\"]) This is due to the hierarchical relationship between the tables, which follows a certain connectivity scheme (Field(Table) format): Transaction_Reference(Inv_Transaction_Lines) -> Transaction_Id(Inv_Transactions) Document_Reference(Inv_Transactions) -> Id(Gen_Documents) Filter data by the date of the document in which it is included. Using OData feed does NOT allow incremental refresh of data. The example below uses Web.Contents as a way to fetch data: =Json.Document(Web.Contents(baseURL & \"/tableapi/odata/Inv_Transaction_Lines\",[Query=[#\"$filter\" = \"Transaction_Reference/Document_Reference/Document_Date ge \" & DateTime.ToText(RangeStart,[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"]) & \" and Transaction_Reference/Document_Reference/Document_Date le \" & DateTime.ToText(Date.EndOfDay(Date.AddDays(RangeEnd,-1)),[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"])]], 65001) Since a comparison using 'le' (operator <=) must be used, the following statement calculates the correct end date of the period: Date.EndOfDay(Date.AddDays(RangeEnd,-1)) Important In the filter, you can use only: The logical operator 'and' The comparison operators 'eq', 'le', 'ge' The operator 'like' The comparison operator with list of values 'in' If a logical OR operator is needed in the filter, the query must be split into several separate queries that do not contain OR, which are then combined into a single query using \"Append queries\". An exception is the above-described statement for filtering by enumerated values of the type: **and (Field eq 'Value1' or Field eq 'Value2' ... or Field eq 'ValueN')** <br> which is equivalent to the standard supported statement: **and Field in ('Value1', 'Value2', ...,'ValueN')** <br> In PowerBI, it is possible to set up incremental updating. For this purpose, you must create two parameters (RangeStart, RangeEnd) of type DateTime whose values automatically change according to the incremental updating policy set for the specific object in PowerBI. Here, it is necessary to manually modify the query after the initial URL is set, because there is no way to add the information from the input parameters formatted in the desired way. Using incremental refresh to accelerate data updates in PowerBI To achieve filtering for lines and other tables by the Document_Date field of the document head, it is necessary to filter by a reference field. However, an incremental refresh problem will then arise. It is not possible to set the required filtering without manually setting parameters by which to filter, and PowerBI online does not support refreshing from the source that was set this way. It is imperative that you set the general parameters described at the beginning of this article before proceeding! Data loading via Web Content with the ability to filter by reference fields and compatibility with incremental refresh Let's apply the following approach: Use Web Content as data source Manually set all possible filters that should be applied in the data source to reduce the transferred data as much as possible Manually set the list of fields to be returned to reduce the amount of data Convert the returned data to JSON Convert the result to a table, after which other processings can continue It is easiest to use the example provided, which can be changed as needed. An example of data filtering for table Crm_Sales_Order_Lines_Table: let strEntity = \"Crm_Sales_Order_Lines\", strEntityHeadReference = \"Sales_Order_Reference\", strSelectFields = \"\", strEntHead = strEntityHeadReference & (if strEntityHeadReference = \"\" then \"\" else \"/\"), strDocHead = strEntHead & \"Document_Reference/\", strFilter = strDocHead &\"Void eq false and \" & strDocHead & \"State ge 30 and \" & strDocHead & \"Document_Date ge \" & strRangeStart &\" and \" & strDocHead & \"Document_Date le \"& strRangeEnd, strRangeStart = DateTime.ToText(DateTime.From(RangeStart),[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"]), strRangeEnd = DateTime.ToText(Date.AddDays(DateTime.From(RangeEnd),-1),[Format=\"yyyy-MM-dd'T'HH:mm:ss'Z'\", Culture=\"en-US\"]), Source1 = Json.Document(Web.Contents(baseURL & \"/tableapi/odata/\" & strEntity, [Query=[#\"$filter\" = strFilter, #\"$select\" = strSelectFields, #\"$top\" = Text.From(TopCount)], Timeout=#duration(0, 2, 0, 0)]), 65001), ResultList = Source1[value], value = if List.NonNullCount(ResultList) = 0 then List.Union({ResultList, {null}}) else ResultList, #\"Converted to Table\" = Table.FromList(value, Splitter.SplitByNothing(), null, null, ExtraValues.Error), #\"Result\" = Table.ExpandRecordColumn(#\"Converted to Table\", \"Column1\", {\"Sales_Order_Id\", \"Line_No\", \"Product_Id\", \"Quantity\", \"Quantity_Unit_Id\", \"Product_Price_Id\", \"Unit_Price\", \"Line_Discount_Id\", \"Line_Standard_Discount_Percent\", \"Line_Custom_Discount_Percent\", \"Line_Amount\", \"Line_Store_Id\", \"Requested_Quantity\", \"Quantity_Base\"}, {\"Sales_Order_Id\", \"Line_No\", \"Product_Id\", \"Quantity\", \"Quantity_Unit_Id\", \"Product_Price_Id\", \"Unit_Price\", \"Line_Discount_Id\", \"Line_Standard_Discount_Percent\", \"Line_Custom_Discount_Percent\", \"Line_Amount\", \"Line_Store_Id\", \"Requested_Quantity\", \"Quantity_Base\"}) in #\"Result\" Add new table with incremental refresh capability (step-by-step) Switch to edit data sources mode (select from Home -> Queries -> Transform data). Create a new query (table) from Home -> New Source -> Blank Query. Then, navigate to Home -> Query -> Advanced editor to open the window in which the M code of the query is written. The result is as follows: Picture 5 Replace the text in the window with the above sample text (for Crm_Sales_Order_Lines_Table). Edit the value of the strEntityHeadReference variable with the reference field pointing to the new entity whose will be loaded. Edit the value of strEntity with the name of the new entity. If it will be loaded from the head of the entity, the field must be empty. If you are going to load Crm_Sales_Orders_Table, for example, edit the fields as follows: strEntity = \"Crm_Sales_Orders\", strEntityHeadReference = \"\", If it is loaded from Gen_Documents, then change the strDocHead to: strDocHead = \"\", Then, select the columns to be included in the table by deleting the last step of the conversions. Using the expanding feature (the yellow highlighted icon) from the \"Converted to Table\" step, we select the necessary fields as shown in the picture: Picture 6 This assumes that the string in strSelectFields is empty (strSelectFields=\"\"). If it is filled with certain fields like: strSelectFields=\"Sales_Order_Id, Customer_Id, Store_Id, Sales_Person_Id, Dealer_Id, Document_Currency_Id\", then only these will be visible, and only they will be returned from TableAPI, which will save time in data transfer and speed up loading. For this reason, specifying the field names to be returned by the query is highly recommended. Picture 7 There is one line in the code above: value = if List.NonNullCount(ResultList) = 0 then List.Union({ResultList, {null}}) else ResultList, which may seem redundant but is very important for the synchronization to run without error. It is used to check the returned result, and if no data is returned, an empty line is added. Missing data causes an error in the next steps of conversion to the tabular form in which we need the data. An error would occur if any information is missing in any incremental refresh period. Executing the code above will result in sending the following data fetch command: HTTP GET /tableapi/data/Crm_Sales_Orders?$filter=Document_Reference/Void eq false and Document_Reference/State ge 30 and Document_Reference/Document_Date ge 2015-01-01T00:00:00Z and Document_Reference/Document_Date le 2024-01-09T00:00:00Z&$select=Sales_Order_Id, Customer_Id, Store_Id, Sales_Person_Id, Dealer_Id, Document_Currency_Id&$top=500 The Document_Date filtering and the value of the $top parameter are determined by the parameters we have defined. This applies to PowerBI Desktop queries. When querying from online PowerBI with incremental update defined for the object, the parameter values will be automatically filled, and separate queries will be generated and executed for each update period. Once the project is published to PowerBI, the first thing to set is chaning TopCount parameter to a large enough value, for example 500000000. After that, a manual Refresh can be run at an appropriate time as this will cause the data to be fully loaded (from the processing period set in the incremental refresh). Let's also pay attention to the Timeout parameter set in this sample query: Timeout=#duration(0, 2, 0, 0) It is used to set the timeout of a single data download request. The above setting changes it to 2 hours. This is the maximum time given to one request (each incremental period) at a time. In PowerBI, this value defaults to 600 seconds, which can be insufficient, especially during the initial data load when the archive period data is loaded. The default time for a single query may not be enough if the settings are as follows: Picture 8 Archival data periods will be 1 year in size. This means the amount of data to be loaded will be very large, and the query will be slow to execute. We need to increase the timeout, as we have done in the example, or change the period to an equivalent but with a smaller size. We can set the following: Archive data starting 60 Month before refresh date which is equivalent to the above settings, but the period of data processed with one query will be one month. This will reduce the execution time and the probability of timeout of single queries on initial data load. The archive period data is loaded once on the first Refresh after the project is published. Data loading in the periods defined by Incrementally refresh data is done on each Refresh, but the refresh time will not increase proportionally to the total data in the database - rather, to the volume of data in the periods being processed. The use of TableAPI allows multiple queries to pull data from the database simultaneously without overloading the server and disrupting the primary operations. Optimized loading of custom properties Custom properties are also used in the analyses performed in PowerBI. Since their volume is significant, it is very important for them to be loaded and used efficiently. Optimized loading of all necessary properties For this purpose, we use the following code defining a query named Gen_Property_Values: let Source = OData.Feed(baseURL & \"/tableapi/odata/\", null, [Implementation=\"2.0\"]), Gen_Property_Values_table = Source{[Name=\"Gen_Property_Values\",Signature=\"table\"]}[Data], #\"Filtered Rows1\" = Table.SelectRows(Gen_Property_Values_table, each ([Property_Id] = \"18eb8480-a19b-4336-b935-c2715730f988\" or [Property_Id] = \"28e65696-2d8e-4e22-9932-686737235d88\" or [Property_Id] = \"41324c1d-6f64-4fa3-85e4-4c99fcf4f407\" or [Property_Id] = \"46d58fad-4ef2-409e-ba92-b5c55f7ea20b\")), #\"Removed Other Columns\" = Table.SelectColumns(#\"Filtered Rows1\",{\"Entity_Item_Id\", \"Property_Id\", \"Property_Value\", \"Description\"}), #\"Filtered Rows\" = Table.Buffer(#\"Removed Other Columns\") in #\"Filtered Rows\" In this example, the four GUID feature numbers listed are randomly selected. You need to replace and supplement them with the IDs of the properties you need. The construct: ... or [Property_Id] = \"Guid\" can be reduced or expanded with more members. Note the following operation: #\"Filtered Rows\" = Table.Buffer(#\"Removed Other Columns\") It specifies that the data will be statically buffered in memory. In the next operations that use as a source Gen_Property_Values (the query we define), data will be retrieved from the buffer in the memory which will save significant re-fetching time. Another optimization comes from loading only the required fields listed in the Table.SelectColumns operation. This reduces the returned data and speeds up the query. This is possible thanks to the Folding support which is active when using an OData feed data source. Dividing the loaded properties by entities to which they refer The processing can continue by creating a new query (e.g., Entity1_Property_Values) with the following code: let Source = Gen_Property_Values, #\"Filtered Rows\" = Table.SelectRows(Source, each ([Property_Id] = \"41324c1d-6f64-4fa3-85e4-4c99fcf4f407\" or [Property_Id] = \"46d58fad-4ef2-409e-ba92-b5c55f7ea20b\") and ([Property_Value] <> null and [Property_Value] <> \"\")), #\"Added Custom\" = Table.AddColumn(#\"Filtered Rows\", \"Param1\", each if [Property_Id]=\"41324c1d-6f64-4fa3-85e4-4c99fcf4f407\" then [Property_Value] else null), #\"Added Custom1\" = Table.AddColumn(#\"Added Custom\", \"Param2\", each if [Property_Id] = \"46d58fad-4ef2-409e-ba92-b5c55f7ea20b\" then [Property_Value] else null), #\"Added Custom2\" = Table.AddColumn(#\"Added Custom1\", \"Descr1\", each if [Property_Id] = \"41324c1d-6f64-4fa3-85e4-4c99fcf4f407\" then [Description] else null), #\"Added Custom3\" = Table.AddColumn(#\"Added Custom2\", \"Descr2\", each if [Property_Id]=\"46d58fad-4ef2-409e-ba92-b5c55f7ea20b\" then [Description] else null), #\"Grouped Rows\" = Table.Group(#\"Added Custom3\", {\"Entity_Item_Id\"}, {{\"Par1\", each List.Max([Param1]), type nullable text}, {\"Descr1\", each List.Max([Descr1]), type nullable text}, {\"Par2\", each List.Max([Param2]), type nullable text}, {\"Descr2\", each List.Max([Descr2]), type nullable text}}) in #\"Grouped Rows\" In the first step, select the Gen_Property_Values query created earlier as the data source, which will buffer the data load. The next step performs filtering, taking the values of only two of the properties that apply to a single entity to optimize and reduce the data to process. They must not be null or empty (\"\"). If needed, the filtering list can be expanded or reduced according to the properties being processed and already loaded by the previous query. In the following steps, new columns are created that contain only values for a particular Property_Id. This is necessary to prepare data for grouping by Entity_Item_Id, which will convert the table into one with no more than one row for each entity. Afterwards, you can link it to the entity table to which the custom properties apply. These steps must be edited or completed for the specific Property_Id that are processed. As a final step, grouping by Entity_Item_Id is performed and data is ready to be associated with the entity data it refers to. If you add the link to the same query, the linking dialog would look something like this: Picture 9 The link must be Outher (not all records in the entity table have a match in the table with feature values), and in this case, it is Right because the base table where all data is stored is second (named Documents_ODATA). If we add the properties in Entity1_Property_Values to Documents_ODATA, then we would have a Join Kind of type Left Outer. Warning Reading data from the Gen_Property_Values_Table is always slow because it triggers a scan (full crawl) of the table, which is very large. This has a very negative impact on the SQL server and slows down the updating of PowerBI. Therefore, it is imperative to follow the recommended approach shown here! There may be other optimal methods, but the table scanning and large execution time of a query should always be considered. The only exception might be if you filter by a list of values for Entity_Item_Id, in which case the query will execute quickly as it will use SEEK in the database. However, due to the nature of BI, this option is likely not practical. When reading custom properties, there is no way to filter by the date of the document they refer to and therefore no way to use incremental refresh. That is why the example uses the standard OData feed as a data source. PowerBI setup after uploading the project These settings are required to set the access rights when connecting to the data source (in this case, TableAPI). It is important to configure the correct values for these settings to avoid creating additional problems and disturbances when loading the data. For each source (table) read from TableAPI when using the WEB Content access method, it is necessary to set the rights separately. For a source using OData Feed, the necessary access rights are set once. Only the Basic authentication method is supported! Picture 10 For these settings, it is necessary to check the \"Skip test connection\" box, as shown in the picture: Picture 11 For the OData source, you may leave this box empty. It is even advisable to first set the access for the OData source with an empty check box, verifying that the correct credentials (user, password) are set. If there is a problem, you will receive a notification. If everything is alright, you can proceed to configure the access for the other sources in the same way, but with the check box selected. As of version 23.2 SP4, it is no longer necessary to uncheck \"Skip test connection\", because the system behavior when disconnecting from TableAPI has been adjusted. Before the first run which loads the data after uploading the project, it is necessary to set the \"TopCount\" parameter to a value that does not limit the volume of the loaded data (e.g. 500000000, as shown in the picture). Be careful not to set a too large value for the parameter. The maximum allowed value is 2^31 (MAXINT), after which the query will return an error. Picture 12 If for whatever reason the data source has been renamed, this can be easily corrected here by changing the \"baseURL\" parameter to match the correct one, without needing to make project corrections and re-uploads. Conclusion Through these techniques, you are ready to take advantage of PowerBI's incremental refresh capability, which makes the refresh time relatively constant and proportional to the growth of data in the last selected refresh periods. This capability has been tested in practice with 4 parallel connections, which did not lead to a significant load on the TableAPI site, AppServer, or SQL Server. We can assume that Refresh even with 5-10 connections will still be within the permissible load limits and will not significantly affect the system's performance. However, it is best to track the specific refresh process to determine its impact and the load it causes. This will make it possible to choose appropriate values for the number of parallel refresh requests that are possible without interfering with the normal system operations."
  },
  "table-api/usage-guide.html": {
    "href": "table-api/usage-guide.html",
    "title": "Recommendations for using TableAPI as a data source for BI | ERP.net Developer Docs",
    "summary": "Recommendations for using TableAPI as a data source for BI Respecting the technical capabilities of the TableAPI, such as its filtering and data presentation capabilities, is necessary to ensure fast, efficient, and trouble-free operation. To achieve this, the following recommendations should be followed: Select only the necessary tables from which you will load data. Filter the table as early as possible by using solid constraints that the data must meet. Negative constructions, OR statements, and unsupported types of filtering should not be used. This should be aligned with the documentation for each field being filtered. For example, do not use \"<>\", \"<\", \">\", \"OR\", \"NOT\" as they are not supported. The supported constructions are \"AND\" ,\"=\" (including \"= null\"), \"<=\", \">=\". Remove unnecessary fields as early as possible. Here it matters whether you choose \"Remove other columns\" or \"Remove columns\" (different functions, where one keeps the listed columns and the other removes them). Use the former (\"Remove other columns\"), which will ensure that if there is a modification in the table structure, the result will remain the same. Supplement the data (add rows) from other sources if more complex data filtering containing OR clauses is required. All OR-separated filters should be divided into several sub-filters, where each sub-filter requires a separate query to the same table with the respective sub-filter. Finally, all these sub-queries should be combined into one table by appending queries. When filtering data based on related tables (filter is not on a field from the current table), use table merging (Merge queries), where the main table to which you are making a connection should already be filtered, and use the \"Inner join - only matching rows\" type of join. For example, if you need to filter only certain documents from Crm_Sales_Orders, you should first filter Gen_Documents for the desired documents (based on Entity_Name, Void, State, Document_Date, etc.), and then merge Crm_Sales_Orders with Gen_Documents using an Inner join and specifying the corresponding fields Document_Id (Crm_Sales_Orders) -> Id (Gen_Documents). If the tables have a relatively small volume (number of records), you may not need to follow the above filtering recommendations, as in that case, the entire table will likely be loaded into BI, and the filtering will be applied afterwards by BI."
  },
  "testinclude.html": {
    "href": "testinclude.html",
    "title": "| ERP.net Developer Docs",
    "summary": "The includes/erpnet.md file exists for the sole reason of containing the proper writing of \"ERP.net\". It is intended to be included inline in the text of other topics. Unfortunately, DocFX seems to handle the matter of inline-inclusion with a pretty heavy-weight syntax. Example: I can easily create a link to the erpnet topic. But this is a link. We need just to include the file contents. For more information: https://dotnet.github.io/docfx/tutorial/links_and_cross_references.html#shorthand-form I can include the file contents, but with a pretty heavy syntax ERP.net. This syntax is not adequate for everyday writing. For more information: https://dotnet.github.io/docfx/spec/docfx_flavored_markdown.html#inline Ideally, the following syntax should include the text inline: This is the ERP.net service! The above line should render as: This is the ERP.net service!"
  },
  "whats-new/index.html": {
    "href": "whats-new/index.html",
    "title": "What’s New in ERP.net | ERP.net Developer Docs",
    "summary": "What’s New in ERP.net The What’s New section highlights the latest updates and improvements for developers working with ERP.net. It includes detailed information about changes to the API, Data Model, and other developer-focused components. This page provides a clear overview of technical modifications, schema updates, and integration enhancements — helping developers stay aligned with the latest platform capabilities. You can explore the version-specific threads to review changes, migration notes, and new development tools introduced in each release. Version 26.2"
  },
  "whats-new/v26-2/index.html": {
    "href": "whats-new/v26-2/index.html",
    "title": "Version 26.2 | ERP.net Developer Docs",
    "summary": "Version 26.2 Reference Access Tokens (PAT, SAT) Now supported for long-lived, manually issued access - ideal for automation, scripts, and service integrations. ExecuteScript (Domain API) Execute raw JavaScript server-side via an unbound OData action, with full access to the Domain Model for querying and modifying data. Paging via @odata.nextLink (Domain API) Queries that include $top now return @odata.nextLink for server-driven paging. Depending on the query shape, the continuation link may use $skiptoken (keyset paging) or $skip (offset paging) - clients should always follow @odata.nextLink as an opaque URL. AggregateLastUpdateTimeUtc (Domain API) Aggregate root entities now expose AggregateLastUpdateTimeUtc, enabling incremental pull scenarios by filtering entities updated after a given UTC timestamp. Import ERP.net Domain API defines an Import endpoint which can be used to import multiple entities at once."
  }
}